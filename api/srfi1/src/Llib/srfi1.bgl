;*=====================================================================*/
;*    serrano/prgm/project/bigloo/api/srfi1/src/Llib/srfi1.bgl         */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Wed Feb 24 21:27:38 1999                          */
;*    Last change :  Fri Dec 13 12:48:32 2013 (serrano)                */
;*    -------------------------------------------------------------    */
;*    The Bigloo module clause for the srfi1 implementation            */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module __srfi1
   
   (option (set! *dlopen-init-gc* #t)
           (set! *dlopen-init* "bgl_dload_init_s_srfi1"))
   
   (export (xcons::pair d a)
	   (make-list::pair-nil ::int . el)
	   (list-tabulate::pair-nil ::int ::procedure)
	   (list-copy::pair-nil ::pair-nil)
	   (iota count . maybe-start+step)
	   (circular-list::pair val1 . vals)
	   (proper-list?::bool x)
	   (dotted-list?::bool x)
	   (circular-list?::bool x)
	   (list= = . lists)
	   (length+ x)
	   (zip::pair-nil ::pair-nil . more-list)
	   (first ::pair)
	   (second ::pair)
	   (third ::pair)
	   (fourth ::pair)
	   (fifth ::pair)
	   (sixth ::pair)
	   (seventh ::pair)
	   (eighth ::pair)
	   (ninth ::pair)
	   (tenth ::pair)
	   (car+cdr ::pair)
	   (take ::pair-nil ::int)
	   (take! ::pair-nil ::int)
	   (drop ::pair-nil ::int)
	   (take-right lis k)
	   (drop-right lis k)
	   (drop-right! lis k)
	   (split-at x k)
	   (split-at! x k)
	   (last ::pair-nil)
	   (unzip1 lis)
	   (unzip2 ::pair-nil)
	   (unzip3 ::pair-nil)
	   (unzip4 ::pair-nil)
	   (unzip5 ::pair-nil)
	   (append-reverse rev-head tail)
	   (append-reverse! rev-head tail)
	   (concatenate  lists)
	   (concatenate!  lists)
	   (count pred list1 . lists)
	   (unfold-right p f g seed . maybe-tail)
	   (unfold p f g seed . maybe-tail-gen)
	   (fold kons knil lis1 . lists)
	   (fold-left kons knil lis1 . lists)
	   (fold-right kons knil lis1 . lists)
	   (pair-fold-right f zero lis1 . lists)
	   (pair-fold-left f zero lis1 . lists)
	   (pair-fold f zero lis1 . lists)
	   (reduce f ridentity lis)
	   (reduce-left f lidentity lis)
	   (reduce-right f ridentity lis)
	   (append-map f lis1 . lists)
	   (append-map! f lis1 . lists)
	   (pair-for-each proc lis1 . lists)
	   (map! f lis1 . lists)
	   (filter-map f lis1 . lists)
	   (map-in-order f lis1 . lists)
	   (filter pred lis)
	   (filter! pred lis)
	   (partition pred lis)
	   (partition! pred lis)
	   (remove ::procedure lis)
	   (remove! ::procedure list)
	   (delete x lis . maybe-=)
;	   (delete! x lis . maybe-=)
	   (member x lis . maybe-=)
	   (delete-duplicates lis . maybe-=)
	   (delete-duplicates! lis . maybe-=)
	   (assoc x lis . maybe-=)
	   (alist-cons key datum alist)
	   (alist-copy alist)
	   (alist-delete key alist . maybe-=)
	   (alist-delete! key alist . maybe-=)
	   (find pred list)
	   (find-tail pred list)
	   (take-while pred lis)
	   (drop-while pred lis)
	   (take-while! pred lis)
	   (span pred lis)
	   (span! pred lis)
	   (break  pred lis)
	   (break! pred lis)
	   (any pred lis1 . lists)
	   (every pred lis1 . lists)
	   (list-index pred lis1 . lists)
	   (lset= = . lists)
	   (lset<= = . lists)
	   (lset-adjoin = lis . elts)
	   (lset-union = . lists)
	   (lset-union! = . lists)
	   (lset-intersection = lis1 . lists)
	   (lset-intersection! = lis1 . lists)
	   (lset-difference = lis1 . lists)
	   (lset-difference! = lis1 . lists)
	   (lset-xor = . lists)
	   (lset-xor! = . lists)
	   (lset-diff+intersection = lis1 . lists)
	   (lset-diff+intersection! = lis1 . lists)))
