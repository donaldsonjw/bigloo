diff -Naur gc-7.1alpha3.orig/Makefile.am gc-7.1alpha3/Makefile.am
--- gc-7.1alpha3.orig/Makefile.am	2008-02-20 21:15:04.000000000 +0100
+++ gc-7.1alpha3/Makefile.am	2008-02-21 07:08:51.000000000 +0100
@@ -49,7 +49,7 @@
 
 lib_LTLIBRARIES += libgc.la
 libgc_la_SOURCES = \
-	allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \
+	allchblk.c alloc.c inline-alloc.c blacklst.c checksums.c dbg_mlc.c \
 	dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \
 	malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \
 	obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \
@@ -74,7 +74,7 @@
 if USE_INTERNAL_LIBATOMIC_OPS 	 
 nodist_libgc_la_SOURCES = ./atomic_ops.c 	 
 endif 	 
-  	 
+	 
 if NEED_ATOMIC_OPS_ASM 	 
 nodist_libgc_la_SOURCES = ./atomic_ops_sysdeps.S 	 
 endif
@@ -200,7 +200,7 @@
 include cord/cord.am
 include tests/tests.am
 include doc/doc.am
-# Putting these at the top causes cord to be built first, and not find libgc.a
+# Putting these at the top causes cord to be built first, and not find lib$(BOOTLIBDIR)/libbigloogc-$(RELEASE).a
 # on HP/UX.  There may be a better fix.
 
 
diff -Naur gc-7.1alpha3.orig/Makefile.direct gc-7.1alpha3/Makefile.direct
--- gc-7.1alpha3.orig/Makefile.direct	2008-01-25 06:02:07.000000000 +0100
+++ gc-7.1alpha3/Makefile.direct	2008-02-21 07:10:41.000000000 +0100
@@ -1,3 +1,12 @@
+#*---------------------------------------------------------------------*/
+#*    Bigloo start                                                     */
+#*---------------------------------------------------------------------*/
+include ../../Makefile.config
+include ../../Makefile.misc
+#*---------------------------------------------------------------------*/
+#*    Bigloo stop                                                      */
+#*---------------------------------------------------------------------*/
+
 # This is the original manually generated Makefile.  It may still be used
 # to build the collector.
 #
@@ -19,7 +28,13 @@
 # ABI flag for assembler.  On HP/UX this is +A64 for 64 bit
 # executables.
 
-CC=cc $(ABI_FLAG)
+#*---------------------------------------------------------------------*/
+#*    Bigloo start (30 jul 2007)                                       */
+#*---------------------------------------------------------------------*/
+CC+=$(ABI_FLAG)
+#*---------------------------------------------------------------------*/
+#*    Bigloo end                                                       */
+#*---------------------------------------------------------------------*/
 CXX=g++ $(ABI_FLAG)
 AS=as $(AS_ABI_FLAG)
 #  The above doesn't work with gas, which doesn't run cpp.
@@ -326,12 +341,19 @@
 AR= ar
 RANLIB= ranlib
 
+#*---------------------------------------------------------------------*/
+#*    Bigloo start                                                     */
+#*---------------------------------------------------------------------*/
+INLOBJS= inline-alloc.o
+#*---------------------------------------------------------------------*/
+#*    Bigloo stop                                                      */
+#*---------------------------------------------------------------------*/
 
 OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o \
   headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o  \
   malloc.o stubborn.o checksums.o pthread_support.o pthread_stop_world.o \
   darwin_stop_world.o typd_mlc.o ptr_chck.o mallocx.o gcj_mlc.o specific.o \
-  gc_dlopen.o backgraph.o win32_threads.o thread_local_alloc.o
+  gc_dlopen.o backgraph.o win32_threads.o thread_local_alloc.o $(INLOBJS)
 
 CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c \
   headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c \
@@ -428,9 +450,15 @@
 
 # if AO_INSTALL_DIR doesn't exist, we assume that it is pointing to
 # the default location, and we need to build
+#*---------------------------------------------------------------------*/
+#*    Bigloo start                                                     */
+#*---------------------------------------------------------------------*/
 $(AO_INSTALL_DIR): 
 	CC=$(CC) $(srcdir)/configure_atomic_ops.sh
 	cd $(AO_SRC_DIR); $(MAKE) CC=$(CC) install
+#*---------------------------------------------------------------------*/
+#*    Bigloo stop                                                      */
+#*---------------------------------------------------------------------*/
 
 LEAKFLAGS=$(CFLAGS) -DFIND_LEAK
 
@@ -494,6 +522,21 @@
 	./if_not_there dont_ar_1 $(RANLIB) gc.a || cat /dev/null
 #	ignore ranlib failure; that usually means it doesn't exist, and isn't needed
 
+#*---------------------------------------------------------------------*/
+#*    Bigloo libraries start                                           */
+#*---------------------------------------------------------------------*/
+EOBJECTS=$(OBJS) dyn_load.o
+$(BOOTLIBDIR)/libbigloogc$(LIBSUF)$(LIBQ)-$(RELEASE).$(SHAREDSUFFIX): $(EOBJECTS)
+	@ $(MAKE) shared-lib \
+             LIBDEST=$@ \
+             SONAME=libbigloogc$(LIBSUF)$(LIBQ)-$(RELEASE).$(SHAREDSUFFIX) \
+             GCCLOSELIB= \
+             LDLIBS=$(EXTRAGCLIBS) \
+             OBJECTS="$(EOBJECTS)"
+#*---------------------------------------------------------------------*/
+#*    Bigloo libraries stop                                            */
+#*---------------------------------------------------------------------*/
+
 cords: $(CORD_OBJS) cord/cordtest $(UTILS)
 	rm -f dont_ar_3
 	./if_mach SPARC SOLARIS touch dont_ar_3
@@ -583,9 +626,9 @@
 	./if_mach SPARC "" $(CC) -c -o mach_dep1.o $(SPECIALCFLAGS) $(srcdir)/mach_dep.c
 	./if_mach SPARC "" ld -r -o mach_dep.o mach_dep1.o mach_dep2.o
 	./if_mach IA64 "" as $(AS_ABI_FLAG) -o ia64_save_regs_in_stack.o $(srcdir)/ia64_save_regs_in_stack.s
-	./if_mach IA64 "" $(CC) -c -o mach_dep1.o $(SPECIALCFLAGS) $(srcdir)/mach_dep.c
+	./if_mach IA64 "" $(CC) -c -o mach_dep1.o $(SPECIALCFLAGS) $(CPICFLAGS) $(srcdir)/mach_dep.c
 	./if_mach IA64 "" ld -r -o mach_dep.o mach_dep1.o ia64_save_regs_in_stack.o
-	./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c
+	./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(CPICFLAGS) $(srcdir)/mach_dep.c
 
 mark_rts.o: $(srcdir)/mark_rts.c $(UTILS)
 	rm -f mark_rts.o
@@ -631,14 +674,33 @@
 	./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses
 	./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) `./threadlibs`
 
+#*---------------------------------------------------------------------*/
+#*    Bigloo start                                                     */
+#*---------------------------------------------------------------------*/
 if_mach: $(srcdir)/if_mach.c $(srcdir)/include/private/gcconfig.h
-	$(HOSTCC) $(HOSTCFLAGS) -o if_mach $(srcdir)/if_mach.c
+	$(HOSTCC) -O -o if_mach $(srcdir)/if_mach.c -I$(srcdir)/include
 
 threadlibs: $(srcdir)/threadlibs.c $(srcdir)/include/private/gcconfig.h Makefile
 	$(HOSTCC) $(HOSTCFLAGS) -o threadlibs $(srcdir)/threadlibs.c
 
 if_not_there: $(srcdir)/if_not_there.c
-	$(HOSTCC) $(HOSTCFLAGS) -o if_not_there $(srcdir)/if_not_there.c
+	$(HOSTCC) -O -o if_not_there $(srcdir)/if_not_there.c -I$(srcdir)/include
+
+DClean: clean
+
+bigloo-clean: 
+	rm -rf libatomic_ops-install
+	rm -f config.log
+	rm -f libatomic_ops-1.2/config.log
+	rm -f libatomic_ops-1.2/src/atomic_ops/atomic_ops.o \
+              libatomic_ops-1.2/src/atomic_ops/atomic_ops_malloc.o \
+              libatomic_ops-1.2/src/atomic_ops/atomic_ops_stack.o
+	rm -f libatomic_ops-1.2/src/atomic_ops/libatomic_ops.a \
+              libatomic_ops-1.2/src/atomic_ops/libatomic_ops_gpl.a
+#*---------------------------------------------------------------------*/
+#*    Bigloo stop                                                      */
+#*---------------------------------------------------------------------*/
+clean: 
 
 clean: 
 	rm -f gc.a *.o *.exe tests/*.o gctest gctest_dyn_link test_cpp \
@@ -737,3 +799,12 @@
 		sed s/_GC_/GC_/g < $$file > tmp; \
 		cp tmp $$file; \
 		done
+
+#*---------------------------------------------------------------------*/
+#*    Bigloo start                                                     */
+#*---------------------------------------------------------------------*/
+inline-alloc.o: ../../runtime/Clib/inline-alloc.c
+	$(CC) $(CFLAGS) $< -c
+#*---------------------------------------------------------------------*/
+#*    Bigloo stop                                                      */
+#*---------------------------------------------------------------------*/
diff -Naur gc-7.1alpha3.orig/Makefile.direct~ gc-7.1alpha3/Makefile.direct~
--- gc-7.1alpha3.orig/Makefile.direct~	1970-01-01 01:00:00.000000000 +0100
+++ gc-7.1alpha3/Makefile.direct~	2008-02-21 07:08:51.000000000 +0100
@@ -0,0 +1,803 @@
+#*---------------------------------------------------------------------*/
+#*    Bigloo start                                                     */
+#*---------------------------------------------------------------------*/
+include ../../Makefile.config
+include ../../Makefile.misc
+#*---------------------------------------------------------------------*/
+#*    Bigloo stop                                                      */
+#*---------------------------------------------------------------------*/
+
+# This is the original manually generated Makefile.  It may still be used
+# to build the collector.
+#
+# Primary targets:
+# gc.a - builds basic library
+# c++ - adds C++ interface to library
+# cords - adds cords (heavyweight strings) to library
+# test - prints porting information, then builds basic version of gc.a,
+#      	 and runs some tests of collector and cords.  Does not add cords or
+#	 c++ interface to gc.a
+# cord/de - builds dumb editor based on cords.
+ABI_FLAG= 
+# ABI_FLAG should be the cc flag that specifies the ABI.  On most
+# platforms this will be the empty string.  Possible values:
+# +DD64 for 64-bit executable on HP/UX.
+# -n32, -n64, -o32 for SGI/MIPS ABIs.
+
+AS_ABI_FLAG=$(ABI_FLAG)
+# ABI flag for assembler.  On HP/UX this is +A64 for 64 bit
+# executables.
+
+#*---------------------------------------------------------------------*/
+#*    Bigloo start (30 jul 2007)                                       */
+#*---------------------------------------------------------------------*/
+CC+=$(ABI_FLAG)
+#*---------------------------------------------------------------------*/
+#*    Bigloo end                                                       */
+#*---------------------------------------------------------------------*/
+CXX=g++ $(ABI_FLAG)
+AS=as $(AS_ABI_FLAG)
+#  The above doesn't work with gas, which doesn't run cpp.
+#  Define AS as `gcc -c -x assembler-with-cpp' instead.
+
+# Redefining srcdir allows object code for the nonPCR version of the collector
+# to be generated in different directories.
+srcdir= .
+VPATH= $(srcdir)
+
+# Atomic_ops installation directory.  If this doesn't exist, we create
+# it from the included libatomic_ops distribution.
+AO_VERSION=1.2
+AO_SRC_DIR=$(srcdir)/libatomic_ops-$(AO_VERSION)
+AO_INSTALL_DIR=$(srcdir)/libatomic_ops-install
+
+CFLAGS= -O -I$(srcdir)/include -I$(AO_INSTALL_DIR)/include -DATOMIC_UNCOLLECTABLE -DNO_EXECUTE_PERMISSION -DALL_INTERIOR_POINTERS
+
+# To build the parallel collector on Linux, add to the above:
+# -DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC
+# To build the thread-capable preload library that intercepts
+# malloc, add -DGC_USE_DLOPEN_WRAP -DREDIRECT_MALLOC=GC_malloc -fpic
+# To build the parallel collector in a static library on HP/UX,
+# add to the above:
+# -DGC_HPUX_THREADS -DTHREAD_LOCAL_ALLOC -D_POSIX_C_SOURCE=199506L -mt
+# FIXME: PARALLEL_MARK currently broken on HP/UX.
+# To build the thread-safe collector on Tru64, add to the above:
+# -pthread -DGC_OSF1_THREADS
+
+# HOSTCC and HOSTCFLAGS are used to build executables that will be run as
+# part of the build process, i.e. on the build machine.  These will usually
+# be the same as CC and CFLAGS, except in a cross-compilation environment.
+# Note that HOSTCFLAGS should include any -D flags that affect thread support.
+HOSTCC=$(CC)
+HOSTCFLAGS=$(CFLAGS)
+
+# For dynamic library builds, it may be necessary to add flags to generate
+# PIC code, e.g. -fPIC on Linux.
+
+# Setjmp_test may yield overly optimistic results when compiled
+# without optimization.
+
+# These define arguments influence the collector configuration:
+# -DFIND_LEAK causes GC_find_leak to be initially set.
+#   This causes the collector to assume that all inaccessible
+#   objects should have been explicitly deallocated, and reports exceptions.
+#   Finalization and the test program are not usable in this mode.
+#
+# IMPORTANT: Any of the _THREADS options must normally also be defined in
+# the client before including gc.h.  This redefines thread primitives to
+# invoke the GC_ versions instead.  Alternatively, linker-based symbol
+# interception can be used on a few platforms.
+# -DGC_THREADS should set the appropriate one of the below macros,
+#   except -DGC_WIN32_PTHREADS, which must be set explicitly.
+# -DGC_SOLARIS_PTHREADS enables support for Solaris pthreads.
+#   (Clients should also define GC_SOLARIS_THREADS and then include
+#   gc.h before performing thr_ or dl* or GC_ operations.)
+#   Must also define -D_REENTRANT.
+# -DGC_IRIX_THREADS enables support for Irix pthreads.  See README.irix.
+# -DGC_HPUX_THREADS enables support for HP/UX 11 pthreads.
+#   Also requires -D_REENTRANT or -D_POSIX_C_SOURCE=199506L. See README.hp.
+# -DGC_LINUX_THREADS enables support for Xavier Leroy's Linux threads
+#   or NPTL threads. See README.linux.  -D_REENTRANT may also be required.
+# -DGC_OSF1_THREADS enables support for Tru64 pthreads.
+# -DGC_FREEBSD_THREADS enables support for FreeBSD pthreads.
+#   Appeared to run into some underlying thread problems.
+# -DGC_DARWIN_THREADS enables support for Mac OS X pthreads.
+# -DGC_AIX_THREADS enables support for IBM AIX threads.
+# -DGC_DGUX386_THREADS enables support for DB/UX on I386 threads.
+#   See README.DGUX386.  (Probably has not been tested recently.)
+# -DGC_WIN32_THREADS enables support for win32 threads.  That makes sense
+#   for this Makefile only under Cygwin.
+# -DGC_WIN32_PTHREADS enables support for Ming32 pthreads.  This cannot be
+#   enabled automatically by GC_THREADS, which would assume Win32 native
+#   threads.
+# -DPTW32_STATIC_LIB causes the static version of the Mingw pthreads library
+#   to be used.  Requires -DGC_WIN32_PTHREADS.
+#   
+# -DALL_INTERIOR_POINTERS allows all pointers to the interior
+#   of objects to be recognized.  (See gc_priv.h for consequences.)
+#   Alternatively, GC_all_interior_pointers can be set at process
+#   initialization time.
+# -DSMALL_CONFIG tries to tune the collector for small heap sizes,
+#   usually causing it to use less space in such situations.
+#   Incremental collection no longer works in this case.
+# -DLARGE_CONFIG tunes the collector for unusually large heaps.
+#   Necessary for heaps larger than about 500 MB on most machines.
+#   Recommended for heaps larger than about 64 MB.
+# -DDONT_ADD_BYTE_AT_END is meaningful only with -DALL_INTERIOR_POINTERS or
+#   GC_all_interior_pointers = 1.  Normally -DALL_INTERIOR_POINTERS
+#   causes all objects to be padded so that pointers just past the end of
+#   an object can be recognized.  This can be expensive.  (The padding
+#   is normally more than one byte due to alignment constraints.)
+#   -DDONT_ADD_BYTE_AT_END disables the padding.
+# -DNO_EXECUTE_PERMISSION may cause some or all of the heap to not
+#   have execute permission, i.e. it may be impossible to execute
+#   code from the heap.  Currently this only affects the incremental
+#   collector on UNIX machines.  It may greatly improve its performance,
+#   since this may avoid some expensive cache synchronization.
+# -DGC_NO_OPERATOR_NEW_ARRAY declares that the C++ compiler does not support
+#   the  new syntax "operator new[]" for allocating and deleting arrays.
+#   See gc_cpp.h for details.  No effect on the C part of the collector.
+#   This is defined implicitly in a few environments.  Must also be defined
+#   by clients that use gc_cpp.h.
+# -DREDIRECT_MALLOC=X causes malloc to be defined as alias for X.
+#   Unless the following macros are defined, realloc is also redirected
+#   to GC_realloc, and free is redirected to GC_free.
+#   Calloc and strdup are redefined in terms of the new malloc.  X should
+#   be either GC_malloc or GC_malloc_uncollectable, or
+#   GC_debug_malloc_replacement.  (The latter invokes GC_debug_malloc
+#   with dummy source location information, but still results in
+#   properly remembered call stacks on Linux/X86 and Solaris/SPARC.
+#   It requires that the following two macros also be used.)
+#   The former is occasionally useful for working around leaks in code
+#   you don't want to (or can't) look at.  It may not work for
+#   existing code, but it often does.  Neither works on all platforms,
+#   since some ports use malloc or calloc to obtain system memory.
+#   (Probably works for UNIX, and win32.)  If you build with DBG_HDRS_ALL,
+#   you should only use GC_debug_malloc_replacement as a malloc
+#   replacement.
+# -DREDIRECT_REALLOC=X causes GC_realloc to be redirected to X.
+#   The canonical use is -DREDIRECT_REALLOC=GC_debug_realloc_replacement,
+#   together with -DREDIRECT_MALLOC=GC_debug_malloc_replacement to
+#   generate leak reports with call stacks for both malloc and realloc.
+#   This also requires the following:
+# -DREDIRECT_FREE=X causes free to be redirected to X.  The
+#   canonical use is -DREDIRECT_FREE=GC_debug_free.
+# -DIGNORE_FREE turns calls to free into a noop.  Only useful with
+#   -DREDIRECT_MALLOC.
+# -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.
+#   Reduces code size slightly at the expense of debuggability.
+# -DJAVA_FINALIZATION makes it somewhat safer to finalize objects out of
+#   order by specifying a nonstandard finalization mark procedure  (see
+#   finalize.c).  Objects reachable from finalizable objects will be marked
+#   in a separate postpass, and hence their memory won't be reclaimed.
+#   Not recommended unless you are implementing a language that specifies
+#   these semantics.  Since 5.0, determines only the initial value
+#   of GC_java_finalization variable.
+# -DFINALIZE_ON_DEMAND causes finalizers to be run only in response
+#   to explicit GC_invoke_finalizers() calls.
+#   In 5.0 this became runtime adjustable, and this only determines the
+#   initial value of GC_finalize_on_demand.
+# -DATOMIC_UNCOLLECTABLE includes code for GC_malloc_atomic_uncollectable.
+#   This is useful if either the vendor malloc implementation is poor,
+#   or if REDIRECT_MALLOC is used.
+# -DMARK_BIT_PER_GRANULE requests that a mark bit (or often byte)
+#   be allocated for each allocation granule, as opposed to each object.
+#   This often improves speed, possibly at some cost in space and/or
+#   cache footprint.  Normally it is best to let this decision be
+#   made automatically depending on platform.
+# -DMARK_BIT_PER_OBJ requests that a mark bit be allocated for each
+#   object instead of allocation granule.  The opposiet of
+#   MARK_BIT_PER_GRANULE.
+# -DHBLKSIZE=ddd, where ddd is a power of 2 between 512 and 16384, explicitly
+#   sets the heap block size.  Each heap block is devoted to a single size and
+#   kind of object.  For the incremental collector it makes sense to match
+#   the most likely page size.  Otherwise large values result in more
+#   fragmentation, but generally better performance for large heaps.
+# -DUSE_MMAP use MMAP instead of sbrk to get new memory.
+#   Works for Solaris and Irix.
+# -DUSE_MUNMAP causes memory to be returned to the OS under the right
+#   circumstances.  This currently disables VM-based incremental collection.
+#   This is currently experimental, and works only under some Unix,
+#   Linux and Windows versions.  Requires -DUSE_MMAP, even under Windows,
+#   where USE_MMAP doesn't do anything.
+# -DMMAP_STACKS (for Solaris threads) Use mmap from /dev/zero rather than
+#   GC_scratch_alloc() to get stack memory.
+# -DPRINT_BLACK_LIST Whenever a black list entry is added, i.e. whenever
+#   the garbage collector detects a value that looks almost, but not quite,
+#   like a pointer, print both the address containing the value, and the
+#   value of the near-bogus-pointer.  Can be used to identifiy regions of
+#   memory that are likely to contribute misidentified pointers.
+# -DKEEP_BACK_PTRS Add code to save back pointers in debugging headers
+#   for objects allocated with the debugging allocator.  If all objects
+#   through GC_MALLOC with GC_DEBUG defined, this allows the client
+#   to determine how particular or randomly chosen objects are reachable
+#   for debugging/profiling purposes.  The gc_backptr.h interface is
+#   implemented only if this is defined.
+# -DGC_ASSERTIONS Enable some internal GC assertion checking.  Currently
+#   this facility is only used in a few places.  It is intended primarily
+#   for debugging of the garbage collector itself, but could also
+# -DDBG_HDRS_ALL Make sure that all objects have debug headers.  Increases
+#   the reliability (from 99.9999% to 100% mod. bugs) of some of the debugging
+#   code (especially KEEP_BACK_PTRS).  Makes -DSHORT_DBG_HDRS possible.
+#   Assumes that all client allocation is done through debugging
+#   allocators.
+# -DSHORT_DBG_HDRS Assume that all objects have debug headers.  Shorten
+#   the headers to minimize object size, at the expense of checking for
+#   writes past the end of an object.  This is intended for environments
+#   in which most client code is written in a "safe" language, such as
+#   Scheme or Java.  Assumes that all client allocation is done using
+#   the GC_debug_ functions, or through the macros that expand to these,
+#   or by redirecting malloc to GC_debug_malloc_replacement.
+#   (Also eliminates the field for the requested object size.)
+# -DSAVE_CALL_COUNT=<n> Set the number of call frames saved with objects
+#   allocated through the debugging interface.  Affects the amount of
+#   information generated in leak reports.  Only matters on platforms
+#   on which we can quickly generate call stacks, currently Linux/(X86 & SPARC)
+#   and Solaris/SPARC and platforms that provide execinfo.h.
+#   Default is zero.  On X86, client
+#   code should NOT be compiled with -fomit-frame-pointer.
+# -DSAVE_CALL_NARGS=<n> Set the number of functions arguments to be
+#   saved with each call frame.  Default is zero.  Ignored if we
+#   don't know how to retrieve arguments on the platform.
+# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly
+#   altered stubborn objects, at substantial performance cost.
+#   Use only for debugging of the incremental collector.
+# -DGC_GCJ_SUPPORT includes support for gcj (and possibly other systems
+#   that include a pointer to a type descriptor in each allocated object).
+#   Building this way requires an ANSI C compiler.
+# -DUSE_I686_PREFETCH causes the collector to issue Pentium III style
+#   prefetch instructions.  No effect except on X86 Linux platforms.
+#   Assumes a very recent gcc-compatible compiler and assembler.
+#   (Gas prefetcht0 support was added around May 1999.)
+#   Empirically the code appears to still run correctly on Pentium II
+#   processors, though with no performance benefit.  May not run on other
+#   X86 processors?  In some cases this improves performance by
+#   15% or so.
+# -DUSE_3DNOW_PREFETCH causes the collector to issue AMD 3DNow style
+#   prefetch instructions.  Same restrictions as USE_I686_PREFETCH.
+#   Minimally tested.  Didn't appear to be an obvious win on a K6-2/500.
+# -DUSE_PPC_PREFETCH causes the collector to issue PowerPC style
+#   prefetch instructions.  No effect except on PowerPC OS X platforms.
+#   Performance impact untested.
+# -DGC_USE_LD_WRAP in combination with the old flags listed in README.linux
+#   causes the collector some system and pthread calls in a more transparent
+#   fashion than the usual macro-based approach.  Requires GNU ld, and
+#   currently probably works only with Linux.
+# -DGC_USE_DLOPEN_WRAP causes the collector to redefine malloc and intercepted
+#   pthread routines with their real names, and causes it to use dlopen
+#   and dlsym to refer to the original versions.  This makes it possible to
+#   build an LD_PRELOADable malloc replacement library.
+# -DTHREAD_LOCAL_ALLOC defines GC_malloc(), GC_malloc_atomic()
+#   and GC_gcj_malloc() to use a per-thread set of free-lists.
+#   These then allocate  in a way that usually does not involve
+#   acquisition of a global lock.  Currently supported only on platforms
+#   such as Linux that use pthread_support.c.  Recommended for multiprocessors.
+#   Requires explicit GC_INIT() call, unless REDIRECT_MALLOC is
+#   defined and GC_malloc is used first.
+# -DUSE_COMPILER_TLS causes thread local allocation to use compiler-supported
+#   "__thread" thread-local variables.  This is the default in HP/UX.  It
+#   may help performance on recent Linux installations.  (It failed for
+#   me on RedHat 8, but appears to work on RedHat 9.)
+# -DPARALLEL_MARK allows the marker to run in multiple threads.  Recommended
+#   for multiprocessors.  Currently requires Linux on X86 or IA64, though
+#   support for other Posix platforms should be fairly easy to add,
+#   if the thread implementation is otherwise supported.
+# -DNO_GETENV prevents the collector from looking at environment variables.
+#   These may otherwise alter its configuration, or turn off GC altogether.
+#   I don't know of a reason to disable this, except possibly if the
+#   resulting process runs as a privileged user?
+# -DUSE_GLOBAL_ALLOC.  Win32 only.  Use GlobalAlloc instead of
+#   VirtualAlloc to allocate the heap.  May be needed to work around
+#   a Windows NT/2000 issue.  Incompatible with USE_MUNMAP.
+#   See README.win32 for details.
+# -DMAKE_BACK_GRAPH. Enable GC_PRINT_BACK_HEIGHT environment variable.
+#   See README.environment for details.  Experimental. Limited platform
+#   support.  Implies DBG_HDRS_ALL.  All allocation should be done using
+#   the debug interface.
+# -DSTUBBORN_ALLOC allows allocation of "hard to change" objects, and thus
+#   makes incremental collection easier.  Was enabled by default until 6.0.
+#   Rarely used, to my knowledge.
+# -DHANDLE_FORK attempts to make GC_malloc() work in a child process fork()ed
+#   from a multithreaded parent.  Currently only supported by pthread_support.c.
+#   (Similar code should work on Solaris or Irix, but it hasn't been tried.)
+# -DTEST_WITH_SYSTEM_MALLOC causes gctest to allocate (and leak) large chunks
+#   of memory with the standard system malloc.  This will cause the root
+#   set and collected heap to grow significantly if malloced memory is
+#   somehow getting traced by the collector.  This has no impact on the
+#   generated library; it only affects the test.
+# -DNO_INCREMENTAL cases the gctest program to not invoke the incremental
+#   collector.  This has no impact on the generated library, only on the
+#   test program.  (This is often useful for debugging failures unrelated
+#   to incremental GC.)
+# -DPOINTER_MASK=0x... causes candidate pointers to be ANDed with the
+#   given mask before being considered.  If either this or the following
+#   macro is defined, it will be assumed that all pointers stored in
+#   the heap need to be processed this way.  Stack and register pointers
+#   will be considered both with and without processing.
+#   These macros are normally needed only to support systems that use
+#   high-order pointer tags. EXPERIMENTAL.
+# -DPOINTER_SHIFT=n causes the collector to left shift candidate pointers
+#   by the indicated amount before trying to interpret them.  Applied
+#   after POINTER_MASK. EXPERIMENTAL.  See also the preceding macro.
+# -DENABLE_TRACE enables the GC_TRACE=addr environment setting to do its
+#   job.  By default this is not supported in order to keep the marker as fast
+#   as possible.
+# -DDARWIN_DONT_PARSE_STACK Causes the Darwin port to discover thread
+#   stack bounds in the same way as other pthread ports, without trying to
+#   walk the frames onthe stack.  This is recommended only as a fallback
+#   for applications that don't support proper stack unwinding.
+# -DUSE_PROC_FOR_LIBRARIES Causes the Linux collector to treat writable
+#   memory mappings (as reported by /proc) as roots, if it doesn't have
+#   otherinformation about them.  It no longer traverses dynamic loader
+#   data structures to find dynamic library static data.  This may be
+#   required for applications that store pointers in mmapped segments without
+#   informaing the collector.  But it typically performs poorly, especially
+#   since it will scan inactive but cached NPTL thread stacks completely.
+# -DNO_PROC_STAT Causes the collector to avoid relying on Linux'
+#   /proc/self/stat.
+#
+
+CXXFLAGS= $(CFLAGS) 
+AR= ar
+RANLIB= ranlib
+
+
+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o \
+  headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o  \
+  malloc.o stubborn.o checksums.o pthread_support.o pthread_stop_world.o \
+  darwin_stop_world.o typd_mlc.o ptr_chck.o mallocx.o gcj_mlc.o specific.o \
+  gc_dlopen.o backgraph.o win32_threads.o thread_local_alloc.o
+
+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c \
+  headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c \
+  new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c \
+  checksums.c pthread_support.c pthread_stop_world.c darwin_stop_world.c \
+  typd_mlc.c ptr_chck.c mallocx.c gcj_mlc.c specific.c gc_dlopen.c \
+  backgraph.c win32_threads.c thread_local_alloc.c
+
+CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC
+
+CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o
+
+SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.S \
+    sparc_mach_dep.S include/gc.h include/gc_typed.h include/gc_tiny_fl.h \
+    include/gc_version.h include/private/gc_hdrs.h include/private/gc_priv.h \
+    include/private/gcconfig.h include/private/gc_pmark.h \
+    include/gc_inline.h include/gc_mark.h \
+    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc include/gc_cpp.h \
+    gcname.c include/weakpointer.h include/private/gc_locks.h \
+    mips_ultrix_mach_dep.s \
+    include/new_gc_alloc.h include/gc_allocator.h \
+    include/javaxfc.h sparc_sunos4_mach_dep.s sparc_netbsd_mach_dep.s \
+    include/gc_backptr.h \
+    hpux_test_and_clear.s include/gc_gcj.h \
+    include/private/dbg_mlc.h \
+    include/private/specific.h \
+    include/leak_detector.h include/gc_amiga_redirects.h \
+    include/gc_pthread_redirects.h ia64_save_regs_in_stack.s \
+    include/gc_config_macros.h include/private/pthread_support.h \
+    include/private/pthread_stop_world.h include/private/darwin_semaphore.h \
+    include/private/darwin_stop_world.h include/private/thread_local_alloc.h \
+    $(CORD_SRCS)
+
+DOC_FILES= README.QUICK doc/README.Mac doc/README.MacOSX doc/README.OS2 \
+	doc/README.amiga doc/README.cords doc/debugging.html \
+	doc/porting.html doc/overview.html \
+	doc/README.dj doc/README.hp doc/README.linux doc/README.rs6000 \
+	doc/README.sgi doc/README.solaris2 doc/README.uts \
+	doc/README.win32 doc/barrett_diagram doc/README \
+        doc/README.contributors doc/README.changes doc/gc.man \
+	doc/README.environment doc/tree.html doc/gcdescr.html \
+	doc/README.autoconf doc/README.macros doc/README.ews4800 \
+	doc/README.DGUX386 doc/README.arm.cross doc/leak.html \
+	doc/scale.html doc/gcinterface.html doc/README.darwin \
+	doc/simple_example.html doc/README.win64
+
+TESTS= tests/test.c tests/test_cpp.cc tests/trace_test.c \
+	tests/leak_test.c tests/thread_leak_test.c tests/middle.c
+
+GNU_BUILD_FILES= configure.ac Makefile.am configure acinclude.m4 \
+		 libtool.m4 install-sh configure.host Makefile.in \
+		 aclocal.m4 config.sub config.guess \
+		 include/include.am doc/doc.am \
+		 ltmain.sh mkinstalldirs depcomp missing \
+		 cord/cord.am tests/tests.am autogen.sh \
+		 bdw-gc.pc.in compile
+
+OTHER_MAKEFILES= OS2_MAKEFILE NT_MAKEFILE NT_THREADS_MAKEFILE gc.mak \
+		 BCC_MAKEFILE EMX_MAKEFILE WCC_MAKEFILE Makefile.dj \
+		 PCR-Makefile SMakefile.amiga Makefile.DLLs \
+		 digimars.mak Makefile.direct NT_STATIC_THREADS_MAKEFILE \
+		 NT_X64_STATIC_THREADS_MAKEFILE NT_X64_THREADS_MAKEFILE \
+		 configure_atomic_ops.sh
+#	Makefile and Makefile.direct are copies of each other.
+
+OTHER_FILES= Makefile setjmp_t.c callprocs \
+           MacProjects.sit.hqx MacOS.c \
+           Mac_files/datastart.c Mac_files/dataend.c \
+           Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \
+           add_gc_prefix.c gc_cpp.cpp \
+	   AmigaOS.c mscvc_dbg.c include/private/msvc_dbg.h \
+	   $(TESTS) $(GNU_BUILD_FILES) $(OTHER_MAKEFILES)
+
+CORD_INCLUDE_FILES= $(srcdir)/include/gc.h $(srcdir)/include/cord.h \
+	$(srcdir)/include/ec.h $(srcdir)/include/private/cord_pos.h
+
+UTILS= if_mach if_not_there threadlibs
+
+# Libraries needed for curses applications.  Only needed for de.
+CURSES= -lcurses -ltermlib
+
+# The following is irrelevant on most systems.  But a few
+# versions of make otherwise fork the shell specified in
+# the SHELL environment variable.
+SHELL= /bin/sh
+
+SPECIALCFLAGS = -I$(srcdir)/include -I$(AO_INSTALL_DIR)/include
+# Alternative flags to the C compiler for mach_dep.c.
+# Mach_dep.c often doesn't like optimization, and it's
+# not time-critical anyway.
+# Set SPECIALCFLAGS to -q nodirect_code on Encore.
+
+all: gc.a gctest
+
+# if AO_INSTALL_DIR doesn't exist, we assume that it is pointing to
+# the default location, and we need to build
+#*---------------------------------------------------------------------*/
+#*    Bigloo start                                                     */
+#*---------------------------------------------------------------------*/
+$(AO_INSTALL_DIR): 
+	CC=$(CC) $(srcdir)/configure_atomic_ops.sh
+	cd $(AO_SRC_DIR); $(MAKE) CC=$(CC) install
+#*---------------------------------------------------------------------*/
+#*    Bigloo stop                                                      */
+#*---------------------------------------------------------------------*/
+
+LEAKFLAGS=$(CFLAGS) -DFIND_LEAK
+
+BSD-pkg-all: bsd-libgc.a bsd-libleak.a
+
+bsd-libgc.a:
+	$(MAKE) CFLAGS="$(CFLAGS)" clean c++-t
+	mv gc.a bsd-libgc.a
+
+bsd-libleak.a:
+	$(MAKE) -f Makefile.direct CFLAGS="$(LEAKFLAGS)" clean c++-nt
+	mv gc.a bsd-libleak.a
+
+BSD-pkg-install: BSD-pkg-all
+	${CP} bsd-libgc.a libgc.a
+	${INSTALL_DATA} libgc.a ${PREFIX}/lib
+	${INSTALL_DATA} gc.h gc_cpp.h ${PREFIX}/include
+	${INSTALL_MAN} doc/gc.man ${PREFIX}/man/man3/gc.3
+
+pcr: PCR-Makefile include/private/gc_private.h include/private/gc_hdrs.h \
+include/private/gc_locks.h include/gc.h include/private/gcconfig.h \
+mach_dep.o $(SRCS)
+	$(MAKE) -f PCR-Makefile depend
+	$(MAKE) -f PCR-Makefile
+
+$(OBJS) tests/test.o dyn_load.o dyn_load_sunos53.o: \
+    $(srcdir)/include/private/gc_priv.h \
+    $(srcdir)/include/private/gc_hdrs.h $(srcdir)/include/private/gc_locks.h \
+    $(srcdir)/include/gc.h $(srcdir)/include/gc_pthread_redirects.h \
+    $(srcdir)/include/private/gcconfig.h $(srcdir)/include/gc_typed.h \
+    $(srcdir)/include/gc_config_macros.h Makefile $(AO_INSTALL_DIR)
+# The dependency on Makefile is needed.  Changing
+# options affects the size of GC_arrays,
+# invalidating all .o files that rely on gc_priv.h
+
+mark.o typd_mlc.o finalize.o ptr_chck.o: $(srcdir)/include/gc_mark.h \
+					 $(srcdir)/include/private/gc_pmark.h
+
+specific.o pthread_support.o thread_local_alloc.o win32_threads.o: \
+	$(srcdir)/include/private/specific.h $(srcdir)/include/gc_inline.h \
+	$(srcdir)/include/private/thread_local_alloc.h
+
+dbg_mlc.o gcj_mlc.o: $(srcdir)/include/private/dbg_mlc.h
+
+tests/test.o: tests $(srcdir)/tests/test.c
+	$(CC) $(CFLAGS) -c $(srcdir)/tests/test.c
+	mv test.o tests/test.o
+
+tests:
+	mkdir tests
+
+base_lib gc.a: $(OBJS) dyn_load.o $(UTILS)
+	echo > base_lib
+	rm -f dont_ar_1
+	cp $(AO_INSTALL_DIR)/lib/libatomic_ops.a gc.a
+	./if_mach SPARC SOLARIS touch dont_ar_1
+	./if_mach SPARC SOLARIS $(AR) rus gc.a $(OBJS) dyn_load.o
+	./if_mach M68K AMIGA touch dont_ar_1
+	./if_mach M68K AMIGA $(AR) -vrus gc.a $(OBJS) dyn_load.o
+	./if_not_there dont_ar_1 $(AR) ru gc.a $(OBJS) dyn_load.o
+	./if_not_there dont_ar_1 $(RANLIB) gc.a || cat /dev/null
+#	ignore ranlib failure; that usually means it doesn't exist, and isn't needed
+
+#*---------------------------------------------------------------------*/
+#*    Bigloo libraries start                                           */
+#*---------------------------------------------------------------------*/
+EOBJECTS=$(OBJS) dyn_load.o
+$(BOOTLIBDIR)/libbigloogc$(LIBSUF)$(LIBQ)-$(RELEASE).$(SHAREDSUFFIX): $(EOBJECTS)
+	@ $(MAKE) shared-lib \
+             LIBDEST=$@ \
+             SONAME=libbigloogc$(LIBSUF)$(LIBQ)-$(RELEASE).$(SHAREDSUFFIX) \
+             GCCLOSELIB= \
+             LDLIBS=$(EXTRAGCLIBS) \
+             OBJECTS="$(EOBJECTS)"
+#*---------------------------------------------------------------------*/
+#*    Bigloo libraries stop                                            */
+#*---------------------------------------------------------------------*/
+
+cords: $(CORD_OBJS) cord/cordtest $(UTILS)
+	rm -f dont_ar_3
+	./if_mach SPARC SOLARIS touch dont_ar_3
+	./if_mach SPARC SOLARIS $(AR) rus gc.a $(CORD_OBJS)
+	./if_mach M68K AMIGA touch dont_ar_3
+	./if_mach M68K AMIGA $(AR) -vrus gc.a $(CORD_OBJS)
+	./if_not_there dont_ar_3 $(AR) ru gc.a $(CORD_OBJS)
+	./if_not_there dont_ar_3 $(RANLIB) gc.a || cat /dev/null
+
+gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/include/gc_cpp.h $(srcdir)/include/gc.h Makefile
+	$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc
+
+test_cpp: $(srcdir)/tests/test_cpp.cc $(srcdir)/include/gc_cpp.h gc_cpp.o $(srcdir)/include/gc.h \
+base_lib $(UTILS)
+	rm -f test_cpp
+	./if_mach HP_PA HPUX $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/tests/test_cpp.cc gc_cpp.o gc.a -ldld `./threadlibs`
+	./if_not_there test_cpp $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/tests/test_cpp.cc gc_cpp.o gc.a `./threadlibs`
+
+c++-t: c++
+	./test_cpp 1
+
+c++-nt: c++
+	@echo "Use ./test_cpp 1 to test the leak library"
+
+c++: gc_cpp.o $(srcdir)/include/gc_cpp.h test_cpp
+	rm -f dont_ar_4
+	./if_mach SPARC SOLARIS touch dont_ar_4
+	./if_mach SPARC SOLARIS $(AR) rus gc.a gc_cpp.o
+	./if_mach M68K AMIGA touch dont_ar_4
+	./if_mach M68K AMIGA $(AR) -vrus gc.a gc_cpp.o
+	./if_not_there dont_ar_4 $(AR) ru gc.a gc_cpp.o
+	./if_not_there dont_ar_4 $(RANLIB) gc.a || cat /dev/null
+	./test_cpp 1
+	echo > c++
+
+dyn_load_sunos53.o: dyn_load.c
+	$(CC) $(CFLAGS) -DSUNOS53_SHARED_LIB -c $(srcdir)/dyn_load.c -o $@
+
+# SunOS5 shared library version of the collector
+sunos5gc.so: $(OBJS) dyn_load_sunos53.o
+	$(CC) -G -o sunos5gc.so $(OBJS) dyn_load_sunos53.o $(AO_INSTALL_DIR)/lib/libatomic_ops.a -ldl
+	ln sunos5gc.so libgc.so
+
+# Alpha/OSF shared library version of the collector
+libalphagc.so: $(OBJS)
+	ld -shared -o libalphagc.so $(OBJS) dyn_load.o -lc
+	ln libalphagc.so libgc.so
+
+# IRIX shared library version of the collector
+libirixgc.so: $(OBJS) dyn_load.o
+	ld -shared $(ABI_FLAG) -o libirixgc.so $(OBJS) dyn_load.o -lc
+	ln libirixgc.so libgc.so
+
+# Linux shared library version of the collector
+liblinuxgc.so: $(OBJS) dyn_load.o
+	gcc -shared -o liblinuxgc.so $(OBJS) dyn_load.o
+	ln liblinuxgc.so libgc.so
+
+# Build gctest with dynamic library
+dyn_test:
+	$(CC) $(CFLAGS) -o gctest tests/test.c libgc.so `./threadlibs`
+	./gctest
+
+# Alternative Linux rule.  This is preferable, but is likely to break the
+# Makefile for some non-linux platforms.
+# LIBOBJS= $(patsubst %.o, %.lo, $(OBJS))
+#
+#.SUFFIXES: .lo $(SUFFIXES)
+#
+#.c.lo:
+#	$(CC) $(CFLAGS) $(CPPFLAGS) -fPIC -c $< -o $@
+#
+# liblinuxgc.so: $(LIBOBJS) dyn_load.lo
+# 	gcc -shared -Wl,-soname=libgc.so.0 -o libgc.so.0 $(LIBOBJS) dyn_load.lo
+#	touch liblinuxgc.so
+
+mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s \
+	    $(srcdir)/mips_ultrix_mach_dep.s \
+            $(srcdir)/rs6000_mach_dep.s \
+	    $(srcdir)/sparc_mach_dep.S $(srcdir)/sparc_sunos4_mach_dep.s \
+	    $(srcdir)/ia64_save_regs_in_stack.s \
+	    $(srcdir)/sparc_netbsd_mach_dep.s $(UTILS)
+	rm -f mach_dep.o
+	./if_mach SPARC SOLARIS $(CC) -c -o mach_dep2.o $(srcdir)/sparc_mach_dep.S
+	./if_mach SPARC OPENBSD $(AS) -o mach_dep2.o $(srcdir)/sparc_sunos4_mach_dep.s
+	./if_mach SPARC NETBSD $(AS) -o mach_dep2.o $(srcdir)/sparc_netbsd_mach_dep.s
+	./if_mach SPARC "" $(CC) -c -o mach_dep1.o $(SPECIALCFLAGS) $(srcdir)/mach_dep.c
+	./if_mach SPARC "" ld -r -o mach_dep.o mach_dep1.o mach_dep2.o
+	./if_mach IA64 "" as $(AS_ABI_FLAG) -o ia64_save_regs_in_stack.o $(srcdir)/ia64_save_regs_in_stack.s
+	./if_mach IA64 "" $(CC) -c -o mach_dep1.o $(SPECIALCFLAGS) $(CPICFLAGS) $(srcdir)/mach_dep.c
+	./if_mach IA64 "" ld -r -o mach_dep.o mach_dep1.o ia64_save_regs_in_stack.o
+	./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(CPICFLAGS) $(srcdir)/mach_dep.c
+
+mark_rts.o: $(srcdir)/mark_rts.c $(UTILS)
+	rm -f mark_rts.o
+	-./if_mach ALPHA OSF1 $(CC) -c $(CFLAGS) -Wo,-notail $(srcdir)/mark_rts.c
+	./if_not_there mark_rts.o $(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c
+#	Work-around for DEC optimizer tail recursion elimination bug.
+#  The ALPHA-specific line should be removed if gcc is used.
+
+alloc.o: include/gc_version.h
+
+cord:
+	mkdir cord
+
+cord/cordbscs.o: cord $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)
+	$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordbscs.c
+	mv cordbscs.o cord/cordbscs.o
+#  not all compilers understand -o filename
+
+cord/cordxtra.o: cord $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)
+	$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordxtra.c
+	mv cordxtra.o cord/cordxtra.o
+
+cord/cordprnt.o: cord $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)
+	$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordprnt.c
+	mv cordprnt.o cord/cordprnt.o
+
+cord/cordtest: $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a $(UTILS)
+	rm -f cord/cordtest
+	./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -lucb
+	./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -ldld `./threadlibs`
+	./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`
+	./if_not_there cord/cordtest $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`
+
+cord/de: $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(UTILS)
+	rm -f cord/de
+	./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb `./threadlibs`
+	./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld `./threadlibs`
+	./if_mach POWERPC AIX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses
+	./if_mach POWERPC DARWIN $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a
+	./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`
+	./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`
+	./if_mach IA64 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`
+	./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses
+	./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) `./threadlibs`
+
+#*---------------------------------------------------------------------*/
+#*    Bigloo start                                                     */
+#*---------------------------------------------------------------------*/
+if_mach: $(srcdir)/if_mach.c $(srcdir)/include/private/gcconfig.h
+	$(HOSTCC) -O -o if_mach $(srcdir)/if_mach.c -I$(srcdir)/include
+
+threadlibs: $(srcdir)/threadlibs.c $(srcdir)/include/private/gcconfig.h Makefile
+	$(HOSTCC) $(HOSTCFLAGS) -o threadlibs $(srcdir)/threadlibs.c
+
+if_not_there: $(srcdir)/if_not_there.c
+	$(HOSTCC) -O -o if_not_there $(srcdir)/if_not_there.c -I$(srcdir)/include
+
+DClean: clean
+
+bigloo-clean: 
+	rm -rf libatomic_ops-install
+	rm -f config.log
+	rm -f libatomic_ops-1.2/config.log
+	rm -f libatomic_ops-1.2/src/atomic_ops/atomic_ops.o \
+              libatomic_ops-1.2/src/atomic_ops/atomic_ops_malloc.o \
+              libatomic_ops-1.2/src/atomic_ops/atomic_ops_stack.o
+	rm -f libatomic_ops-1.2/src/atomic_ops/libatomic_ops.a \
+              libatomic_ops-1.2/src/atomic_ops/libatomic_ops_gpl.a
+#*---------------------------------------------------------------------*/
+#*    Bigloo stop                                                      */
+#*---------------------------------------------------------------------*/
+clean: 
+
+clean: 
+	rm -f gc.a *.o *.exe tests/*.o gctest gctest_dyn_link test_cpp \
+	      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \
+	      threadlibs $(CORD_OBJS) cord/cordtest cord/de 
+	-rm -f *~
+
+gctest: tests/test.o gc.a $(UTILS)
+	rm -f gctest
+	./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -lucb
+	./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -ldld `./threadlibs`
+	./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o gctest  tests/test.o gc.a `./threadlibs`
+	./if_not_there gctest $(CC) $(CFLAGS) -o gctest tests/test.o gc.a `./threadlibs`
+
+# If an optimized setjmp_test generates a segmentation fault,
+# odds are your compiler is broken.  Gctest may still work.
+# Try compiling setjmp_t.c unoptimized.
+setjmp_test: $(srcdir)/setjmp_t.c $(srcdir)/include/gc.h $(UTILS) $(AO_INSTALL_DIR)
+	$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c
+
+test:  KandRtest cord/cordtest
+	cord/cordtest
+
+# Those tests that work even with a K&R C compiler:
+KandRtest: setjmp_test gctest
+	./setjmp_test
+	./gctest
+
+add_gc_prefix: $(srcdir)/add_gc_prefix.c $(srcdir)/include/gc_version.h
+	$(CC) -o add_gc_prefix $(srcdir)/add_gc_prefix.c
+
+gcname: $(srcdir)/gcname.c $(srcdir)/include/gc_version.h
+	$(CC) -o gcname $(srcdir)/gcname.c
+
+#We assume this is being done from source directory.
+dist gc.tar: $(SRCS) $(DOC_FILES) $(OTHER_FILES) add_gc_prefix gcname
+	cp Makefile Makefile.old
+	cp Makefile.direct Makefile
+	CC=$(CC) ./configure_atomic_ops.sh
+	cd $(AO_SRC_DIR); $(MAKE) dist
+	if test $(srcdir)/libatomic_ops-$(AO_VERSION) = $(AO_SRC_DIR); \
+	then \
+	  mv $(AO_SRC_DIR) $(AO_SRC_DIR).bak ; \
+	  tar xvfz $(AO_SRC_DIR).bak/libatomic_ops-$(AO_VERSION).tar.gz ; \
+	else \
+	  tar xvfz $(AO_SRC_DIR)/libatomic_ops-$(AO_VERSION).tar.gz ; \
+	fi
+	rm -f `./gcname`
+	ln -s . `./gcname`
+	./add_gc_prefix $(SRCS) $(DOC_FILES) $(OTHER_FILES) libatomic_ops-$(AO_VERSION) > /tmp/gc.tar-files
+	tar cvfh gc.tar `cat /tmp/gc.tar-files`
+	cp gc.tar `./gcname`.tar
+	gzip `./gcname`.tar
+	rm `./gcname`
+
+gc.tar.Z: gc.tar
+	compress gc.tar
+
+gc.tar.gz: gc.tar
+	gzip gc.tar
+
+lint: $(CSRCS) tests/test.c
+	lint -DLINT $(CSRCS) tests/test.c | egrep -v "possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall|change in ANSI|improper alignment"
+
+# BTL: added to test shared library version of collector.
+# Currently works only under SunOS5.  Requires GC_INIT call from statically
+# loaded client code.
+ABSDIR = `pwd`
+gctest_dyn_link: tests/test.o libgc.so
+	$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link tests/test.o -lgc -ldl -lthread
+
+gctest_irix_dyn_link: tests/test.o libirixgc.so
+	$(CC) -L$(ABSDIR) -o gctest_irix_dyn_link tests/test.o -lirixgc
+
+# The following appear to be dead, especially since libgc_globals.h
+# is apparently lost.
+test_dll.o: tests/test.c libgc_globals.h
+	$(CC) $(CFLAGS) -DGC_USE_DLL -c tests/test.c -o test_dll.o
+
+test_dll: test_dll.o libgc_dll.a libgc.dll
+	$(CC) test_dll.o -L$(ABSDIR) -lgc_dll -o test_dll
+
+SYM_PREFIX-libgc=GC
+
+# Uncomment the following line to build a GNU win32 DLL
+# include Makefile.DLLs
+
+reserved_namespace: $(SRCS)
+	for file in $(SRCS) tests/test.c tests/test_cpp.cc; do \
+		sed s/GC_/_GC_/g < $$file > tmp; \
+		cp tmp $$file; \
+		done
+
+user_namespace: $(SRCS)
+	for file in $(SRCS) tests/test.c tests/test_cpp.cc; do \
+		sed s/_GC_/GC_/g < $$file > tmp; \
+		cp tmp $$file; \
+		done
+
+#*---------------------------------------------------------------------*/
+#*    Bigloo start                                                     */
+#*---------------------------------------------------------------------*/
+inline-alloc.o: ../../runtime/Clib/inline-alloc.c
+	$(CC) $(CFLAGS) $< -c
+#*---------------------------------------------------------------------*/
+#*    Bigloo stop                                                      */
+#*---------------------------------------------------------------------*/
diff -Naur gc-7.1alpha3.orig/alloc.c gc-7.1alpha3/alloc.c
--- gc-7.1alpha3.orig/alloc.c	2008-02-20 01:07:53.000000000 +0100
+++ gc-7.1alpha3/alloc.c	2008-02-21 07:08:51.000000000 +0100
@@ -447,9 +447,35 @@
     return(result);
 }
 
-# if !defined(REDIRECT_MALLOC) && (defined(MSWIN32) || defined(MSWINCE))
-  void GC_add_current_malloc_heap();
-# endif
+/*---------------------------------------------------------------------*/
+/*    Bigloo profiling 13Apr2003: start                                */
+/*---------------------------------------------------------------------*/
+static void (*GC_gcollect_hook)() = 0;
+GC_add_gc_hook( void (*f)() ) {
+   GC_gcollect_hook = f;
+}
+/*---------------------------------------------------------------------*/
+/*    Bigloo profiling 13Apr2003: stop                                 */
+/*---------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------*/
+/*    Bigloo start                                                     */
+/*---------------------------------------------------------------------*/
+static long allocated_bytes = 0;
+
+GC_get_allocated_bytes() {
+   return allocated_bytes;
+}
+
+#ifdef KEEP_BACK_PTRS
+int GC_heap_info_available = 1;
+#else
+int GC_heap_info_available = 0;
+#endif
+/*---------------------------------------------------------------------*/
+/*    Bigloo stop                                                      */
+/*---------------------------------------------------------------------*/
+
 /*
  * Assumes lock is held, signals are disabled.
  * We stop the world.
@@ -462,6 +488,15 @@
     int dummy;
     CLOCK_TYPE start_time, current_time;
 	
+/*---------------------------------------------------------------------*/
+/*    Bigloo start                                                     */
+/*---------------------------------------------------------------------*/
+#   ifdef KEEP_BACK_PTRS
+    allocated_bytes += GC_get_bytes_since_gc();
+#   endif
+/*---------------------------------------------------------------------*/
+/*    Bigloo stop                                                      */
+/*---------------------------------------------------------------------*/
     if (GC_print_stats)
 	GET_TIME(start_time);
 
@@ -724,6 +759,17 @@
 	GC_log_printf("\n");
     }
 
+/*---------------------------------------------------------------------*/
+/*    Bigloo profiling 13Apr2003: start                                */
+/*---------------------------------------------------------------------*/
+    if( GC_gcollect_hook )
+       GC_gcollect_hook( GC_heapsize,
+			 (unsigned long)(GC_atomic_in_use)+
+			 (unsigned long)(GC_composite_in_use) );
+/*---------------------------------------------------------------------*/
+/*    Bigloo profiling 13Apr2003: start                                */
+/*---------------------------------------------------------------------*/
+
     /* Reset or increment counters for next cycle */
       GC_n_attempts = 0;
       GC_is_full_gc = FALSE;
diff -Naur gc-7.1alpha3.orig/alloc.c~ gc-7.1alpha3/alloc.c~
--- gc-7.1alpha3.orig/alloc.c~	1970-01-01 01:00:00.000000000 +0100
+++ gc-7.1alpha3/alloc.c~	2008-02-20 01:07:53.000000000 +0100
@@ -0,0 +1,1076 @@
+/*
+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers
+ * Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.
+ * Copyright (c) 1998 by Silicon Graphics.  All rights reserved.
+ * Copyright (c) 1999-2004 Hewlett-Packard Development Company, L.P.
+ *
+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
+ *
+ * Permission is hereby granted to use or copy this program
+ * for any purpose,  provided the above notices are retained on all copies.
+ * Permission to modify the code and to distribute modified code is granted,
+ * provided the above notices are retained, and a notice that the code was
+ * modified is included with the above copyright notice.
+ *
+ */
+
+
+# include "private/gc_priv.h"
+
+# include <stdio.h>
+# if !defined(MACOS) && !defined(MSWINCE)
+#   include <signal.h>
+#   include <sys/types.h>
+# endif
+
+/*
+ * Separate free lists are maintained for different sized objects
+ * up to MAXOBJBYTES.
+ * The call GC_allocobj(i,k) ensures that the freelist for
+ * kind k objects of size i points to a non-empty
+ * free list. It returns a pointer to the first entry on the free list.
+ * In a single-threaded world, GC_allocobj may be called to allocate
+ * an object of (small) size i as follows:
+ *
+ *            opp = &(GC_objfreelist[i]);
+ *            if (*opp == 0) GC_allocobj(i, NORMAL);
+ *            ptr = *opp;
+ *            *opp = obj_link(ptr);
+ *
+ * Note that this is very fast if the free list is non-empty; it should
+ * only involve the execution of 4 or 5 simple instructions.
+ * All composite objects on freelists are cleared, except for
+ * their first word.
+ */
+
+/*
+ *  The allocator uses GC_allochblk to allocate large chunks of objects.
+ * These chunks all start on addresses which are multiples of
+ * HBLKSZ.   Each allocated chunk has an associated header,
+ * which can be located quickly based on the address of the chunk.
+ * (See headers.c for details.) 
+ * This makes it possible to check quickly whether an
+ * arbitrary address corresponds to an object administered by the
+ * allocator.
+ */
+
+word GC_non_gc_bytes = 0;  /* Number of bytes not intended to be collected */
+
+word GC_gc_no = 0;
+
+#ifndef SMALL_CONFIG
+  int GC_incremental = 0;  /* By default, stop the world.	*/
+#endif
+
+int GC_parallel = FALSE;   /* By default, parallel GC is off.	*/
+
+int GC_full_freq = 19;	   /* Every 20th collection is a full	*/
+			   /* collection, whether we need it 	*/
+			   /* or not.			        */
+
+GC_bool GC_need_full_gc = FALSE;
+			   /* Need full GC do to heap growth.	*/
+
+#ifdef THREADS
+  GC_bool GC_world_stopped = FALSE;
+# define IF_THREADS(x) x
+#else
+# define IF_THREADS(x)
+#endif
+
+word GC_used_heap_size_after_full = 0;
+
+char * GC_copyright[] =
+{"Copyright 1988,1989 Hans-J. Boehm and Alan J. Demers ",
+"Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved. ",
+"Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved. ",
+"Copyright (c) 1999-2001 by Hewlett-Packard Company.  All rights reserved. ",
+"THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY",
+" EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.",
+"See source code for details." };
+
+/* Version macros are now defined in gc_version.h, which is included by	*/
+/* gc.h, which is included by gc_priv.h".				*/
+
+#ifndef GC_NO_VERSION_VAR
+
+unsigned GC_version = ((GC_VERSION_MAJOR << 16) | (GC_VERSION_MINOR << 8) | GC_TMP_ALPHA_VERSION);
+
+#endif /* GC_NO_VERSION_VAR */
+
+/* some more variables */
+
+extern signed_word GC_bytes_found; /* Number of reclaimed bytes		*/
+				  /* after garbage collection      	*/
+
+GC_bool GC_dont_expand = 0;
+
+word GC_free_space_divisor = 3;
+
+extern GC_bool GC_collection_in_progress();
+		/* Collection is in progress, or was abandoned.	*/
+
+int GC_never_stop_func (void) { return(0); }
+
+unsigned long GC_time_limit = TIME_LIMIT;
+
+CLOCK_TYPE GC_start_time;  	/* Time at which we stopped world.	*/
+				/* used only in GC_timeout_stop_func.	*/
+
+int GC_n_attempts = 0;		/* Number of attempts at finishing	*/
+				/* collection within GC_time_limit.	*/
+
+#if defined(SMALL_CONFIG) || defined(NO_CLOCK)
+#   define GC_timeout_stop_func GC_never_stop_func
+#else
+  int GC_timeout_stop_func (void)
+  {
+    CLOCK_TYPE current_time;
+    static unsigned count = 0;
+    unsigned long time_diff;
+    
+    if ((count++ & 3) != 0) return(0);
+    GET_TIME(current_time);
+    time_diff = MS_TIME_DIFF(current_time,GC_start_time);
+    if (time_diff >= GC_time_limit) {
+	if (GC_print_stats) {
+	    GC_log_printf("Abandoning stopped marking after ");
+	    GC_log_printf("%lu msecs", time_diff);
+	    GC_log_printf("(attempt %d)\n", GC_n_attempts);
+	}
+    	return(1);
+    }
+    return(0);
+  }
+#endif /* !SMALL_CONFIG */
+
+/* Return the minimum number of words that must be allocated between	*/
+/* collections to amortize the collection cost.				*/
+static word min_bytes_allocd()
+{
+#   ifdef THREADS
+ 	/* We punt, for now. */
+ 	signed_word stack_size = 10000;
+#   else
+        int dummy;
+        signed_word stack_size = (ptr_t)(&dummy) - GC_stackbottom;
+#   endif
+    word total_root_size;  	    /* includes double stack size,	*/
+    				    /* since the stack is expensive	*/
+    				    /* to scan.				*/
+    word scan_size;		/* Estimate of memory to be scanned 	*/
+				/* during normal GC.			*/
+    
+    if (stack_size < 0) stack_size = -stack_size;
+    total_root_size = 2 * stack_size + GC_root_size;
+    scan_size = 2 * GC_composite_in_use + GC_atomic_in_use/4
+		+ total_root_size;
+    if (TRUE_INCREMENTAL) {
+        return scan_size / (2 * GC_free_space_divisor);
+    } else {
+        return scan_size / GC_free_space_divisor;
+    }
+}
+
+/* Return the number of bytes allocated, adjusted for explicit storage	*/
+/* management, etc..  This number is used in deciding when to trigger	*/
+/* collections.								*/
+word GC_adj_bytes_allocd(void)
+{
+    signed_word result;
+    signed_word expl_managed =
+    		(signed_word)GC_non_gc_bytes
+		- (signed_word)GC_non_gc_bytes_at_gc;
+    
+    /* Don't count what was explicitly freed, or newly allocated for	*/
+    /* explicit management.  Note that deallocating an explicitly	*/
+    /* managed object should not alter result, assuming the client	*/
+    /* is playing by the rules.						*/
+    result = (signed_word)GC_bytes_allocd
+    	     + (signed_word)GC_bytes_dropped
+    	     - (signed_word)GC_bytes_freed 
+	     + (signed_word)GC_finalizer_bytes_freed
+	     - expl_managed;
+    if (result > (signed_word)GC_bytes_allocd) {
+        result = GC_bytes_allocd;
+    	/* probably client bug or unfortunate scheduling */
+    }
+    result += GC_bytes_finalized;
+    	/* We count objects enqueued for finalization as though they	*/
+    	/* had been reallocated this round. Finalization is user	*/
+    	/* visible progress.  And if we don't count this, we have	*/
+    	/* stability problems for programs that finalize all objects.	*/
+    if (result < (signed_word)(GC_bytes_allocd >> 3)) {
+    	/* Always count at least 1/8 of the allocations.  We don't want	*/
+    	/* to collect too infrequently, since that would inhibit	*/
+    	/* coalescing of free storage blocks.				*/
+    	/* This also makes us partially robust against client bugs.	*/
+        return(GC_bytes_allocd >> 3);
+    } else {
+        return(result);
+    }
+}
+
+
+/* Clear up a few frames worth of garbage left at the top of the stack.	*/
+/* This is used to prevent us from accidentally treating garbade left	*/
+/* on the stack by other parts of the collector as roots.  This 	*/
+/* differs from the code in misc.c, which actually tries to keep the	*/
+/* stack clear of long-lived, client-generated garbage.			*/
+void GC_clear_a_few_frames()
+{
+#   define NWORDS 64
+    word frames[NWORDS];
+    int i;
+    
+    for (i = 0; i < NWORDS; i++) frames[i] = 0;
+}
+
+/* Heap size at which we need a collection to avoid expanding past	*/
+/* limits used by blacklisting.						*/
+static word GC_collect_at_heapsize = (word)(-1);
+
+/* Have we allocated enough to amortize a collection? */
+GC_bool GC_should_collect(void)
+{
+    static word last_min_bytes_allocd;
+    static word last_gc_no;
+    if (last_gc_no != GC_gc_no) {
+      last_gc_no = GC_gc_no;
+      last_min_bytes_allocd = min_bytes_allocd();
+    }
+    return(GC_adj_bytes_allocd() >= last_min_bytes_allocd
+	   || GC_heapsize >= GC_collect_at_heapsize);
+}
+
+
+void GC_notify_full_gc(void)
+{
+    if (GC_start_call_back != (void (*) (void))0) {
+	(*GC_start_call_back)();
+    }
+}
+
+GC_bool GC_is_full_gc = FALSE;
+
+/* 
+ * Initiate a garbage collection if appropriate.
+ * Choose judiciously
+ * between partial, full, and stop-world collections.
+ */
+void GC_maybe_gc(void)
+{
+    static int n_partial_gcs = 0;
+
+    GC_ASSERT(I_HOLD_LOCK());
+    if (GC_should_collect()) {
+        if (!GC_incremental) {
+            GC_gcollect_inner();
+            n_partial_gcs = 0;
+            return;
+        } else {
+#   	  ifdef PARALLEL_MARK
+	    GC_wait_for_reclaim();
+#   	  endif
+	  if (GC_need_full_gc || n_partial_gcs >= GC_full_freq) {
+	    if (GC_print_stats) {
+	        GC_log_printf(
+	          "***>Full mark for collection %lu after %ld allocd bytes\n",
+     		  (unsigned long)GC_gc_no+1,
+		  (long)GC_bytes_allocd);
+	    }
+	    GC_promote_black_lists();
+	    (void)GC_reclaim_all((GC_stop_func)0, TRUE);
+	    GC_clear_marks();
+            n_partial_gcs = 0;
+	    GC_notify_full_gc();
+ 	    GC_is_full_gc = TRUE;
+          } else {
+            n_partial_gcs++;
+          }
+	}
+        /* We try to mark with the world stopped.	*/
+        /* If we run out of time, this turns into	*/
+        /* incremental marking.			*/
+#	ifndef NO_CLOCK
+          if (GC_time_limit != GC_TIME_UNLIMITED) { GET_TIME(GC_start_time); }
+#	endif
+        if (GC_stopped_mark(GC_time_limit == GC_TIME_UNLIMITED? 
+			    GC_never_stop_func : GC_timeout_stop_func)) {
+#           ifdef SAVE_CALL_CHAIN
+                GC_save_callers(GC_last_stack);
+#           endif
+            GC_finish_collection();
+        } else {
+	    if (!GC_is_full_gc) {
+		/* Count this as the first attempt */
+	        GC_n_attempts++;
+	    }
+	}
+    }
+}
+
+
+/*
+ * Stop the world garbage collection.  Assumes lock held, signals disabled.
+ * If stop_func is not GC_never_stop_func, then abort if stop_func returns TRUE.
+ * Return TRUE if we successfully completed the collection.
+ */
+GC_bool GC_try_to_collect_inner(GC_stop_func stop_func)
+{
+    CLOCK_TYPE start_time, current_time;
+    if (GC_dont_gc) return FALSE;
+    if (GC_incremental && GC_collection_in_progress()) {
+      if (GC_print_stats) {
+	GC_log_printf(
+	    "GC_try_to_collect_inner: finishing collection in progress\n");
+      }
+      /* Just finish collection already in progress.	*/
+    	while(GC_collection_in_progress()) {
+    	    if (stop_func()) return(FALSE);
+    	    GC_collect_a_little_inner(1);
+    	}
+    }
+    if (stop_func == GC_never_stop_func) GC_notify_full_gc();
+    if (GC_print_stats) {
+        GET_TIME(start_time);
+	GC_log_printf(
+	   "Initiating full world-stop collection %lu after %ld allocd bytes\n",
+	   (unsigned long)GC_gc_no+1, (long)GC_bytes_allocd);
+    }
+    GC_promote_black_lists();
+    /* Make sure all blocks have been reclaimed, so sweep routines	*/
+    /* don't see cleared mark bits.					*/
+    /* If we're guaranteed to finish, then this is unnecessary.		*/
+    /* In the find_leak case, we have to finish to guarantee that 	*/
+    /* previously unmarked objects are not reported as leaks.		*/
+#       ifdef PARALLEL_MARK
+	    GC_wait_for_reclaim();
+#       endif
+ 	if ((GC_find_leak || stop_func != GC_never_stop_func)
+	    && !GC_reclaim_all(stop_func, FALSE)) {
+	    /* Aborted.  So far everything is still consistent.	*/
+	    return(FALSE);
+	}
+    GC_invalidate_mark_state();  /* Flush mark stack.	*/
+    GC_clear_marks();
+#   ifdef SAVE_CALL_CHAIN
+        GC_save_callers(GC_last_stack);
+#   endif
+    GC_is_full_gc = TRUE;
+    if (!GC_stopped_mark(stop_func)) {
+      if (!GC_incremental) {
+    	/* We're partially done and have no way to complete or use 	*/
+    	/* current work.  Reestablish invariants as cheaply as		*/
+    	/* possible.							*/
+    	GC_invalidate_mark_state();
+	GC_unpromote_black_lists();
+      } /* else we claim the world is already still consistent.  We'll 	*/
+        /* finish incrementally.					*/
+      return(FALSE);
+    }
+    GC_finish_collection();
+    if (GC_print_stats) {
+        GET_TIME(current_time);
+        GC_log_printf("Complete collection took %lu msecs\n",
+                  MS_TIME_DIFF(current_time,start_time));
+    }
+    return(TRUE);
+}
+
+
+
+/*
+ * Perform n units of garbage collection work.  A unit is intended to touch
+ * roughly GC_RATE pages.  Every once in a while, we do more than that.
+ * This needs to be a fairly large number with our current incremental
+ * GC strategy, since otherwise we allocate too much during GC, and the
+ * cleanup gets expensive.
+ */
+# define GC_RATE 10 
+# define MAX_PRIOR_ATTEMPTS 1
+ 	/* Maximum number of prior attempts at world stop marking	*/
+ 	/* A value of 1 means that we finish the second time, no matter */
+ 	/* how long it takes.  Doesn't count the initial root scan	*/
+ 	/* for a full GC.						*/
+
+int GC_deficit = 0;	/* The number of extra calls to GC_mark_some	*/
+			/* that we have made.				*/
+
+void GC_collect_a_little_inner(int n)
+{
+    int i;
+    
+    if (GC_dont_gc) return;
+    if (GC_incremental && GC_collection_in_progress()) {
+    	for (i = GC_deficit; i < GC_RATE*n; i++) {
+    	    if (GC_mark_some((ptr_t)0)) {
+    	        /* Need to finish a collection */
+#     		ifdef SAVE_CALL_CHAIN
+        	    GC_save_callers(GC_last_stack);
+#     		endif
+#		ifdef PARALLEL_MARK
+		    GC_wait_for_reclaim();
+#		endif
+		if (GC_n_attempts < MAX_PRIOR_ATTEMPTS
+		    && GC_time_limit != GC_TIME_UNLIMITED) {
+		  GET_TIME(GC_start_time);
+		  if (!GC_stopped_mark(GC_timeout_stop_func)) {
+		    GC_n_attempts++;
+		    break;
+		  }
+		} else {
+		  (void)GC_stopped_mark(GC_never_stop_func);
+		}
+    	        GC_finish_collection();
+    	        break;
+    	    }
+    	}
+    	if (GC_deficit > 0) GC_deficit -= GC_RATE*n;
+	if (GC_deficit < 0) GC_deficit = 0;
+    } else {
+        GC_maybe_gc();
+    }
+}
+
+int GC_collect_a_little(void)
+{
+    int result;
+    DCL_LOCK_STATE;
+
+    LOCK();
+    GC_collect_a_little_inner(1);
+    result = (int)GC_collection_in_progress();
+    UNLOCK();
+    if (!result && GC_debugging_started) GC_print_all_smashed();
+    return(result);
+}
+
+# if !defined(REDIRECT_MALLOC) && (defined(MSWIN32) || defined(MSWINCE))
+  void GC_add_current_malloc_heap();
+# endif
+/*
+ * Assumes lock is held, signals are disabled.
+ * We stop the world.
+ * If stop_func() ever returns TRUE, we may fail and return FALSE.
+ * Increment GC_gc_no if we succeed.
+ */
+GC_bool GC_stopped_mark(GC_stop_func stop_func)
+{
+    unsigned i;
+    int dummy;
+    CLOCK_TYPE start_time, current_time;
+	
+    if (GC_print_stats)
+	GET_TIME(start_time);
+
+#   if !defined(REDIRECT_MALLOC) && (defined(MSWIN32) || defined(MSWINCE))
+        GC_add_current_malloc_heap();
+#   endif
+#   if defined(REGISTER_LIBRARIES_EARLY)
+        GC_cond_register_dynamic_libraries();
+#   endif
+    STOP_WORLD();
+    IF_THREADS(GC_world_stopped = TRUE);
+    if (GC_print_stats) {
+	GC_log_printf("--> Marking for collection %lu ",
+		  (unsigned long)GC_gc_no + 1);
+	GC_log_printf("after %lu allocd bytes\n",
+	   	   (unsigned long) GC_bytes_allocd);
+    }
+#   ifdef MAKE_BACK_GRAPH
+      if (GC_print_back_height) {
+        GC_build_back_graph();
+      }
+#   endif
+
+    /* Mark from all roots.  */
+        /* Minimize junk left in my registers and on the stack */
+            GC_clear_a_few_frames();
+            GC_noop(0,0,0,0,0,0);
+	GC_initiate_gc();
+	for(i = 0;;i++) {
+	    if ((*stop_func)()) {
+		    if (GC_print_stats) {
+		    	GC_log_printf("Abandoned stopped marking after ");
+			GC_log_printf("%u iterations\n", i);
+		    }
+		    GC_deficit = i; /* Give the mutator a chance. */
+                    IF_THREADS(GC_world_stopped = FALSE);
+	            START_WORLD();
+	            return(FALSE);
+	    }
+	    if (GC_mark_some((ptr_t)(&dummy))) break;
+	}
+	
+    GC_gc_no++;
+    if (GC_print_stats) {
+      GC_log_printf("Collection %lu reclaimed %ld bytes",
+		    (unsigned long)GC_gc_no - 1,
+	   	    (long)GC_bytes_found);
+      GC_log_printf(" ---> heapsize = %lu bytes\n",
+      	        (unsigned long) GC_heapsize);
+        /* Printf arguments may be pushed in funny places.  Clear the	*/
+        /* space.							*/
+      GC_log_printf("");
+    }
+
+    /* Check all debugged objects for consistency */
+        if (GC_debugging_started) {
+            (*GC_check_heap)();
+        }
+    
+    IF_THREADS(GC_world_stopped = FALSE);
+    START_WORLD();
+    if (GC_print_stats) {
+      GET_TIME(current_time);
+      GC_log_printf("World-stopped marking took %lu msecs\n",
+	            MS_TIME_DIFF(current_time,start_time));
+    }
+    return(TRUE);
+}
+
+/* Set all mark bits for the free list whose first entry is q	*/
+void GC_set_fl_marks(ptr_t q)
+{
+   ptr_t p;
+   struct hblk * h, * last_h = 0;
+   hdr *hhdr;  /* gcc "might be uninitialized" warning is bogus. */
+   IF_PER_OBJ(size_t sz;)
+   unsigned bit_no;
+
+   for (p = q; p != 0; p = obj_link(p)){
+	h = HBLKPTR(p);
+	if (h != last_h) {
+	  last_h = h; 
+	  hhdr = HDR(h);
+	  IF_PER_OBJ(sz = hhdr->hb_sz;)
+	}
+	bit_no = MARK_BIT_NO((ptr_t)p - (ptr_t)h, sz);
+	if (!mark_bit_from_hdr(hhdr, bit_no)) {
+      	  set_mark_bit_from_hdr(hhdr, bit_no);
+          ++hhdr -> hb_n_marks;
+        }
+   }
+}
+
+#ifdef GC_ASSERTIONS
+/* Check that all mark bits for the free list whose first entry is q	*/
+/* are set.								*/
+void GC_check_fl_marks(ptr_t q)
+{
+   ptr_t p;
+
+   for (p = q; p != 0; p = obj_link(p)){
+	if (!GC_is_marked(p)) {
+	    GC_err_printf("Unmarked object %p on list %p\n", p, q);
+	    ABORT("Unmarked local free list entry.");
+	}
+   }
+}
+#endif
+
+/* Clear all mark bits for the free list whose first entry is q	*/
+/* Decrement GC_bytes_found by number of bytes on free list.	*/
+void GC_clear_fl_marks(ptr_t q)
+{
+   ptr_t p;
+   struct hblk * h, * last_h = 0;
+   hdr *hhdr;
+   size_t sz;
+   unsigned bit_no;
+
+   for (p = q; p != 0; p = obj_link(p)){
+	h = HBLKPTR(p);
+	if (h != last_h) {
+	  last_h = h; 
+	  hhdr = HDR(h);
+	  sz = hhdr->hb_sz;  /* Normally set only once. */
+	}
+	bit_no = MARK_BIT_NO((ptr_t)p - (ptr_t)h, sz);
+	if (mark_bit_from_hdr(hhdr, bit_no)) {
+	  size_t n_marks = hhdr -> hb_n_marks - 1;
+      	  clear_mark_bit_from_hdr(hhdr, bit_no);
+#	  ifdef PARALLEL_MARK
+	    /* Appr. count, don't decrement to zero! */
+	    if (0 != n_marks) {
+              hhdr -> hb_n_marks = n_marks;
+	    }
+#	  else
+            hhdr -> hb_n_marks = n_marks;
+#	  endif
+        }
+	GC_bytes_found -= sz;
+   }
+}
+
+#if defined(GC_ASSERTIONS) && defined(THREADS) && defined(THREAD_LOCAL_ALLOC)
+extern void GC_check_tls(void);
+#endif
+
+/* Finish up a collection.  Assumes lock is held, signals are disabled,	*/
+/* but the world is otherwise running.					*/
+void GC_finish_collection()
+{
+    CLOCK_TYPE start_time;
+    CLOCK_TYPE finalize_time;
+    CLOCK_TYPE done_time;
+	
+#   if defined(GC_ASSERTIONS) && defined(THREADS) \
+       && defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)
+	/* Check that we marked some of our own data.  		*/
+        /* FIXME: Add more checks.				*/
+        GC_check_tls();
+#   endif
+
+    if (GC_print_stats)
+      GET_TIME(start_time);
+
+    GC_bytes_found = 0;
+#   if defined(LINUX) && defined(__ELF__) && !defined(SMALL_CONFIG)
+	if (getenv("GC_PRINT_ADDRESS_MAP") != 0) {
+	  GC_print_address_map();
+	}
+#   endif
+    COND_DUMP;
+    if (GC_find_leak) {
+      /* Mark all objects on the free list.  All objects should be */
+      /* marked when we're done.				   */
+	{
+	  word size;		/* current object size		*/
+	  unsigned kind;
+	  ptr_t q;
+
+	  for (kind = 0; kind < GC_n_kinds; kind++) {
+	    for (size = 1; size <= MAXOBJGRANULES; size++) {
+	      q = GC_obj_kinds[kind].ok_freelist[size];
+	      if (q != 0) GC_set_fl_marks(q);
+	    }
+	  }
+	}
+	GC_start_reclaim(TRUE);
+	  /* The above just checks; it doesn't really reclaim anything. */
+    }
+
+    GC_finalize();
+#   ifdef STUBBORN_ALLOC
+      GC_clean_changing_list();
+#   endif
+
+    if (GC_print_stats)
+      GET_TIME(finalize_time);
+
+    if (GC_print_back_height) {
+#     ifdef MAKE_BACK_GRAPH
+	GC_traverse_back_graph();
+#     else
+#	ifndef SMALL_CONFIG
+	  GC_err_printf("Back height not available: "
+		        "Rebuild collector with -DMAKE_BACK_GRAPH\n");
+#  	endif
+#     endif
+    }
+
+    /* Clear free list mark bits, in case they got accidentally marked   */
+    /* (or GC_find_leak is set and they were intentionally marked).	 */
+    /* Also subtract memory remaining from GC_bytes_found count.         */
+    /* Note that composite objects on free list are cleared.             */
+    /* Thus accidentally marking a free list is not a problem;  only     */
+    /* objects on the list itself will be marked, and that's fixed here. */
+      {
+	word size;		/* current object size		*/
+	ptr_t q;	/* pointer to current object	*/
+	unsigned kind;
+
+	for (kind = 0; kind < GC_n_kinds; kind++) {
+	  for (size = 1; size <= MAXOBJGRANULES; size++) {
+	    q = GC_obj_kinds[kind].ok_freelist[size];
+	    if (q != 0) GC_clear_fl_marks(q);
+	  }
+	}
+      }
+
+
+    if (GC_print_stats == VERBOSE)
+	GC_log_printf("Bytes recovered before sweep - f.l. count = %ld\n",
+	          (long)GC_bytes_found);
+    
+    /* Reconstruct free lists to contain everything not marked */
+        GC_start_reclaim(FALSE);
+	if (GC_print_stats) {
+	  GC_log_printf("Heap contains %lu pointer-containing "
+		        "+ %lu pointer-free reachable bytes\n",
+		        (unsigned long)GC_composite_in_use,
+		        (unsigned long)GC_atomic_in_use);
+	}
+        if (GC_is_full_gc)  {
+	    GC_used_heap_size_after_full = USED_HEAP_SIZE;
+	    GC_need_full_gc = FALSE;
+	} else {
+	    GC_need_full_gc =
+		 USED_HEAP_SIZE - GC_used_heap_size_after_full
+		 > min_bytes_allocd();
+	}
+
+    if (GC_print_stats == VERBOSE) {
+	GC_log_printf(
+		  "Immediately reclaimed %ld bytes in heap of size %lu bytes",
+	          (long)GC_bytes_found,
+	          (unsigned long)GC_heapsize);
+#	ifdef USE_MUNMAP
+	  GC_log_printf("(%lu unmapped)", (unsigned long)GC_unmapped_bytes);
+#	endif
+	GC_log_printf("\n");
+    }
+
+    /* Reset or increment counters for next cycle */
+      GC_n_attempts = 0;
+      GC_is_full_gc = FALSE;
+      GC_bytes_allocd_before_gc += GC_bytes_allocd;
+      GC_non_gc_bytes_at_gc = GC_non_gc_bytes;
+      GC_bytes_allocd = 0;
+      GC_bytes_dropped = 0;
+      GC_bytes_freed = 0;
+      GC_finalizer_bytes_freed = 0;
+      
+#   ifdef USE_MUNMAP
+      GC_unmap_old();
+#   endif
+    if (GC_print_stats) {
+	GET_TIME(done_time);
+	GC_log_printf("Finalize + initiate sweep took %lu + %lu msecs\n",
+	              MS_TIME_DIFF(finalize_time,start_time),
+	              MS_TIME_DIFF(done_time,finalize_time));
+    }
+}
+
+/* Externally callable routine to invoke full, stop-world collection */
+int GC_try_to_collect(GC_stop_func stop_func)
+{
+    int result;
+    DCL_LOCK_STATE;
+    
+    if (!GC_is_initialized) GC_init();
+    if (GC_debugging_started) GC_print_all_smashed();
+    GC_INVOKE_FINALIZERS();
+    LOCK();
+    ENTER_GC();
+    if (!GC_is_initialized) GC_init_inner();
+    /* Minimize junk left in my registers */
+      GC_noop(0,0,0,0,0,0);
+    result = (int)GC_try_to_collect_inner(stop_func);
+    EXIT_GC();
+    UNLOCK();
+    if(result) {
+        if (GC_debugging_started) GC_print_all_smashed();
+        GC_INVOKE_FINALIZERS();
+    }
+    return(result);
+}
+
+void GC_gcollect(void)
+{
+    (void)GC_try_to_collect(GC_never_stop_func);
+    if (GC_have_errors) GC_print_all_errors();
+}
+
+word GC_n_heap_sects = 0;	/* Number of sections currently in heap. */
+
+#ifdef USE_PROC_FOR_LIBRARIES
+  word GC_n_memory = 0;		/* Number of GET_MEM allocated memory	*/
+				/* sections.				*/
+#endif
+
+#ifdef USE_PROC_FOR_LIBRARIES
+  /* Add HBLKSIZE aligned, GET_MEM-generated block to GC_our_memory. */
+  /* Defined to do nothing if USE_PROC_FOR_LIBRARIES not set.	    */
+  void GC_add_to_our_memory(ptr_t p, size_t bytes)
+  {
+    if (0 == p) return;
+    GC_our_memory[GC_n_memory].hs_start = p;
+    GC_our_memory[GC_n_memory].hs_bytes = bytes;
+    GC_n_memory++;
+  }
+#endif
+/*
+ * Use the chunk of memory starting at p of size bytes as part of the heap.
+ * Assumes p is HBLKSIZE aligned, and bytes is a multiple of HBLKSIZE.
+ */
+void GC_add_to_heap(struct hblk *p, size_t bytes)
+{
+    hdr * phdr;
+    word endp;
+    
+    if (GC_n_heap_sects >= MAX_HEAP_SECTS) {
+    	ABORT("Too many heap sections: Increase MAXHINCR or MAX_HEAP_SECTS");
+    }
+    while ((word)p <= HBLKSIZE) {
+        /* Can't handle memory near address zero. */
+        ++p;
+	bytes -= HBLKSIZE;
+        if (0 == bytes) return;
+    }
+    endp = (word)p + bytes;
+    if (endp <= (word)p) {
+    	/* Address wrapped. */
+	bytes -= HBLKSIZE;
+        if (0 == bytes) return;
+	endp -= HBLKSIZE;
+    }
+    phdr = GC_install_header(p);
+    if (0 == phdr) {
+    	/* This is extremely unlikely. Can't add it.  This will		*/
+    	/* almost certainly result in a	0 return from the allocator,	*/
+    	/* which is entirely appropriate.				*/
+    	return;
+    }
+    GC_ASSERT(endp > (word)p && endp == (word)p + bytes);
+    GC_heap_sects[GC_n_heap_sects].hs_start = (ptr_t)p;
+    GC_heap_sects[GC_n_heap_sects].hs_bytes = bytes;
+    GC_n_heap_sects++;
+    phdr -> hb_sz = bytes;
+    phdr -> hb_flags = 0;
+    GC_freehblk(p);
+    GC_heapsize += bytes;
+    if ((ptr_t)p <= (ptr_t)GC_least_plausible_heap_addr
+        || GC_least_plausible_heap_addr == 0) {
+        GC_least_plausible_heap_addr = (void *)((ptr_t)p - sizeof(word));
+        	/* Making it a little smaller than necessary prevents	*/
+        	/* us from getting a false hit from the variable	*/
+        	/* itself.  There's some unintentional reflection	*/
+        	/* here.						*/
+    }
+    if ((ptr_t)p + bytes >= (ptr_t)GC_greatest_plausible_heap_addr) {
+        GC_greatest_plausible_heap_addr = (void *)endp;
+    }
+}
+
+# if !defined(NO_DEBUGGING)
+void GC_print_heap_sects(void)
+{
+    unsigned i;
+    
+    GC_printf("Total heap size: %lu\n", (unsigned long) GC_heapsize);
+    for (i = 0; i < GC_n_heap_sects; i++) {
+        ptr_t start = GC_heap_sects[i].hs_start;
+        size_t len = GC_heap_sects[i].hs_bytes;
+        struct hblk *h;
+        unsigned nbl = 0;
+        
+    	GC_printf("Section %d from %p to %p ", i,
+    		   start, start + len);
+    	for (h = (struct hblk *)start; h < (struct hblk *)(start + len); h++) {
+    	    if (GC_is_black_listed(h, HBLKSIZE)) nbl++;
+    	}
+    	GC_printf("%lu/%lu blacklisted\n", (unsigned long)nbl,
+    		   (unsigned long)(len/HBLKSIZE));
+    }
+}
+# endif
+
+void * GC_least_plausible_heap_addr = (void *)ONES;
+void * GC_greatest_plausible_heap_addr = 0;
+
+static INLINE word GC_max(word x, word y)
+{
+    return(x > y? x : y);
+}
+
+static INLINE word GC_min(word x, word y)
+{
+    return(x < y? x : y);
+}
+
+void GC_set_max_heap_size(GC_word n)
+{
+    GC_max_heapsize = n;
+}
+
+GC_word GC_max_retries = 0;
+
+/*
+ * this explicitly increases the size of the heap.  It is used
+ * internally, but may also be invoked from GC_expand_hp by the user.
+ * The argument is in units of HBLKSIZE.
+ * Tiny values of n are rounded up.
+ * Returns FALSE on failure.
+ */
+GC_bool GC_expand_hp_inner(word n)
+{
+    word bytes;
+    struct hblk * space;
+    word expansion_slop;	/* Number of bytes by which we expect the */
+    				/* heap to expand soon.			  */
+
+    if (n < MINHINCR) n = MINHINCR;
+    bytes = n * HBLKSIZE;
+    /* Make sure bytes is a multiple of GC_page_size */
+      {
+	word mask = GC_page_size - 1;
+	bytes += mask;
+	bytes &= ~mask;
+      }
+    
+    if (GC_max_heapsize != 0 && GC_heapsize + bytes > GC_max_heapsize) {
+        /* Exceeded self-imposed limit */
+        return(FALSE);
+    }
+    space = GET_MEM(bytes);
+    GC_add_to_our_memory((ptr_t)space, bytes);
+    if( space == 0 ) {
+	if (GC_print_stats) {
+	    GC_log_printf("Failed to expand heap by %ld bytes\n",
+		          (unsigned long)bytes);
+	}
+	return(FALSE);
+    }
+    if (GC_print_stats) {
+	GC_log_printf("Increasing heap size by %lu after %lu allocated bytes\n",
+	              (unsigned long)bytes,
+	              (unsigned long)GC_bytes_allocd);
+    }
+    /* Adjust heap limits generously for blacklisting to work better.	*/
+    /* GC_add_to_heap performs minimal adjustment need for correctness.	*/
+    expansion_slop = min_bytes_allocd() + 4*MAXHINCR*HBLKSIZE;
+    if ((GC_last_heap_addr == 0 && !((word)space & SIGNB))
+        || (GC_last_heap_addr != 0 && GC_last_heap_addr < (ptr_t)space)) {
+        /* Assume the heap is growing up */
+	word new_limit = (word)space + bytes + expansion_slop;
+	if (new_limit > (word)space) {
+          GC_greatest_plausible_heap_addr =
+            (void *)GC_max((word)GC_greatest_plausible_heap_addr,
+                           (word)new_limit);
+	}
+    } else {
+        /* Heap is growing down */
+	word new_limit = (word)space - expansion_slop;
+	if (new_limit < (word)space) {
+          GC_least_plausible_heap_addr =
+            (void *)GC_min((word)GC_least_plausible_heap_addr,
+                           (word)space - expansion_slop);
+	}
+    }
+    GC_prev_heap_addr = GC_last_heap_addr;
+    GC_last_heap_addr = (ptr_t)space;
+    GC_add_to_heap(space, bytes);
+    /* Force GC before we are likely to allocate past expansion_slop */
+      GC_collect_at_heapsize =
+         GC_heapsize + expansion_slop - 2*MAXHINCR*HBLKSIZE;
+#     if defined(LARGE_CONFIG)
+        if (GC_collect_at_heapsize < GC_heapsize /* wrapped */)
+         GC_collect_at_heapsize = (word)(-1);
+#     endif
+    return(TRUE);
+}
+
+/* Really returns a bool, but it's externally visible, so that's clumsy. */
+/* Arguments is in bytes.						*/
+int GC_expand_hp(size_t bytes)
+{
+    int result;
+    DCL_LOCK_STATE;
+    
+    LOCK();
+    if (!GC_is_initialized) GC_init_inner();
+    result = (int)GC_expand_hp_inner(divHBLKSZ((word)bytes));
+    if (result) GC_requested_heapsize += bytes;
+    UNLOCK();
+    return(result);
+}
+
+unsigned GC_fail_count = 0;  
+			/* How many consecutive GC/expansion failures?	*/
+			/* Reset by GC_allochblk.			*/
+
+GC_bool GC_collect_or_expand(word needed_blocks, GC_bool ignore_off_page)
+{
+    if (!GC_incremental && !GC_dont_gc &&
+	((GC_dont_expand && GC_bytes_allocd > 0) || GC_should_collect())) {
+      GC_gcollect_inner();
+    } else {
+      word blocks_to_get = GC_heapsize/(HBLKSIZE*GC_free_space_divisor)
+      			   + needed_blocks;
+      
+      if (blocks_to_get > MAXHINCR) {
+          word slop;
+          
+	  /* Get the minimum required to make it likely that we		*/
+	  /* can satisfy the current request in the presence of black-	*/
+	  /* listing.  This will probably be more than MAXHINCR.	*/
+          if (ignore_off_page) {
+              slop = 4;
+          } else {
+	      slop = 2*divHBLKSZ(BL_LIMIT);
+	      if (slop > needed_blocks) slop = needed_blocks;
+	  }
+          if (needed_blocks + slop > MAXHINCR) {
+              blocks_to_get = needed_blocks + slop;
+          } else {
+              blocks_to_get = MAXHINCR;
+          }
+      }
+      if (!GC_expand_hp_inner(blocks_to_get)
+        && !GC_expand_hp_inner(needed_blocks)) {
+      	if (GC_fail_count++ < GC_max_retries) {
+      	    WARN("Out of Memory!  Trying to continue ...\n", 0);
+	    GC_gcollect_inner();
+	} else {
+#	    if !defined(AMIGA) || !defined(GC_AMIGA_FASTALLOC)
+	      WARN("Out of Memory!  Returning NIL!\n", 0);
+#	    endif
+	    return(FALSE);
+	}
+      } else {
+          if (GC_fail_count && GC_print_stats) {
+	      GC_printf("Memory available again ...\n");
+	  }
+      }
+    }
+    return(TRUE);
+}
+
+/*
+ * Make sure the object free list for size gran (in granules) is not empty.
+ * Return a pointer to the first object on the free list.
+ * The object MUST BE REMOVED FROM THE FREE LIST BY THE CALLER.
+ * Assumes we hold the allocator lock and signals are disabled.
+ *
+ */
+ptr_t GC_allocobj(size_t gran, int kind)
+{
+    void ** flh = &(GC_obj_kinds[kind].ok_freelist[gran]);
+    GC_bool tried_minor = FALSE;
+    
+    if (gran == 0) return(0);
+
+    while (*flh == 0) {
+      ENTER_GC();
+      /* Do our share of marking work */
+        if(TRUE_INCREMENTAL) GC_collect_a_little_inner(1);
+      /* Sweep blocks for objects of this size */
+        GC_continue_reclaim(gran, kind);
+      EXIT_GC();
+      if (*flh == 0) {
+        GC_new_hblk(gran, kind);
+      }
+      if (*flh == 0) {
+        ENTER_GC();
+	if (GC_incremental && GC_time_limit == GC_TIME_UNLIMITED
+	    && ! tried_minor ) {
+	    GC_collect_a_little_inner(1);
+	    tried_minor = TRUE;
+	} else {
+          if (!GC_collect_or_expand((word)1,FALSE)) {
+	    EXIT_GC();
+	    return(0);
+	  }
+	}
+	EXIT_GC();
+      }
+    }
+    /* Successful allocation; reset failure count.	*/
+    GC_fail_count = 0;
+    
+    return(*flh);
+}
diff -Naur gc-7.1alpha3.orig/include/private/#gcconfig.h# gc-7.1alpha3/include/private/#gcconfig.h#
--- gc-7.1alpha3.orig/include/private/#gcconfig.h#	1970-01-01 01:00:00.000000000 +0100
+++ gc-7.1alpha3/include/private/#gcconfig.h#	2008-02-21 07:12:28.000000000 +0100
@@ -0,0 +1,2374 @@
+/* 
+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers
+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.
+ * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.
+ * Copyright (c) 2000-2004 Hewlett-Packard Development Company, L.P.
+ *
+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
+ *
+ * Permission is hereby granted to use or copy this program
+ * for any purpose,  provided the above notices are retained on all copies.
+ * Permission to modify the code and to distribute modified code is granted,
+ * provided the above notices are retained, and a notice that the code was
+ * modified is included with the above copyright notice.
+ */
+
+/*
+ * This header is private to the gc.  It is almost always included from
+ * gc_priv.h.  However it is possible to include it by itself if just the
+ * configuration macros are needed.  In that
+ * case, a few declarations relying on types declared in gc_priv.h will be
+ * omitted.
+ */
+ 
+#ifndef GCCONFIG_H
+
+# define GCCONFIG_H
+
+# ifndef GC_PRIVATE_H
+    /* Fake ptr_t declaration, just to avoid compilation errors.	*/
+    /* This avoids many instances if "ifndef GC_PRIVATE_H" below.	*/
+    typedef struct GC_undefined_struct * ptr_t;
+#   include <stddef.h>	/* For size_t etc. */
+# endif
+
+/* Machine dependent parameters.  Some tuning parameters can be found	*/
+/* near the top of gc_private.h.					*/
+
+/* Machine specific parts contributed by various people.  See README file. */
+
+/* First a unified test for Linux: */
+# if defined(linux) || defined(__linux__)
+#  ifndef LINUX
+#    define LINUX
+#  endif
+# endif
+
+/* And one for NetBSD: */
+# if defined(__NetBSD__)
+#    define NETBSD
+# endif
+
+/* And one for OpenBSD: */
+# if defined(__OpenBSD__)
+#    define OPENBSD
+# endif
+
+/* And one for FreeBSD: */
+# if (defined(__FreeBSD__) || defined(__DragonFly__) || \
+      defined(__FreeBSD_kernel__)) && !defined(FREEBSD)
+#    define FREEBSD
+# endif
+
+/* Determine the machine type: */
+# if defined(__arm__) || defined(__thumb__)
+#    define ARM32
+#    if !defined(LINUX) && !defined(NETBSD)
+#      define NOSYS
+#      define mach_type_known
+#    endif
+# endif
+# if defined(sun) && defined(mc68000)
+#    error SUNOS4 no longer supported
+# endif
+# if defined(hp9000s300)
+#    error M68K based HP machines no longer supported.
+# endif
+# if defined(OPENBSD) && defined(m68k)
+#    define M68K
+#    define mach_type_known
+# endif
+# if defined(OPENBSD) && defined(__sparc__)
+#    define SPARC
+#    define mach_type_known
+# endif
+# if defined(NETBSD) && (defined(m68k) || defined(__m68k__))
+#    define M68K
+#    define mach_type_known
+# endif
+# if defined(NETBSD) && defined(__powerpc__)
+#    define POWERPC
+#    define mach_type_known
+# endif
+# if defined(NETBSD) && (defined(__arm32__) || defined(__arm__))
+#    define ARM32
+#    define mach_type_known
+# endif
+# if defined(NETBSD) && defined(__sh__)
+#    define SH
+#    define mach_type_known
+# endif
+# if defined(vax)
+#    define VAX
+#    ifdef ultrix
+#	define ULTRIX
+#    else
+#	define BSD
+#    endif
+#    define mach_type_known
+# endif
+# if defined(__NetBSD__) && defined(__vax__)
+#    define VAX
+#    define mach_type_known
+# endif
+# if defined(mips) || defined(__mips) || defined(_mips)
+#    define MIPS
+#    if defined(nec_ews) || defined(_nec_ews)
+#      define EWS4800
+#    endif
+#    if !defined(LINUX) && !defined(EWS4800) && !defined(NETBSD)
+#      if defined(ultrix) || defined(__ultrix)
+#	 define ULTRIX
+#      else
+#	 define IRIX5   /* or IRIX 6.X */
+#      endif
+#    endif /* !LINUX */
+#    if defined(__NetBSD__) && defined(__MIPSEL__)
+#      undef ULTRIX
+#    endif
+#    define mach_type_known
+# endif
+# if defined(DGUX) && (defined(i386) || defined(__i386__))
+#    define I386
+#    ifndef _USING_DGUX
+#    define _USING_DGUX
+#    endif
+#    define mach_type_known
+# endif
+# if defined(sequent) && (defined(i386) || defined(__i386__))
+#    define I386
+#    define SEQUENT
+#    define mach_type_known
+# endif
+# if defined(sun) && (defined(i386) || defined(__i386__))
+#    define I386
+#    define SOLARIS
+#    define mach_type_known
+# endif
+# if defined(sun) && defined(__amd64)
+#    define X86_64
+#    define SOLARIS
+#    define mach_type_known
+# endif
+# if (defined(__OS2__) || defined(__EMX__)) && defined(__32BIT__)
+#    define I386
+#    define OS2
+#    define mach_type_known
+# endif
+# if defined(ibm032)
+#   error IBM PC/RT no longer supported.
+# endif
+# if defined(sun) && (defined(sparc) || defined(__sparc))
+#   define SPARC
+    /* Test for SunOS 5.x */
+#     include <errno.h>
+#     define SOLARIS
+#   define mach_type_known
+# endif
+# if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux) \
+     && !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__) \
+     && !defined(__DragonFly__)
+#   define SPARC
+#   define DRSNX
+#   define mach_type_known
+# endif
+# if defined(_IBMR2)
+#   define POWERPC
+#   define AIX
+#   define mach_type_known
+# endif
+# if defined(__NetBSD__) && defined(__sparc__)
+#   define SPARC
+#   define mach_type_known
+# endif
+# if defined(_M_XENIX) && defined(_M_SYSV) && defined(_M_I386)
+	/* The above test may need refinement	*/
+#   define I386
+#   if defined(_SCO_ELF)
+#     define SCO_ELF
+#   else
+#     define SCO
+#   endif
+#   define mach_type_known
+# endif
+# if defined(_AUX_SOURCE)
+#   error A/UX no longer supported
+# endif
+# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) || defined(_PA_RISC2_0) \
+     || defined(hppa) || defined(__hppa__)
+#   define HP_PA
+#   if !defined(LINUX) && !defined(HPUX)
+#     define HPUX
+#   endif
+#   define mach_type_known
+# endif
+# if defined(__ia64) && (defined(_HPUX_SOURCE) || defined(__HP_aCC))
+#   define IA64
+#   ifndef HPUX
+#     define HPUX
+#   endif
+#   define mach_type_known
+# endif
+# if defined(__BEOS__) && defined(_X86_)
+#    define I386
+#    define BEOS
+#    define mach_type_known
+# endif
+# if defined(LINUX) && (defined(i386) || defined(__i386__))
+#    define I386
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__x86_64__)
+#    define X86_64
+#    define mach_type_known
+# endif
+# if defined(LINUX) && (defined(__ia64__) || defined(__ia64))
+#    define IA64
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__arm__)
+#    define ARM32
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__cris__)
+#    ifndef CRIS
+#	define CRIS
+#    endif
+#    define mach_type_known
+# endif
+# if defined(LINUX) && (defined(powerpc) || defined(__powerpc__) || \
+		        defined(powerpc64) || defined(__powerpc64__))
+#    define POWERPC
+#    define mach_type_known
+# endif
+# if defined(FREEBSD) && (defined(powerpc) || defined(__powerpc__))
+#    define POWERPC
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__mc68000__)
+#    define M68K
+#    define mach_type_known
+# endif
+# if defined(LINUX) && (defined(sparc) || defined(__sparc__))
+#    define SPARC
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__arm__)
+#    define ARM32
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__sh__)
+#    define SH
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__m32r__)
+#    define M32R
+#    define mach_type_known
+# endif
+# if defined(__alpha) || defined(__alpha__)
+#   define ALPHA
+#   if !defined(LINUX) && !defined(NETBSD) && !defined(OPENBSD) && !defined(FREEBSD)
+#     define OSF1	/* a.k.a Digital Unix */
+#   endif
+#   define mach_type_known
+# endif
+# if defined(_AMIGA) && !defined(AMIGA)
+#   define AMIGA
+# endif
+# ifdef AMIGA 
+#   define M68K
+#   define mach_type_known
+# endif
+# if defined(THINK_C) || defined(__MWERKS__) && !defined(__powerc)
+#   define M68K
+#   define MACOS
+#   define mach_type_known
+# endif
+# if defined(__MWERKS__) && defined(__powerc) && !defined(__MACH__)
+#   define POWERPC
+#   define MACOS
+#   define mach_type_known
+# endif
+# if defined(macosx) || (defined(__APPLE__) && defined(__MACH__))
+#   define DARWIN
+#   if defined(__ppc__)  || defined(__ppc64__)
+#    define POWERPC
+#    define mach_type_known
+#   elif defined(__x86_64__)
+#    define X86_64
+#    define mach_type_known
+#   elif defined(__i386__)
+#    define I386
+#    define mach_type_known
+#   endif
+# endif
+# if defined(NeXT) && defined(mc68000)
+#   define M68K
+#   define NEXT
+#   define mach_type_known
+# endif
+# if defined(NeXT) && (defined(i386) || defined(__i386__))
+#   define I386
+#   define NEXT
+#   define mach_type_known
+# endif
+# if defined(__OpenBSD__) && (defined(i386) || defined(__i386__))
+#   define I386
+#   define OPENBSD
+#   define mach_type_known
+# endif
+# if defined(FREEBSD) && (defined(i386) || defined(__i386__))
+#   define I386
+#   define mach_type_known
+# endif
+# if defined(FREEBSD) && defined(__x86_64__)
+#   define X86_64
+#   define mach_type_known
+# endif
+# if defined(__NetBSD__) && (defined(i386) || defined(__i386__))
+#   define I386
+#   define mach_type_known
+# endif
+# if defined(__NetBSD__) && defined(__x86_64__)
+#    define X86_64
+#    define mach_type_known
+# endif
+# if defined(FREEBSD) && defined(__sparc__)
+#    define SPARC
+#    define mach_type_known
+# endif
+# if defined(bsdi) && (defined(i386) || defined(__i386__))
+#    define I386
+#    define BSDI
+#    define mach_type_known
+# endif
+# if !defined(mach_type_known) && defined(__386BSD__)
+#   define I386
+#   define THREE86BSD
+#   define mach_type_known
+# endif
+# if defined(_CX_UX) && defined(_M88K)
+#   define M88K
+#   define CX_UX
+#   define mach_type_known
+# endif
+# if defined(DGUX) && defined(m88k)
+#   define M88K
+    /* DGUX defined */
+#   define mach_type_known
+# endif
+# if defined(_WIN32_WCE)
+    /* SH3, SH4, MIPS already defined for corresponding architectures */
+#   if defined(SH3) || defined(SH4)
+#     define SH
+#   endif
+#   if defined(x86)
+#     define I386
+#   endif
+#   if defined(ARM)
+#     define ARM32
+#   endif
+#   define MSWINCE
+#   define mach_type_known
+# else
+#   if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \
+        || defined(_WIN32) && !defined(__CYGWIN32__) && !defined(__CYGWIN__)
+#     if defined(__LP64__) || defined(_WIN64)
+#	define X86_64
+#     else
+#       define I386
+#     endif
+#     define MSWIN32	/* or Win64 */
+#     define mach_type_known
+#   endif
+#   if defined(_MSC_VER) && defined(_M_IA64)
+#     define IA64
+#     define MSWIN32	/* Really win64, but we don't treat 64-bit 	*/
+			/* variants as a differnt platform.		*/
+#   endif
+# endif
+# if defined(__DJGPP__)
+#   define I386
+#   ifndef DJGPP
+#     define DJGPP  /* MSDOS running the DJGPP port of GCC */
+#   endif
+#   define mach_type_known
+# endif
+# if defined(__CYGWIN32__) || defined(__CYGWIN__)
+#   define I386
+#   define CYGWIN32
+#   define mach_type_known
+# endif
+# if defined(__MINGW32__)
+#   define I386
+#   define MSWIN32
+#   define mach_type_known
+# endif
+# if defined(__BORLANDC__)
+#   define I386
+#   define MSWIN32
+#   define mach_type_known
+# endif
+# if defined(_UTS) && !defined(mach_type_known)
+#   define S370
+#   define UTS4
+#   define mach_type_known
+# endif
+# if defined(__pj__)
+#   error PicoJava no longer supported
+    /* The implementation had problems, and I haven't heard of users	*/
+    /* in ages.  If you want it resurrected, let me know.		*/
+# endif
+# if defined(__embedded__) && defined(PPC)
+#   define POWERPC
+#   define NOSYS
+#   define mach_type_known
+# endif
+/* Ivan Demakov */
+# if defined(__WATCOMC__) && defined(__386__)
+#   define I386
+#   if !defined(OS2) && !defined(MSWIN32) && !defined(DOS4GW)
+#     if defined(__OS2__)
+#       define OS2
+#     else
+#       if defined(__WINDOWS_386__) || defined(__NT__)
+#         define MSWIN32
+#       else
+#         define DOS4GW
+#       endif
+#     endif
+#   endif
+#   define mach_type_known
+# endif
+# if defined(__s390__) && defined(LINUX)
+#    define S390
+#    define mach_type_known
+# endif
+# if defined(__GNU__)
+#   if defined(__i386__)
+/* The Debian Hurd running on generic PC */  
+#     define  HURD
+#     define  I386
+#     define  mach_type_known
+#    endif 
+# endif
+# if defined(__TANDEM)
+    /* Nonstop S-series */
+    /* FIXME: Should recognize Integrity series? */
+#   define MIPS
+#   define NONSTOP
+#   define mach_type_known
+# endif
+
+/* Feel free to add more clauses here */
+
+/* Or manually define the machine type here.  A machine type is 	*/
+/* characterized by the architecture.  Some				*/
+/* machine types are further subdivided by OS.				*/
+/* Macros such as LINUX, FREEBSD, etc. distinguish them.		*/
+/* SYSV on an M68K actually means A/UX.					*/
+/* The distinction in these cases is usually the stack starting address */
+# ifndef mach_type_known
+#   error "The collector has not been ported to this machine/OS combination."
+# endif
+		    /* Mapping is: M68K       ==> Motorola 680X0	*/
+		    /*		   (NEXT, and SYSV (A/UX),		*/
+		    /*		   MACOS and AMIGA variants)		*/
+		    /*             I386       ==> Intel 386	 	*/
+		    /*		    (SEQUENT, OS2, SCO, LINUX, NETBSD,	*/
+		    /*		     FREEBSD, THREE86BSD, MSWIN32,	*/
+		    /* 		     BSDI,SOLARIS, NEXT, other variants)	*/
+                    /*             NS32K      ==> Encore Multimax 	*/
+                    /*             MIPS       ==> R2000 through R14K	*/
+                    /*			(many variants)			*/
+                    /*		   VAX	      ==> DEC VAX		*/
+                    /*			(BSD, ULTRIX variants)		*/
+                    /*		   HP_PA      ==> HP9000/700 & /800	*/
+                    /*				  HP/UX, LINUX		*/
+		    /*		   SPARC      ==> SPARC	v7/v8/v9	*/
+		    /*			(SOLARIS, LINUX, DRSNX variants)	*/
+		    /* 		   ALPHA      ==> DEC Alpha 		*/
+		    /*			(OSF1 and LINUX variants)	*/
+		    /* 		   M88K       ==> Motorola 88XX0        */
+		    /* 		        (CX_UX and DGUX)		*/
+		    /* 		   S370	      ==> 370-like machine	*/
+		    /* 			running Amdahl UTS4		*/
+                    /*             S390       ==> 390-like machine      */
+		    /*                  running LINUX                   */
+		    /* 		   ARM32      ==> Intel StrongARM	*/
+		    /* 		   IA64	      ==> Intel IPF		*/
+		    /*				  (e.g. Itanium)	*/
+		    /*			(LINUX and HPUX)	        */
+		    /*		   SH	      ==> Hitachi SuperH	*/
+		    /* 			(LINUX & MSWINCE)		*/
+		    /* 		   X86_64     ==> AMD x86-64		*/
+		    /*		   POWERPC    ==> IBM/Apple PowerPC	*/
+		    /*			(MACOS(<=9),DARWIN(incl.MACOSX),*/
+		    /*			 LINUX, NETBSD, AIX, NOSYS	*/
+		    /*			 variants)			*/
+		    /*			Handles 32 and 64-bit variants.	*/
+		    /*		   CRIS       ==> Axis Etrax		*/
+		    /*		   M32R	      ==> Renesas M32R		*/
+
+
+/*
+ * For each architecture and OS, the following need to be defined:
+ *
+ * CPP_WORDSZ is a simple integer constant representing the word size.
+ * in bits.  We assume byte addressibility, where a byte has 8 bits.
+ * We also assume CPP_WORDSZ is either 32 or 64.
+ * (We care about the length of pointers, not hardware
+ * bus widths.  Thus a 64 bit processor with a C compiler that uses
+ * 32 bit pointers should use CPP_WORDSZ of 32, not 64. Default is 32.)
+ *
+ * MACH_TYPE is a string representation of the machine type.
+ * OS_TYPE is analogous for the OS.
+ *
+ * ALIGNMENT is the largest N, such that
+ * all pointer are guaranteed to be aligned on N byte boundaries.
+ * defining it to be 1 will always work, but perform poorly.
+ *
+ * DATASTART is the beginning of the data segment.
+ * On some platforms SEARCH_FOR_DATA_START is defined.
+ * SEARCH_FOR_DATASTART will cause GC_data_start to
+ * be set to an address determined by accessing data backwards from _end
+ * until an unmapped page is found.  DATASTART will be defined to be
+ * GC_data_start.
+ * On UNIX-like systems, the collector will scan the area between DATASTART
+ * and DATAEND for root pointers.
+ *
+ * DATAEND, if not `end' where `end' is defined as ``extern int end[];''.
+ * RTH suggests gaining access to linker script synth'd values with
+ * this idiom instead of `&end' where `end' is defined as ``extern int end;'' .
+ * Otherwise, ``GCC will assume these are in .sdata/.sbss'' and it will, e.g.,
+ * cause failures on alpha*-*-* with ``-msmall-data or -fpic'' or mips-*-*
+ * without any special options.
+ *
+ * STACKBOTTOM is the cool end of the stack, which is usually the
+ * highest address in the stack.
+ * Under PCR or OS/2, we have other ways of finding thread stacks.
+ * For each machine, the following should:
+ * 1) define STACK_GROWS_UP if the stack grows toward higher addresses, and
+ * 2) define exactly one of
+ *	STACKBOTTOM (should be defined to be an expression)
+ *	LINUX_STACKBOTTOM
+ *	HEURISTIC1
+ *	HEURISTIC2
+ * If STACKBOTTOM is defined, then it's value will be used directly as the
+ * stack base.  If LINUX_STACKBOTTOM is defined, then it will be determined
+ * with a method appropriate for most Linux systems.  Currently we look
+ * first for __libc_stack_end (currently only id USE_LIBC_PRIVATES is
+ * defined), and if that fails read it from /proc.  (If USE_LIBC_PRIVATES
+ * is not defined and NO_PROC_STAT is defined, we revert to HEURISTIC2.)
+ * If either of the last two macros are defined, then STACKBOTTOM is computed
+ * during collector startup using one of the following two heuristics:
+ * HEURISTIC1:  Take an address inside GC_init's frame, and round it up to
+ *		the next multiple of STACK_GRAN.
+ * HEURISTIC2:  Take an address inside GC_init's frame, increment it repeatedly
+ *		in small steps (decrement if STACK_GROWS_UP), and read the value
+ *		at each location.  Remember the value when the first
+ *		Segmentation violation or Bus error is signalled.  Round that
+ *		to the nearest plausible page boundary, and use that instead
+ *		of STACKBOTTOM.
+ *
+ * Gustavo Rodriguez-Rivera points out that on most (all?) Unix machines,
+ * the value of environ is a pointer that can serve as STACKBOTTOM.
+ * I expect that HEURISTIC2 can be replaced by this approach, which
+ * interferes far less with debugging.  However it has the disadvantage
+ * that it's confused by a putenv call before the collector is initialized.
+ * This could be dealt with by intercepting putenv ...
+ *
+ * If no expression for STACKBOTTOM can be found, and neither of the above
+ * heuristics are usable, the collector can still be used with all of the above
+ * undefined, provided one of the following is done:
+ * 1) GC_mark_roots can be changed to somehow mark from the correct stack(s)
+ *    without reference to STACKBOTTOM.  This is appropriate for use in
+ *    conjunction with thread packages, since there will be multiple stacks.
+ *    (Allocating thread stacks in the heap, and treating them as ordinary
+ *    heap data objects is also possible as a last resort.  However, this is
+ *    likely to introduce significant amounts of excess storage retention
+ *    unless the dead parts of the thread stacks are periodically cleared.)
+ * 2) Client code may set GC_stackbottom before calling any GC_ routines.
+ *    If the author of the client code controls the main program, this is
+ *    easily accomplished by introducing a new main program, setting
+ *    GC_stackbottom to the address of a local variable, and then calling
+ *    the original main program.  The new main program would read something
+ *    like:
+ *
+ *		# include "gc_private.h"
+ *
+ *		main(argc, argv, envp)
+ *		int argc;
+ *		char **argv, **envp;
+ *		{
+ *		    int dummy;
+ *
+ *		    GC_stackbottom = (ptr_t)(&dummy);
+ *		    return(real_main(argc, argv, envp));
+ *		}
+ *
+ *
+ * Each architecture may also define the style of virtual dirty bit
+ * implementation to be used:
+ *   MPROTECT_VDB: Write protect the heap and catch faults.
+ *   GWW_VDB: Use win32 GetWriteWatch primitive.
+ *   PROC_VDB: Use the SVR4 /proc primitives to read dirty bits.
+ *
+ * The first and second one may be combined, in which case a runtime
+ * selection will be made, based on GetWriteWatch availability.
+ *
+ * An architecture may define DYNAMIC_LOADING if dynamic_load.c
+ * defined GC_register_dynamic_libraries() for the architecture.
+ *
+ * An architecture may define PREFETCH(x) to preload the cache with *x.
+ * This defaults to a no-op.
+ *
+ * PREFETCH_FOR_WRITE(x) is used if *x is about to be written.
+ *
+ * An architecture may also define CLEAR_DOUBLE(x) to be a fast way to
+ * clear the two words at GC_malloc-aligned address x.  By default,
+ * word stores of 0 are used instead.
+ *
+ * HEAP_START may be defined as the initial address hint for mmap-based
+ * allocation.
+ */
+
+/* If we are using a recent version of gcc, we can use __builtin_unwind_init()
+ * to push the relevant registers onto the stack.
+ */
+# if defined(__GNUC__) && ((__GNUC__ >= 3) || \
+			   (__GNUC__ == 2 && __GNUC_MINOR__ >= 8)) \
+		       && !defined(__INTEL_COMPILER) && !defined(__PATHCC__)
+#   define HAVE_BUILTIN_UNWIND_INIT
+# endif
+
+# define STACK_GRAN 0x1000000
+# ifdef M68K
+#   define MACH_TYPE "M68K"
+#   define ALIGNMENT 2
+#   ifdef OPENBSD
+#	define OS_TYPE "OPENBSD"
+#	define HEURISTIC2
+#	ifdef __ELF__
+#	  define DATASTART GC_data_start
+#	  define DYNAMIC_LOADING
+#	else
+	  extern char etext[];
+#	  define DATASTART ((ptr_t)(etext))
+#       endif
+#   endif
+#   ifdef NETBSD
+#	define OS_TYPE "NETBSD"
+#	define HEURISTIC2
+#	ifdef __ELF__
+#	  define DATASTART GC_data_start
+#	  define DYNAMIC_LOADING
+#	else
+	  extern char etext[];
+#	  define DATASTART ((ptr_t)(etext))
+#       endif
+#   endif
+#   ifdef LINUX
+#       define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#       define MPROTECT_VDB
+#       ifdef __ELF__
+#            define DYNAMIC_LOADING
+#	     include <features.h>
+#	     if defined(__GLIBC__)&& __GLIBC__>=2
+#              define SEARCH_FOR_DATA_START
+#	     else /* !GLIBC2 */
+               extern char **__environ;
+#              define DATASTART ((ptr_t)(&__environ))
+                             /* hideous kludge: __environ is the first */
+                             /* word in crt0.o, and delimits the start */
+                             /* of the data segment, no matter which   */
+                             /* ld options were passed through.        */
+                             /* We could use _etext instead, but that  */
+                             /* would include .rodata, which may       */
+                             /* contain large read-only data tables    */
+                             /* that we'd rather not scan.             */
+#	     endif /* !GLIBC2 */
+             extern int _end[];
+#            define DATAEND (_end)
+#       else
+             extern int etext[];
+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#       endif
+#   endif
+#   ifdef AMIGA
+#	define OS_TYPE "AMIGA"
+ 	    	/* STACKBOTTOM and DATASTART handled specially	*/
+ 	    	/* in os_dep.c					*/
+# 	define DATAEND	/* not needed */
+#	define GETPAGESIZE() 4096
+#   endif
+#   ifdef MACOS
+#     ifndef __LOWMEM__
+#     include <LowMem.h>
+#     endif
+#     define OS_TYPE "MACOS"
+			/* see os_dep.c for details of global data segments. */
+#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())
+#     define DATAEND	/* not needed */
+#     define GETPAGESIZE() 4096
+#   endif
+#   ifdef NEXT
+#	define OS_TYPE "NEXT"
+#	define DATASTART ((ptr_t) get_etext())
+#	define STACKBOTTOM ((ptr_t) 0x4000000)
+#	define DATAEND	/* not needed */
+#   endif
+# endif
+
+# if defined(POWERPC)
+#   define MACH_TYPE "POWERPC"
+#   ifdef MACOS
+#     define ALIGNMENT 2  /* Still necessary?  Could it be 4?	*/
+#     ifndef __LOWMEM__
+#     include <LowMem.h>
+#     endif
+#     define OS_TYPE "MACOS"
+			/* see os_dep.c for details of global data segments. */
+#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())
+#     define DATAEND  /* not needed */
+#   endif
+#   ifdef LINUX
+#     if defined(__powerpc64__)
+#       define ALIGNMENT 8
+#       define CPP_WORDSZ 64
+#       ifndef HBLKSIZE
+#         define HBLKSIZE 4096
+#       endif
+#     else
+#       define ALIGNMENT 4
+#     endif
+#     define OS_TYPE "LINUX"
+      /* HEURISTIC1 has been reliably reported to fail for a 32-bit	*/
+      /* executable on a 64 bit kernel.					*/
+#     define LINUX_STACKBOTTOM
+#     define DYNAMIC_LOADING
+#     define SEARCH_FOR_DATA_START
+      extern int _end[];
+#     define DATAEND (_end)
+#   endif
+#   ifdef DARWIN
+#     define OS_TYPE "DARWIN"
+#     define DYNAMIC_LOADING
+#     if defined(__ppc64__)
+#       define ALIGNMENT 8
+#       define CPP_WORDSZ 64
+#       define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)
+#       define CACHE_LINE_SIZE 64
+#       ifndef HBLKSIZE
+#         define HBLKSIZE 4096
+#       endif
+#     else
+#       define ALIGNMENT 4
+#       define STACKBOTTOM ((ptr_t) 0xc0000000)
+#     endif
+      /* XXX: see get_end(3), get_etext() and get_end() should not be used.
+	 These aren't used when dyld support is enabled (it is by default) */
+#     define DATASTART ((ptr_t) get_etext())
+#     define DATAEND	((ptr_t) get_end())
+#     define USE_MMAP
+#     define USE_MMAP_ANON
+#     ifdef GC_DARWIN_THREADS
+#       define MPROTECT_VDB
+#     endif
+#     include <unistd.h>
+#     define GETPAGESIZE() getpagesize()
+#     if defined(USE_PPC_PREFETCH) && defined(__GNUC__)
+	/* The performance impact of prefetches is untested */
+#	define PREFETCH(x) \
+	  __asm__ __volatile__ ("dcbt 0,%0" : : "r" ((const void *) (x)))
+#	define PREFETCH_FOR_WRITE(x) \
+	  __asm__ __volatile__ ("dcbtst 0,%0" : : "r" ((const void *) (x)))
+#     endif
+      /* There seems to be some issues with trylock hanging on darwin. This
+	 should be looked into some more */
+#     define NO_PTHREAD_TRYLOCK
+#   endif
+#   ifdef FREEBSD
+#       define ALIGNMENT 4
+#       define OS_TYPE "FREEBSD"
+#       ifndef GC_FREEBSD_THREADS
+#           define MPROTECT_VDB
+#       endif
+#       define SIG_SUSPEND SIGUSR1
+#       define SIG_THR_RESTART SIGUSR2
+#       define FREEBSD_STACKBOTTOM
+#       ifdef __ELF__
+#           define DYNAMIC_LOADING
+#       endif
+        extern char etext[];
+        extern char * GC_FreeBSDGetDataStart();
+#       define DATASTART GC_FreeBSDGetDataStart(0x1000, &etext)
+#   endif
+#   ifdef NETBSD
+#     define ALIGNMENT 4
+#     define OS_TYPE "NETBSD"
+#     define HEURISTIC2
+      extern char etext[];
+#     define DATASTART GC_data_start
+#     define DYNAMIC_LOADING
+#   endif
+#   ifdef AIX
+#     define OS_TYPE "AIX"
+#     undef ALIGNMENT /* in case it's defined	*/
+#     ifdef IA64
+#       undef IA64
+          /* DOB: some AIX installs stupidly define IA64 in */
+          /* /usr/include/sys/systemcfg.h   		    */
+#     endif
+#     ifdef __64BIT__
+#       define ALIGNMENT 8
+#       define CPP_WORDSZ 64
+#       define STACKBOTTOM ((ptr_t)0x1000000000000000)
+#     else
+#       define ALIGNMENT 4
+#       define CPP_WORDSZ 32
+#       define STACKBOTTOM ((ptr_t)((ulong)&errno))
+#     endif
+#     define USE_MMAP
+#     define USE_MMAP_ANON
+	/* From AIX linker man page:
+	_text Specifies the first location of the program.
+	_etext Specifies the first location after the program.
+	_data Specifies the first location of the data.
+	_edata Specifies the first location after the initialized data
+	_end or end Specifies the first location after all data.
+	*/
+      extern int _data[], _end[];
+#     define DATASTART ((ptr_t)((ulong)_data))
+#     define DATAEND ((ptr_t)((ulong)_end))
+      extern int errno;
+#     define DYNAMIC_LOADING
+	/* For really old versions of AIX, this may have to be removed. */
+#   endif
+
+#   ifdef NOSYS
+#     define ALIGNMENT 4
+#     define OS_TYPE "NOSYS"
+      extern void __end[], __dso_handle[];
+#     define DATASTART (__dso_handle)  /* OK, that's ugly.  */
+#     define DATAEND (__end)
+	/* Stack starts at 0xE0000000 for the simulator.  */
+#     undef STACK_GRAN
+#     define STACK_GRAN 0x10000000
+#     define HEURISTIC1
+#   endif
+# endif
+
+# ifdef VAX
+#   define MACH_TYPE "VAX"
+#   define ALIGNMENT 4	/* Pointers are longword aligned by 4.2 C compiler */
+    extern char etext[];
+#   define DATASTART ((ptr_t)(etext))
+#   ifdef BSD
+#	define OS_TYPE "BSD"
+#	define HEURISTIC1
+			/* HEURISTIC2 may be OK, but it's hard to test. */
+#   endif
+#   ifdef ULTRIX
+#	define OS_TYPE "ULTRIX"
+#	define STACKBOTTOM ((ptr_t) 0x7fffc800)
+#   endif
+# endif
+
+# ifdef SPARC
+#   define MACH_TYPE "SPARC"
+#   if defined(__arch64__) || defined(__sparcv9)
+#     define ALIGNMENT 8
+#     define CPP_WORDSZ 64
+#     define ELF_CLASS ELFCLASS64
+#   else
+#     define ALIGNMENT 4	/* Required by hardware	*/
+#     define CPP_WORDSZ 32
+#   endif
+    /* Don't define USE_ASM_PUSH_REGS.  We do use an asm helper, but	*/
+    /* not to push the registers on the mark stack.			*/
+#   ifdef SOLARIS
+#	define OS_TYPE "SOLARIS"
+	extern int _etext[];
+	extern int _end[];
+	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_SysVGetDataStart(0x10000, (ptr_t)_etext)
+#	define DATAEND (_end)
+#	if !defined(USE_MMAP) && defined(REDIRECT_MALLOC)
+#	    define USE_MMAP
+	    /* Otherwise we now use calloc.  Mmap may result in the	*/
+	    /* heap interleaved with thread stacks, which can result in	*/
+	    /* excessive blacklisting.  Sbrk is unusable since it	*/
+	    /* doesn't interact correctly with the system malloc.	*/
+#	endif
+#       ifdef USE_MMAP
+#         define HEAP_START (ptr_t)0x40000000
+#       else
+#	  define HEAP_START DATAEND
+#       endif
+#	define PROC_VDB
+/*	HEURISTIC1 reportedly no longer works under 2.7.  		*/
+/*  	HEURISTIC2 probably works, but this appears to be preferable.	*/
+/*	Apparently USRSTACK is defined to be USERLIMIT, but in some	*/
+/* 	installations that's undefined.  We work around this with a	*/
+/*	gross hack:							*/
+#       include <sys/vmparam.h>
+#	ifdef USERLIMIT
+	  /* This should work everywhere, but doesn't.	*/
+#	  define STACKBOTTOM USRSTACK
+#       else
+#	  define HEURISTIC2
+#       endif
+#	include <unistd.h>
+#       define GETPAGESIZE()  sysconf(_SC_PAGESIZE)
+		/* getpagesize() appeared to be missing from at least one */
+		/* Solaris 5.4 installation.  Weird.			  */
+#	define DYNAMIC_LOADING
+#   endif
+#   ifdef DRSNX
+#	define OS_TYPE "DRSNX"
+	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+	extern int etext[];
+#       define DATASTART GC_SysVGetDataStart(0x10000, (ptr_t)etext)
+#	define MPROTECT_VDB
+#       define STACKBOTTOM ((ptr_t) 0xdfff0000)
+#	define DYNAMIC_LOADING
+#   endif
+#   ifdef LINUX
+#     define OS_TYPE "LINUX"
+#     ifdef __ELF__
+#       define DYNAMIC_LOADING
+#     else
+          Linux Sparc/a.out not supported
+#     endif
+      extern int _end[];
+      extern int _etext[];
+#     define DATAEND (_end)
+#     define SVR4
+      extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#     ifdef __arch64__
+#	define DATASTART GC_SysVGetDataStart(0x100000, (ptr_t)_etext)
+#     else
+#       define DATASTART GC_SysVGetDataStart(0x10000, (ptr_t)_etext)
+#     endif
+#     define LINUX_STACKBOTTOM
+#   endif
+#   ifdef OPENBSD
+#     define OS_TYPE "OPENBSD"
+#     define STACKBOTTOM ((ptr_t) 0xf8000000)
+      extern int etext[];
+#     define DATASTART ((ptr_t)(etext))
+#   endif
+#   ifdef NETBSD
+#     define OS_TYPE "NETBSD"
+#     define HEURISTIC2
+#     ifdef __ELF__
+#	define DATASTART GC_data_start
+#	define DYNAMIC_LOADING
+#     else
+	extern char etext[];
+#	define DATASTART ((ptr_t)(etext))
+#     endif
+#   endif
+#   ifdef FREEBSD
+#	define OS_TYPE "FREEBSD"
+#	define SIG_SUSPEND SIGUSR1
+#	define SIG_THR_RESTART SIGUSR2
+#	define FREEBSD_STACKBOTTOM
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+	extern char etext[];
+	extern char edata[];
+	extern char end[];
+#	define NEED_FIND_LIMIT
+#	define DATASTART ((ptr_t)(&etext))
+#	define DATAEND (GC_find_limit (DATASTART, TRUE))
+#	define DATASTART2 ((ptr_t)(&edata))
+#	define DATAEND2 ((ptr_t)(&end))
+#   endif
+# endif
+
+# ifdef I386
+#   define MACH_TYPE "I386"
+#   if defined(__LP64__) || defined(_WIN64)
+#     error This should be handled as X86_64
+#   else
+#     define CPP_WORDSZ 32
+#     define ALIGNMENT 4
+			/* Appears to hold for all "32 bit" compilers	*/
+			/* except Borland.  The -a4 option fixes 	*/
+			/* Borland.					*/
+                        /* Ivan Demakov: For Watcom the option is -zp4. */
+#   endif
+#   ifdef SEQUENT
+#	define OS_TYPE "SEQUENT"
+	extern int etext[];
+#       define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#       define STACKBOTTOM ((ptr_t) 0x3ffff000) 
+#   endif
+#   ifdef BEOS
+#     define OS_TYPE "BEOS"
+#     include <OS.h>
+#     define GETPAGESIZE() B_PAGE_SIZE
+      extern int etext[];
+#     define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#   endif
+#   ifdef SOLARIS
+#	define OS_TYPE "SOLARIS"
+        extern int _etext[], _end[];
+  	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_SysVGetDataStart(0x1000, (ptr_t)_etext)
+#	define DATAEND (_end)
+/*	# define STACKBOTTOM ((ptr_t)(_start)) worked through 2.7,  	*/
+/*      but reportedly breaks under 2.8.  It appears that the stack	*/
+/* 	base is a property of the executable, so this should not break	*/
+/* 	old executables.						*/
+/*  	HEURISTIC2 probably works, but this appears to be preferable.	*/
+#       include <sys/vm.h>
+#	define STACKBOTTOM USRSTACK
+/* At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */
+/* It appears to be fixed in 2.8 and 2.9.				*/
+#	ifdef SOLARIS25_PROC_VDB_BUG_FIXED
+#	  define PROC_VDB
+#	endif
+#	define DYNAMIC_LOADING
+#	if !defined(USE_MMAP) && defined(REDIRECT_MALLOC)
+#	    define USE_MMAP
+	    /* Otherwise we now use calloc.  Mmap may result in the	*/
+	    /* heap interleaved with thread stacks, which can result in	*/
+	    /* excessive blacklisting.  Sbrk is unusable since it	*/
+	    /* doesn't interact correctly with the system malloc.	*/
+#	endif
+#       ifdef USE_MMAP
+#         define HEAP_START (ptr_t)0x40000000
+#       else
+#	  define HEAP_START DATAEND
+#       endif
+#   endif
+#   ifdef SCO
+#	define OS_TYPE "SCO"
+	extern int etext[];
+#   	define DATASTART ((ptr_t)((((word) (etext)) + 0x3fffff) \
+				  & ~0x3fffff) \
+				 +((word)etext & 0xfff))
+#	define STACKBOTTOM ((ptr_t) 0x7ffffffc)
+#   endif
+#   ifdef SCO_ELF
+#       define OS_TYPE "SCO_ELF"
+        extern int etext[];
+#       define DATASTART ((ptr_t)(etext))
+#       define STACKBOTTOM ((ptr_t) 0x08048000)
+#       define DYNAMIC_LOADING
+#	define ELF_CLASS ELFCLASS32
+#   endif
+#   ifdef DGUX
+#	define OS_TYPE "DGUX"
+	extern int _etext, _end;
+	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#	define DATASTART GC_SysVGetDataStart(0x1000, (ptr_t)(&_etext))
+#	define DATAEND (&_end)
+#	define STACK_GROWS_DOWN
+#	define HEURISTIC2
+#	include <unistd.h>
+#	define GETPAGESIZE()  sysconf(_SC_PAGESIZE)
+#	define DYNAMIC_LOADING
+#	ifndef USE_MMAP
+#	  define USE_MMAP
+#	endif /* USE_MMAP */
+#	define MAP_FAILED (void *) -1
+#	ifdef USE_MMAP
+#	  define HEAP_START (ptr_t)0x40000000
+#	else /* USE_MMAP */
+#	  define HEAP_START DATAEND
+#	endif /* USE_MMAP */
+#   endif /* DGUX */
+
+#   ifdef LINUX
+#	define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#	if 0
+#	  define HEURISTIC1
+#         undef STACK_GRAN
+#         define STACK_GRAN 0x10000000
+	  /* STACKBOTTOM is usually 0xc0000000, but this changes with	*/
+	  /* different kernel configurations.  In particular, systems	*/
+	  /* with 2GB physical memory will usually move the user	*/
+	  /* address space limit, and hence initial SP to 0x80000000.	*/
+#       endif
+#       if !defined(GC_LINUX_THREADS) || !defined(REDIRECT_MALLOC)
+#	    define MPROTECT_VDB
+#	else
+	    /* We seem to get random errors in incremental mode,	*/
+	    /* possibly because Linux threads is itself a malloc client */
+	    /* and can't deal with the signals.				*/
+#	endif
+#	define HEAP_START (ptr_t)0x1000
+		/* This encourages mmap to give us low addresses,	*/
+		/* thus allowing the heap to grow to ~3GB		*/
+#       ifdef __ELF__
+#            define DYNAMIC_LOADING
+#	     ifdef UNDEFINED	/* includes ro data */
+	       extern int _etext[];
+#              define DATASTART ((ptr_t)((((word) (_etext)) + 0xfff) & ~0xfff))
+#	     endif
+#	     include <features.h>
+#	     if defined(__GLIBC__) && __GLIBC__ >= 2
+#		 define SEARCH_FOR_DATA_START
+#	     else
+     	         extern char **__environ;
+#                define DATASTART ((ptr_t)(&__environ))
+			      /* hideous kludge: __environ is the first */
+			      /* word in crt0.o, and delimits the start */
+			      /* of the data segment, no matter which   */
+			      /* ld options were passed through.        */
+			      /* We could use _etext instead, but that  */
+			      /* would include .rodata, which may       */
+			      /* contain large read-only data tables    */
+			      /* that we'd rather not scan.		*/
+#	     endif
+	     extern int _end[];
+#	     define DATAEND (_end)
+#	else
+	     extern int etext[];
+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#       endif
+#	ifdef USE_I686_PREFETCH
+	  /* FIXME: Thus should use __builtin_prefetch, but we'll leave that	*/
+	  /* for the next rtelease.						*/
+#	  define PREFETCH(x) \
+	    __asm__ __volatile__ ("	prefetchnta	%0": : "m"(*(char *)(x)))
+	    /* Empirically prefetcht0 is much more effective at reducing	*/
+	    /* cache miss stalls for the targetted load instructions.  But it	*/
+	    /* seems to interfere enough with other cache traffic that the net	*/
+	    /* result is worse than prefetchnta.				*/
+#         if 0 
+	    /* Using prefetches for write seems to have a slight negative	*/
+	    /* impact on performance, at least for a PIII/500.			*/
+#	    define PREFETCH_FOR_WRITE(x) \
+	      __asm__ __volatile__ ("	prefetcht0	%0": : "m"(*(char *)(x)))
+#	  endif
+#	endif
+#	ifdef USE_3DNOW_PREFETCH
+#	  define PREFETCH(x) \
+	    __asm__ __volatile__ ("	prefetch	%0": : "m"(*(char *)(x)))
+#	  define PREFETCH_FOR_WRITE(x) \
+	    __asm__ __volatile__ ("	prefetchw	%0": : "m"(*(char *)(x)))
+#	endif
+#   endif
+#   ifdef CYGWIN32
+#       define OS_TYPE "CYGWIN32"
+#       define DATASTART ((ptr_t)GC_DATASTART)  /* From gc.h */
+#       define DATAEND	 ((ptr_t)GC_DATAEND)
+#	undef STACK_GRAN
+#       define STACK_GRAN 0x10000
+#       define HEURISTIC1
+#   endif
+#   ifdef OS2
+#	define OS_TYPE "OS2"
+ 	    	/* STACKBOTTOM and DATASTART are handled specially in 	*/
+		/* os_dep.c. OS2 actually has the right			*/
+		/* system call!						*/
+#	define DATAEND	/* not needed */
+#   endif
+#   ifdef MSWIN32
+#	define OS_TYPE "MSWIN32"
+		/* STACKBOTTOM and DATASTART are handled specially in 	*/
+		/* os_dep.c.						*/
+#       if !defined(__WATCOMC__)
+#	  define MPROTECT_VDB
+	  /* We also avoided doing this in the past with GC_WIN32_THREADS */
+	  /* Hopefully that's fixed.					  */
+#	endif
+#	if _MSC_VER >= 1300  /* .NET, i.e. > VisualStudio 6	*/
+#         define GWW_VDB
+#	endif
+#       define DATAEND  /* not needed */
+#   endif
+#   ifdef MSWINCE
+#	define OS_TYPE "MSWINCE"
+#       define DATAEND  /* not needed */
+#   endif
+#   ifdef DJGPP
+#       define OS_TYPE "DJGPP"
+#       include "stubinfo.h"
+        extern int etext[];
+        extern int _stklen;
+        extern int __djgpp_stack_limit;
+#       define DATASTART ((ptr_t)((((word) (etext)) + 0x1ff) & ~0x1ff))
+/* #       define STACKBOTTOM ((ptr_t)((word) _stubinfo + _stubinfo->size \
+                                                     + _stklen)) */
+#       define STACKBOTTOM ((ptr_t)((word) __djgpp_stack_limit + _stklen))
+		/* This may not be right.  */
+#   endif
+#   ifdef OPENBSD
+#	define OS_TYPE "OPENBSD"
+#   endif
+#   ifdef FREEBSD
+#	define OS_TYPE "FREEBSD"
+#	ifndef GC_FREEBSD_THREADS
+#	    define MPROTECT_VDB
+#	endif
+#	ifdef __GLIBC__
+#	    define SIG_SUSPEND		(32+6)
+#	    define SIG_THR_RESTART	(32+5)
+	    extern int _end[];
+#	    define DATAEND (_end)
+#	else
+#	    define SIG_SUSPEND SIGUSR1
+#	    define SIG_THR_RESTART SIGUSR2
+#	endif
+#	define FREEBSD_STACKBOTTOM
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+	extern char etext[];
+	extern char * GC_FreeBSDGetDataStart(size_t, ptr_t);
+#	define DATASTART GC_FreeBSDGetDataStart(0x1000, (ptr_t)etext)
+#   endif
+#   ifdef NETBSD
+#	define OS_TYPE "NETBSD"
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+#   endif
+#   ifdef THREE86BSD
+#	define OS_TYPE "THREE86BSD"
+#   endif
+#   ifdef BSDI
+#	define OS_TYPE "BSDI"
+#   endif
+#   if defined(OPENBSD) || defined(NETBSD) \
+        || defined(THREE86BSD) || defined(BSDI)
+#	define HEURISTIC2
+	extern char etext[];
+#	define DATASTART ((ptr_t)(etext))
+#   endif
+#   ifdef NEXT
+#	define OS_TYPE "NEXT"
+#	define DATASTART ((ptr_t) get_etext())
+#	define STACKBOTTOM ((ptr_t)0xc0000000)
+#	define DATAEND	/* not needed */
+#   endif
+#   ifdef DOS4GW
+#     define OS_TYPE "DOS4GW"
+      extern long __nullarea;
+      extern char _end;
+      extern char *_STACKTOP;
+      /* Depending on calling conventions Watcom C either precedes
+         or does not precedes with undescore names of C-variables.
+         Make sure startup code variables always have the same names.  */
+      #pragma aux __nullarea "*";
+      #pragma aux _end "*";
+#     define STACKBOTTOM ((ptr_t) _STACKTOP)
+                         /* confused? me too. */
+#     define DATASTART ((ptr_t) &__nullarea)
+#     define DATAEND ((ptr_t) &_end)
+#   endif
+#   ifdef HURD
+#     define OS_TYPE "HURD"
+#     define STACK_GROWS_DOWN
+#     define HEURISTIC2
+#     define SIG_SUSPEND SIGUSR1
+#     define SIG_THR_RESTART SIGUSR2
+#     define SEARCH_FOR_DATA_START
+      extern int _end[];
+#     define DATAEND ((ptr_t) (_end))
+/* #     define MPROTECT_VDB  Not quite working yet? */
+#     define DYNAMIC_LOADING
+#   endif
+#   ifdef DARWIN
+#     define OS_TYPE "DARWIN"
+#     define DARWIN_DONT_PARSE_STACK
+#     define DYNAMIC_LOADING
+      /* XXX: see get_end(3), get_etext() and get_end() should not be used.
+	 These aren't used when dyld support is enabled (it is by default) */
+#     define DATASTART ((ptr_t) get_etext())
+#     define DATAEND	((ptr_t) get_end())
+#     define STACKBOTTOM ((ptr_t) 0xc0000000)
+#     define USE_MMAP
+#     define USE_MMAP_ANON
+#     ifdef GC_DARWIN_THREADS
+#       define MPROTECT_VDB
+#     endif
+#     include <unistd.h>
+#     define GETPAGESIZE() getpagesize()
+      /* There seems to be some issues with trylock hanging on darwin. This
+	 should be looked into some more */
+#      define NO_PTHREAD_TRYLOCK
+#   endif /* DARWIN */
+# endif
+
+# ifdef NS32K
+#   define MACH_TYPE "NS32K"
+#   define ALIGNMENT 4
+    extern char **environ;
+#   define DATASTART ((ptr_t)(&environ))
+			      /* hideous kludge: environ is the first   */
+			      /* word in crt0.o, and delimits the start */
+			      /* of the data segment, no matter which   */
+			      /* ld options were passed through.        */
+#   define STACKBOTTOM ((ptr_t) 0xfffff000) /* for Encore */
+# endif
+
+# ifdef MIPS
+#   define MACH_TYPE "MIPS"
+#   ifdef LINUX
+      /* This was developed for a linuxce style platform.  Probably	*/
+      /* needs to be tweaked for workstation class machines.		*/
+#     define OS_TYPE "LINUX"
+#     define DYNAMIC_LOADING
+      extern int _end[];
+#     define DATAEND (_end)
+      extern int __data_start[];
+#     define DATASTART ((ptr_t)(__data_start))
+#     ifdef _MIPS_SZPTR
+#	define CPP_WORDSZ _MIPS_SZPTR
+#	define ALIGNMENT (_MIPS_SZPTR/8)
+#     else
+#	define ALIGNMENT 4
+#     endif
+#     if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 2 || __GLIBC__ > 2
+#        define LINUX_STACKBOTTOM
+#     else
+#        define STACKBOTTOM 0x80000000
+#     endif
+#   endif /* Linux */
+#   ifdef EWS4800
+#      define HEURISTIC2
+#      if defined(_MIPS_SZPTR) && (_MIPS_SZPTR == 64)
+         extern int _fdata[], _end[];
+#        define DATASTART ((ptr_t)_fdata)
+#        define DATAEND ((ptr_t)_end)
+#        define CPP_WORDSZ _MIPS_SZPTR
+#        define ALIGNMENT (_MIPS_SZPTR/8)
+#      else
+         extern int etext[], edata[], end[];
+         extern int _DYNAMIC_LINKING[], _gp[];
+#        define DATASTART ((ptr_t)((((word)etext + 0x3ffff) & ~0x3ffff) \
+               + ((word)etext & 0xffff)))
+#        define DATAEND (edata)
+#        define DATASTART2 (_DYNAMIC_LINKING \
+               ? (ptr_t)(((word)_gp + 0x8000 + 0x3ffff) & ~0x3ffff) \
+               : (ptr_t)edata)
+#        define DATAEND2 (end)
+#        define ALIGNMENT 4
+#      endif
+#      define OS_TYPE "EWS4800"
+#   endif
+#   ifdef ULTRIX
+#	define HEURISTIC2
+#       define DATASTART (ptr_t)0x10000000
+			      /* Could probably be slightly higher since */
+			      /* startup code allocates lots of stuff.   */
+#	define OS_TYPE "ULTRIX"
+#       define ALIGNMENT 4
+#   endif
+#   ifdef IRIX5
+#	define HEURISTIC2
+        extern int _fdata[];
+#       define DATASTART ((ptr_t)(_fdata))
+#       ifdef USE_MMAP
+#         define HEAP_START (ptr_t)0x30000000
+#       else
+#	  define HEAP_START DATASTART
+#       endif
+			      /* Lowest plausible heap address.		*/
+			      /* In the MMAP case, we map there.	*/
+			      /* In either case it is used to identify	*/
+			      /* heap sections so they're not 		*/
+			      /* considered as roots.			*/
+#	define OS_TYPE "IRIX5"
+/*#       define MPROTECT_VDB DOB: this should work, but there is evidence */
+/* 	  	of recent breakage.					   */
+#       ifdef _MIPS_SZPTR
+#	  define CPP_WORDSZ _MIPS_SZPTR
+#	  define ALIGNMENT (_MIPS_SZPTR/8)
+#	else
+#         define ALIGNMENT 4
+#	endif
+#	define DYNAMIC_LOADING
+#   endif
+#   ifdef MSWINCE
+#       define OS_TYPE "MSWINCE"
+#       define ALIGNMENT 4
+#       define DATAEND /* not needed */
+#   endif
+#   if defined(NETBSD)
+#     define OS_TYPE "NETBSD"
+#     define ALIGNMENT 4
+#     define HEURISTIC2
+#     ifdef __ELF__
+        extern int etext[];
+#       define DATASTART GC_data_start
+#       define NEED_FIND_LIMIT
+#       define DYNAMIC_LOADING
+#     else
+#       define DATASTART ((ptr_t) 0x10000000)
+#       define STACKBOTTOM ((ptr_t) 0x7ffff000)
+#     endif /* _ELF_ */
+#  endif
+#  if defined(NONSTOP)
+#    define CPP_WORDSZ 32
+#    define OS_TYPE "NONSTOP"
+#    define ALIGNMENT 4
+#    define DATASTART ((ptr_t) 0x08000000)
+     extern char **environ;
+#    define DATAEND ((ptr_t)(environ - 0x10))
+#    define STACKBOTTOM ((ptr_t) 0x4fffffff)
+#   endif
+# endif
+
+# ifdef HP_PA
+#   define MACH_TYPE "HP_PA"
+#   ifdef __LP64__
+#     define CPP_WORDSZ 64
+#     define ALIGNMENT 8
+#   else
+#     define CPP_WORDSZ 32
+#     define ALIGNMENT 4
+#   endif
+#   if !defined(GC_HPUX_THREADS) && !defined(GC_LINUX_THREADS)
+#     ifndef LINUX /* For now. */
+#       define MPROTECT_VDB
+#     endif
+#   else
+#     ifdef PARALLEL_MARK
+#	define USE_MARK_BYTES
+		/* Minimize compare-and-swap usage.		*/
+#     endif
+#   endif
+#   define STACK_GROWS_UP
+#   ifdef HPUX
+#     define OS_TYPE "HPUX"
+      extern int __data_start[];
+#     define DATASTART ((ptr_t)(__data_start))
+#     if 0
+	/* The following appears to work for 7xx systems running HP/UX	*/
+	/* 9.xx Furthermore, it might result in much faster		*/
+	/* collections than HEURISTIC2, which may involve scanning	*/
+	/* segments that directly precede the stack.  It is not the	*/
+	/* default, since it may not work on older machine/OS		*/
+	/* combinations. (Thanks to Raymond X.T. Nijssen for uncovering	*/
+	/* this.)							*/
+#       define STACKBOTTOM ((ptr_t) 0x7b033000)  /* from /etc/conf/h/param.h */
+#     else
+	/* Gustavo Rodriguez-Rivera suggested changing HEURISTIC2	*/
+	/* to this.  Note that the GC must be initialized before the	*/
+    	/* first putenv call.						*/
+	extern char ** environ;
+#       define STACKBOTTOM ((ptr_t)environ)
+#     endif
+#     define DYNAMIC_LOADING
+#     include <unistd.h>
+#     define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)
+#     ifndef __GNUC__
+#       define PREFETCH(x)  { \
+                              register long addr = (long)(x); \
+                              (void) _asm ("LDW", 0, 0, addr, 0); \
+                            }
+#     endif
+#   endif /* HPUX */
+#   ifdef LINUX
+#     define OS_TYPE "LINUX"
+#     define LINUX_STACKBOTTOM
+#     define DYNAMIC_LOADING
+#     define SEARCH_FOR_DATA_START
+      extern int _end[];
+#     define DATAEND (&_end)
+#   endif /* LINUX */
+# endif /* HP_PA */
+
+# ifdef ALPHA
+#   define MACH_TYPE "ALPHA"
+#   define ALIGNMENT 8
+#   define CPP_WORDSZ 64
+#   ifdef NETBSD
+#	define OS_TYPE "NETBSD"
+#	define HEURISTIC2
+#	define DATASTART GC_data_start
+#	define ELFCLASS32 32
+#	define ELFCLASS64 64
+#	define ELF_CLASS ELFCLASS64
+#       define DYNAMIC_LOADING
+#   endif
+#   ifdef OPENBSD
+#	define OS_TYPE "OPENBSD"
+#	define HEURISTIC2
+#   	ifdef __ELF__	/* since OpenBSD/Alpha 2.9 */
+#	   define DATASTART GC_data_start
+#   	   define ELFCLASS32 32
+#   	   define ELFCLASS64 64
+#   	   define ELF_CLASS ELFCLASS64
+#       else		/* ECOFF, until OpenBSD/Alpha 2.7 */
+#   	   define DATASTART ((ptr_t) 0x140000000)
+#   	endif
+#   endif
+#   ifdef FREEBSD
+#	define OS_TYPE "FREEBSD"
+/* MPROTECT_VDB is not yet supported at all on FreeBSD/alpha. */
+#	define SIG_SUSPEND SIGUSR1
+#	define SIG_THR_RESTART SIGUSR2
+#	define FREEBSD_STACKBOTTOM
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+/* Handle unmapped hole alpha*-*-freebsd[45]* puts between etext and edata. */
+	extern char etext[];
+	extern char edata[];
+	extern char end[];
+#	define NEED_FIND_LIMIT
+#	define DATASTART ((ptr_t)(&etext))
+#	define DATAEND (GC_find_limit (DATASTART, TRUE))
+#	define DATASTART2 ((ptr_t)(&edata))
+#	define DATAEND2 ((ptr_t)(&end))
+#   endif
+#   ifdef OSF1
+#	define OS_TYPE "OSF1"
+#   	define DATASTART ((ptr_t) 0x140000000)
+	extern int _end[];
+#   	define DATAEND ((ptr_t) &_end)
+ 	extern char ** environ;
+	/* round up from the value of environ to the nearest page boundary */
+	/* Probably breaks if putenv is called before collector 	   */
+	/* initialization.						   */
+#	define STACKBOTTOM ((ptr_t)(((word)(environ) | (getpagesize()-1))+1))
+/* #   	define HEURISTIC2 */
+	/* Normally HEURISTIC2 is too conervative, since		*/
+	/* the text segment immediately follows the stack.		*/
+	/* Hence we give an upper pound.				*/
+	/* This is currently unused, since we disabled HEURISTIC2	*/
+    	extern int __start[];
+#   	define HEURISTIC2_LIMIT ((ptr_t)((word)(__start) & ~(getpagesize()-1)))
+#	ifndef GC_OSF1_THREADS
+	  /* Unresolved signal issues with threads.	*/
+#   	  define MPROTECT_VDB
+#       endif
+#   	define DYNAMIC_LOADING
+#   endif
+#   ifdef LINUX
+#       define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#       ifdef __ELF__
+#	  define SEARCH_FOR_DATA_START
+#         define DYNAMIC_LOADING
+#       else
+#           define DATASTART ((ptr_t) 0x140000000)
+#       endif
+	extern int _end[];
+#	define DATAEND (_end)
+#	define MPROTECT_VDB
+		/* Has only been superficially tested.  May not	*/
+		/* work on all versions.			*/
+#   endif
+# endif
+
+# ifdef IA64
+#   define MACH_TYPE "IA64"
+#   ifdef HPUX
+#	ifdef _ILP32
+#	  define CPP_WORDSZ 32
+	    /* Requires 8 byte alignment for malloc */
+#   	  define ALIGNMENT 4
+#       else
+#	  ifndef _LP64
+		---> unknown ABI
+#         endif
+#	  define CPP_WORDSZ 64
+	    /* Requires 16 byte alignment for malloc */
+#         define ALIGNMENT 8
+#       endif
+#       define OS_TYPE "HPUX"	
+        extern int __data_start[];
+#       define DATASTART ((ptr_t)(__data_start))
+        /* Gustavo Rodriguez-Rivera suggested changing HEURISTIC2	*/
+        /* to this.  Note that the GC must be initialized before the	*/
+    	/* first putenv call.						*/
+	extern char ** environ;
+#       define STACKBOTTOM ((ptr_t)environ)
+#       define HPUX_STACKBOTTOM
+#       define DYNAMIC_LOADING
+#       include <unistd.h>
+#       define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)
+ 	/* The following was empirically determined, and is probably	*/
+	/* not very robust.						*/
+	/* Note that the backing store base seems to be at a nice 	*/
+	/* address minus one page.					*/
+#	define BACKING_STORE_DISPLACEMENT 0x1000000
+#	define BACKING_STORE_ALIGNMENT 0x1000
+	extern ptr_t GC_register_stackbottom;
+#	define BACKING_STORE_BASE GC_register_stackbottom
+	/* Known to be wrong for recent HP/UX versions!!!	*/
+#   endif
+#   ifdef LINUX
+#   	define CPP_WORDSZ 64
+#   	define ALIGNMENT 8
+#       define OS_TYPE "LINUX"
+	/* The following works on NUE and older kernels:	*/
+/* #       define STACKBOTTOM ((ptr_t) 0xa000000000000000l)	*/
+	/* This does not work on NUE:				*/
+#       define LINUX_STACKBOTTOM
+	/* We also need the base address of the register stack	*/
+	/* backing store.  This is computed in 			*/
+	/* GC_linux_register_stack_base based on the following	*/
+	/* constants:						*/
+#       define BACKING_STORE_ALIGNMENT 0x100000
+#       define BACKING_STORE_DISPLACEMENT 0x80000000
+	extern ptr_t GC_register_stackbottom;
+#	define BACKING_STORE_BASE GC_register_stackbottom
+#	define SEARCH_FOR_DATA_START
+#	ifdef __GNUC__
+#         define DYNAMIC_LOADING
+#	else
+	  /* In the Intel compiler environment, we seem to end up with  */
+	  /* statically linked executables and an undefined reference	*/
+	  /* to _DYNAMIC						*/
+#  	endif
+#	define MPROTECT_VDB
+		/* Requires Linux 2.3.47 or later.	*/
+	extern int _end[];
+#	define DATAEND (_end)
+#       ifdef __GNUC__
+#	  ifndef __INTEL_COMPILER
+#	    define PREFETCH(x) \
+	      __asm__ ("	lfetch	[%0]": : "r"(x))
+#	    define PREFETCH_FOR_WRITE(x) \
+	      __asm__ ("	lfetch.excl	[%0]": : "r"(x))
+#	    define CLEAR_DOUBLE(x) \
+	      __asm__ ("	stf.spill	[%0]=f0": : "r"((void *)(x)))
+#	  else
+#           include <ia64intrin.h>
+#	    define PREFETCH(x) \
+	      __lfetch(__lfhint_none, (x))
+#	    define PREFETCH_FOR_WRITE(x) \
+	      __lfetch(__lfhint_nta,  (x))
+#	    define CLEAR_DOUBLE(x) \
+	      __stf_spill((void *)(x), 0)
+#	  endif // __INTEL_COMPILER
+#       endif
+#   endif
+#   ifdef MSWIN32
+      /* FIXME: This is a very partial guess.  There is no port, yet.	*/
+#     define OS_TYPE "MSWIN32"
+		/* STACKBOTTOM and DATASTART are handled specially in 	*/
+		/* os_dep.c.						*/
+#     define DATAEND  /* not needed */
+#     if defined(_WIN64)
+#       define CPP_WORDSZ 64
+#     else
+#       define CPP_WORDSZ 32   /* Is this possible?	*/
+#     endif
+#     define ALIGNMENT 8
+#     define STRTOULL _strtoui64
+#   endif
+# endif
+
+# ifdef M88K
+#   define MACH_TYPE "M88K"
+#   define ALIGNMENT 4
+    extern int etext[];
+#   ifdef CX_UX
+#	define OS_TYPE "CX_UX"
+#       define DATASTART ((((word)etext + 0x3fffff) & ~0x3fffff) + 0x10000)
+#   endif
+#   ifdef  DGUX
+#	define OS_TYPE "DGUX"
+	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_SysVGetDataStart(0x10000, (ptr_t)etext)
+#   endif
+#   define STACKBOTTOM ((char*)0xf0000000) /* determined empirically */
+# endif
+
+# ifdef S370
+    /* If this still works, and if anyone cares, this should probably	*/
+    /* be moved to the S390 category.					*/
+#   define MACH_TYPE "S370"
+#   define ALIGNMENT 4	/* Required by hardware	*/
+#   ifdef UTS4
+#       define OS_TYPE "UTS4"
+	extern int etext[];
+	extern int _etext[];
+	extern int _end[];
+	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_SysVGetDataStart(0x10000, (ptr_t)_etext)
+#	define DATAEND (_end)
+#	define HEURISTIC2
+#   endif
+# endif
+
+# ifdef S390
+#   define MACH_TYPE "S390"
+#   ifndef __s390x__
+#   define ALIGNMENT 4
+#   define CPP_WORDSZ 32
+#   else
+#   define ALIGNMENT 8
+#   define CPP_WORDSZ 64
+#   ifndef HBLKSIZE
+#     define HBLKSIZE 4096
+#   endif
+#   endif
+#   ifdef LINUX
+#       define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#       define DYNAMIC_LOADING
+	extern int __data_start[];
+#       define DATASTART ((ptr_t)(__data_start))
+    extern int _end[];
+#   define DATAEND (_end)
+#   define CACHE_LINE_SIZE 256
+#   define GETPAGESIZE() 4096
+#   endif
+# endif
+
+# ifdef ARM32
+#   define CPP_WORDSZ 32
+#   define MACH_TYPE "ARM32"
+#   define ALIGNMENT 4
+#   ifdef NETBSD
+#       define OS_TYPE "NETBSD"
+#       define HEURISTIC2
+#	ifdef __ELF__
+#          define DATASTART GC_data_start
+#	   define DYNAMIC_LOADING
+#	else
+           extern char etext[];
+#          define DATASTART ((ptr_t)(etext))
+#	endif
+#   endif
+#   ifdef LINUX
+#       define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#       undef STACK_GRAN
+#       define STACK_GRAN 0x10000000
+#       ifdef __ELF__
+#            define DYNAMIC_LOADING
+#	     include <features.h>
+#	     if defined(__GLIBC__) && __GLIBC__ >= 2
+#		 define SEARCH_FOR_DATA_START
+#	     else
+     	         extern char **__environ;
+#                define DATASTART ((ptr_t)(&__environ))
+			      /* hideous kludge: __environ is the first */
+			      /* word in crt0.o, and delimits the start */
+			      /* of the data segment, no matter which   */
+			      /* ld options were passed through.        */
+			      /* We could use _etext instead, but that  */
+			      /* would include .rodata, which may       */
+			      /* contain large read-only data tables    */
+			      /* that we'd rather not scan.		*/
+#	     endif
+	     extern int _end[];
+#	     define DATAEND (_end)
+#	else
+	     extern int etext[];
+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#       endif
+#   endif
+#   ifdef MSWINCE
+#     define OS_TYPE "MSWINCE"
+#     define DATAEND /* not needed */
+#   endif
+#   ifdef NOSYS
+      /* __data_start is usually defined in the target linker script.  */
+      extern int __data_start[];
+#     define DATASTART (ptr_t)(__data_start)
+      /* __stack_base__ is set in newlib/libc/sys/arm/crt0.S  */
+      extern void *__stack_base__;
+#     define STACKBOTTOM ((ptr_t) (__stack_base__))
+#   endif
+#endif
+
+# ifdef CRIS
+#   define MACH_TYPE "CRIS"
+#   define CPP_WORDSZ 32
+#   define ALIGNMENT 1
+#   define OS_TYPE "LINUX"
+#   define DYNAMIC_LOADING
+#   define LINUX_STACKBOTTOM
+#   define SEARCH_FOR_DATA_START
+      extern int _end[];
+#   define DATAEND (_end)
+# endif
+
+# ifdef SH
+#   define MACH_TYPE "SH"
+#   define ALIGNMENT 4
+#   ifdef MSWINCE
+#     define OS_TYPE "MSWINCE"
+#     define DATAEND /* not needed */
+#   endif
+#   ifdef LINUX
+#     define OS_TYPE "LINUX"
+#     define LINUX_STACKBOTTOM
+#     define DYNAMIC_LOADING
+#     define SEARCH_FOR_DATA_START
+      extern int _end[];
+#     define DATAEND (_end)
+#   endif
+#   ifdef NETBSD
+#      define OS_TYPE "NETBSD"
+#      define HEURISTIC2
+#      define DATASTART GC_data_start
+#      define DYNAMIC_LOADING
+#   endif
+# endif
+ 
+# ifdef SH4
+#   define MACH_TYPE "SH4"
+#   define OS_TYPE "MSWINCE"
+#   define ALIGNMENT 4
+#   define DATAEND /* not needed */
+# endif
+
+# ifdef M32R
+#   define CPP_WORDSZ 32
+#   define MACH_TYPE "M32R"
+#   define ALIGNMENT 4
+#   ifdef LINUX
+#     define OS_TYPE "LINUX"
+#     define LINUX_STACKBOTTOM
+#     undef STACK_GRAN
+#     define STACK_GRAN 0x10000000
+#     define DYNAMIC_LOADING
+#     define SEARCH_FOR_DATA_START
+      extern int _end[];
+#     define DATAEND (_end)
+#   endif
+# endif
+
+# ifdef X86_64
+#   define MACH_TYPE "X86_64"
+#   define ALIGNMENT 8
+#   define CPP_WORDSZ 64
+#   ifndef HBLKSIZE
+#     define HBLKSIZE 4096
+#   endif
+#   define CACHE_LINE_SIZE 64
+#   ifdef LINUX
+#	define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#       if !defined(GC_LINUX_THREADS) || !defined(REDIRECT_MALLOC)
+#	    define MPROTECT_VDB
+#	else
+	    /* We seem to get random errors in incremental mode,	*/
+	    /* possibly because Linux threads is itself a malloc client */
+	    /* and can't deal with the signals.				*/
+#	endif
+#       ifdef __ELF__
+#            define DYNAMIC_LOADING
+#	     ifdef UNDEFINED	/* includes ro data */
+	       extern int _etext[];
+#              define DATASTART ((ptr_t)((((word) (_etext)) + 0xfff) & ~0xfff))
+#	     endif
+#	     include <features.h>
+#	     define SEARCH_FOR_DATA_START
+	     extern int _end[];
+#	     define DATAEND (_end)
+#	else
+	     extern int etext[];
+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#       endif
+#       if defined(__GNUC__) && __GNUC__ >= 3
+#	    define PREFETCH(x) __builtin_prefetch((x), 0, 0)
+#	    define PREFETCH_FOR_WRITE(x) __builtin_prefetch((x), 1)
+#	endif
+#   endif
+#   ifdef DARWIN
+#     define OS_TYPE "DARWIN"
+#     define DARWIN_DONT_PARSE_STACK
+#     define DYNAMIC_LOADING
+      /* XXX: see get_end(3), get_etext() and get_end() should not be used.
+	 These aren't used when dyld support is enabled (it is by default) */
+#     define DATASTART ((ptr_t) get_etext())
+#     define DATAEND	((ptr_t) get_end())
+#     define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)
+#     define USE_MMAP
+#     define USE_MMAP_ANON
+#     ifdef GC_DARWIN_THREADS
+#       define MPROTECT_VDB
+#     endif
+#     include <unistd.h>
+#     define GETPAGESIZE() getpagesize()
+      /* There seems to be some issues with trylock hanging on darwin. This
+	 should be looked into some more */
+#     define NO_PTHREAD_TRYLOCK
+#   endif
+#   ifdef FREEBSD
+#	define OS_TYPE "FREEBSD"
+#	ifndef GC_FREEBSD_THREADS
+#	    define MPROTECT_VDB
+#	endif
+#	ifdef __GLIBC__
+#	    define SIG_SUSPEND		(32+6)
+#	    define SIG_THR_RESTART	(32+5)
+	    extern int _end[];
+#	    define DATAEND (_end)
+#	else
+#	    define SIG_SUSPEND SIGUSR1
+#	    define SIG_THR_RESTART SIGUSR2
+#	endif
+#	define FREEBSD_STACKBOTTOM
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+	extern char etext[];
+	extern char * GC_FreeBSDGetDataStart();
+#	define DATASTART GC_FreeBSDGetDataStart(0x1000, &etext)
+#   endif
+#   ifdef NETBSD
+#	define OS_TYPE "NETBSD"
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+#	define HEURISTIC2
+	extern char etext[];
+#	define SEARCH_FOR_DATA_START
+#   endif
+#   ifdef SOLARIS
+#	define OS_TYPE "SOLARIS"
+#	define ELF_CLASS ELFCLASS64
+        extern int _etext[], _end[];
+  	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_SysVGetDataStart(0x1000, (ptr_t)_etext)
+#	define DATAEND (_end)
+/*	# define STACKBOTTOM ((ptr_t)(_start)) worked through 2.7,  	*/
+/*      but reportedly breaks under 2.8.  It appears that the stack	*/
+/* 	base is a property of the executable, so this should not break	*/
+/* 	old executables.						*/
+/*  	HEURISTIC2 probably works, but this appears to be preferable.	*/
+/*	Apparently USRSTACK is defined to be USERLIMIT, but in some	*/
+/* 	installations that's undefined.  We work around this with a	*/
+/*	gross hack:							*/
+#       include <sys/vmparam.h>
+#	ifdef USERLIMIT
+	  /* This should work everywhere, but doesn't.	*/
+#	  define STACKBOTTOM USRSTACK
+#       else
+#	  define HEURISTIC2
+#       endif
+/* At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */
+/* It appears to be fixed in 2.8 and 2.9.				*/
+#	ifdef SOLARIS25_PROC_VDB_BUG_FIXED
+#	  define PROC_VDB
+#	endif
+#	define DYNAMIC_LOADING
+#	if !defined(USE_MMAP) && defined(REDIRECT_MALLOC)
+#	    define USE_MMAP
+	    /* Otherwise we now use calloc.  Mmap may result in the	*/
+	    /* heap interleaved with thread stacks, which can result in	*/
+	    /* excessive blacklisting.  Sbrk is unusable since it	*/
+	    /* doesn't interact correctly with the system malloc.	*/
+#	endif
+#       ifdef USE_MMAP
+#         define HEAP_START (ptr_t)0x40000000
+#       else
+#	  define HEAP_START DATAEND
+#       endif
+#   endif
+#   ifdef MSWIN32
+#	define OS_TYPE "MSWIN32"
+		/* STACKBOTTOM and DATASTART are handled specially in 	*/
+		/* os_dep.c.						*/
+#       if !defined(__WATCOMC__)
+#	  define MPROTECT_VDB
+	  /* We also avoided doing this in the past with GC_WIN32_THREADS */
+	  /* Hopefully that's fixed.					  */
+#	endif
+#	if _MSC_VER >= 1300  /* .NET, i.e. > VisualStudio 6	*/
+#         define GWW_VDB
+#	endif
+#       define DATAEND  /* not needed */
+#   endif
+# endif
+
+#if defined(LINUX_STACKBOTTOM) && defined(NO_PROC_STAT) \
+    && !defined(USE_LIBC_PRIVATES)
+    /* This combination will fail, since we have no way to get	*/
+    /* the stack base.	Use HEURISTIC2 instead.			*/
+#   undef LINUX_STACKBOTTOM
+#   define HEURISTIC2
+    /* This may still fail on some architectures like IA64.	*/
+    /* We tried ...						*/
+#endif
+
+#if defined(LINUX_STACKBOTTOM) && defined(NO_PROC_STAT) \
+    && !defined(USE_LIBC_PRIVATES)
+    /* This combination will fail, since we have no way to get	*/
+    /* the stack base.	Use HEURISTIC2 instead.			*/
+#   undef LINUX_STACKBOTTOM
+#   define HEURISTIC2
+    /* This may still fail on some architectures like IA64.	*/
+    /* We tried ...						*/
+#endif
+
+#if defined(LINUX) && defined(USE_MMAP)
+    /* The kernel may do a somewhat better job merging mappings etc.	*/
+    /* with anonymous mappings.						*/
+#   define USE_MMAP_ANON
+#endif
+
+#if defined(GC_LINUX_THREADS) && defined(REDIRECT_MALLOC)
+    /* Nptl allocates thread stacks with mmap, which is fine.  But it	*/
+    /* keeps a cache of thread stacks.  Thread stacks contain the	*/
+    /* thread control blocks.  These in turn contain a pointer to	*/
+    /* (sizeof (void *) from the beginning of) the dtv for thread-local	*/
+    /* storage, which is calloc allocated.  If we don't scan the cached	*/
+    /* thread stacks, we appear to lose the dtv.  This tends to		*/
+    /* result in something that looks like a bogus dtv count, which	*/
+    /* tends to result in a memset call on a block that is way too	*/
+    /* large.  Sometimes we're lucky and the process just dies ...	*/
+    /* There seems to be a similar issue with some other memory 	*/
+    /* allocated by the dynamic loader.					*/
+    /* This should be avoidable by either:				*/
+    /* - Defining USE_PROC_FOR_LIBRARIES here.				*/
+    /*   That performs very poorly, precisely because we end up 	*/
+    /*   scanning cached stacks.					*/
+    /* - Have calloc look at its callers.  				*/
+    /*   In spite of the fact that it is gross and disgusting.		*/
+    /* In fact neither seems to suffice, probably in part because 	*/
+    /* even with USE_PROC_FOR_LIBRARIES, we don't scan parts of stack	*/
+    /* segments that appear to be out of bounds.  Thus we actually	*/
+    /* do both, which seems to yield the best results.			*/
+
+#   define USE_PROC_FOR_LIBRARIES
+#endif
+
+# ifndef STACK_GROWS_UP
+#   define STACK_GROWS_DOWN
+# endif
+
+# ifndef CPP_WORDSZ
+#   define CPP_WORDSZ 32
+# endif
+
+# ifndef OS_TYPE
+#   define OS_TYPE ""
+# endif
+
+# ifndef DATAEND
+    extern int end[];
+#   define DATAEND (end)
+# endif
+
+# if defined(SVR4) && !defined(GETPAGESIZE)
+#    include <unistd.h>
+#    define GETPAGESIZE()  sysconf(_SC_PAGESIZE)
+# endif
+
+# ifndef GETPAGESIZE
+#   if defined(SOLARIS) || defined(IRIX5) || defined(LINUX) \
+       || defined(NETBSD) || defined(FREEBSD) || defined(HPUX)
+#	include <unistd.h>
+#   endif
+#   define GETPAGESIZE() getpagesize()
+# endif
+
+# if defined(SOLARIS) || defined(DRSNX) || defined(UTS4)
+	    /* OS has SVR4 generic features.		*/
+    	    /* Probably others also qualify.		*/
+#   define SVR4
+# endif
+
+# if defined(SOLARIS) || defined(DRSNX)
+	    /* OS has SOLARIS style semi-undocumented interface */
+    	    /* to dynamic loader.				*/
+#   define SOLARISDL
+	    /* OS has SOLARIS style signal handlers.		*/
+#   define SUNOS5SIGS
+# endif
+
+# if defined(HPUX)
+#   define SUNOS5SIGS
+# endif
+
+# if defined(FREEBSD) && \
+     (defined(__DragonFly__) || __FreeBSD__ >= 4 || (__FreeBSD_kernel__ >= 4))
+#   define SUNOS5SIGS
+# endif
+
+# ifdef GC_NETBSD_THREADS
+#   define SIGRTMIN 33
+#   define SIGRTMAX 63
+# endif
+
+# if defined(SVR4) || defined(LINUX) || defined(IRIX5) || defined(HPUX) \
+	    || defined(OPENBSD) || defined(NETBSD) || defined(FREEBSD) \
+	    || defined(DGUX) || defined(BSD) \
+	    || defined(AIX) || defined(DARWIN) || defined(OSF1) \
+	    || defined(HURD)
+#   define UNIX_LIKE   /* Basic Unix-like system calls work.	*/
+# endif
+
+# if CPP_WORDSZ != 32 && CPP_WORDSZ != 64
+	   -> bad word size
+# endif
+
+# ifdef PCR
+#   undef DYNAMIC_LOADING
+#   undef STACKBOTTOM
+#   undef HEURISTIC1
+#   undef HEURISTIC2
+#   undef PROC_VDB
+#   undef MPROTECT_VDB
+#   define PCR_VDB
+# endif
+
+# ifdef SMALL_CONFIG
+	/* Presumably not worth the space it takes. */
+#   undef PROC_VDB
+#   undef MPROTECT_VDB
+# endif
+
+# ifdef USE_MUNMAP
+#   undef MPROTECT_VDB  /* Can't deal with address space holes. */
+# endif
+
+# ifdef PARALLEL_MARK
+#   undef MPROTECT_VDB  /* For now.	*/
+# endif
+
+# if !defined(PCR_VDB) && !defined(PROC_VDB) && !defined(MPROTECT_VDB) \
+    && !defined(GWW_VDB)
+#   define DEFAULT_VDB
+# endif
+
+# ifndef PREFETCH
+#   define PREFETCH(x)
+#   define NO_PREFETCH
+# endif
+
+# ifndef PREFETCH_FOR_WRITE
+#   define PREFETCH_FOR_WRITE(x)
+#   define NO_PREFETCH_FOR_WRITE
+# endif
+
+# ifndef CACHE_LINE_SIZE
+#   define CACHE_LINE_SIZE 32	/* Wild guess	*/
+# endif
+
+# if defined(LINUX) || defined(HURD) || defined(__GLIBC__)
+#   define REGISTER_LIBRARIES_EARLY
+    /* We sometimes use dl_iterate_phdr, which may acquire an internal	*/
+    /* lock.  This isn't safe after the world has stopped.  So we must	*/
+    /* call GC_register_dynamic_libraries before stopping the world.	*/
+    /* For performance reasons, this may be beneficial on other		*/
+    /* platforms as well, though it should be avoided in win32.		*/
+# endif /* LINUX */
+
+# if defined(SEARCH_FOR_DATA_START)
+    extern ptr_t GC_data_start;
+#   define DATASTART GC_data_start
+# endif
+
+# ifndef CLEAR_DOUBLE
+#   define CLEAR_DOUBLE(x) \
+		((word*)x)[0] = 0; \
+		((word*)x)[1] = 0;
+# endif /* CLEAR_DOUBLE */
+
+# if defined(GC_LINUX_THREADS) && defined(REDIRECT_MALLOC) \
+     && !defined(INCLUDE_LINUX_THREAD_DESCR)
+    /* Will not work, since libc and the dynamic loader use thread 	*/
+    /* locals, sometimes as the only reference.				*/
+#   define INCLUDE_LINUX_THREAD_DESCR
+# endif
+
+# if defined(GC_IRIX_THREADS) && !defined(IRIX5)
+	--> inconsistent configuration
+# endif
+# if defined(GC_LINUX_THREADS) && !defined(LINUX)
+	--> inconsistent configuration
+# endif
+# if defined(GC_NETBSD_THREADS) && !defined(NETBSD)
+	--> inconsistent configuration
+# endif
+qy# if defined(GC_FREEBSD_THREADS) && !defined(FREEBSD)
+	--> inconsistent configuration
+# endif
+# if defined(GC_SOLARIS_THREADS) && !defined(SOLARIS)
+	--> inconsistent configuration
+# endif
+# if defined(GC_HPUX_THREADS) && !defined(HPUX)
+	--> inconsistent configuration
+# endif
+# if defined(GC_AIX_THREADS) && !defined(_AIX)
+	--> inconsistent configuration
+# endif
+# if defined(GC_GNU_THREADS) && !defined(HURD)
+	--> inconsistent configuration
+# endif
+# if defined(GC_WIN32_THREADS) && !defined(MSWIN32) && !defined(CYGWIN32)
+	--> inconsistent configuration
+# endif
+
+# if defined(PCR) || defined(GC_WIN32_THREADS) || defined(GC_PTHREADS)
+#   define THREADS
+# endif
+
+# if !defined(USE_MARK_BITS) && !defined(USE_MARK_BYTES)
+#   if defined(THREADS) && defined(PARALLEL_MARK)
+#     define USE_MARK_BYTES
+#   else
+#     define USE_MARK_BITS
+#   endif
+# endif
+
+# if defined(MSWINCE)
+#   define NO_GETENV
+# endif
+
+# if defined(SPARC)
+#   define ASM_CLEAR_CODE	/* Stack clearing is crucial, and we 	*/
+				/* include assembly code to do it well.	*/
+# endif
+
+  /* Can we save call chain in objects for debugging?   	        */
+  /* SET NFRAMES (# of saved frames) and NARGS (#of args for each 	*/
+  /* frame) to reasonable values for the platform.			*/
+  /* Set SAVE_CALL_CHAIN if we can.  SAVE_CALL_COUNT can be specified 	*/
+  /* at build time, though we feel free to adjust it slightly.		*/
+  /* Define NEED_CALLINFO if we either save the call stack or 		*/
+  /* GC_ADD_CALLER is defined.						*/
+  /* GC_CAN_SAVE_CALL_STACKS is set in gc.h.				*/
+
+#if defined(SPARC)
+# define CAN_SAVE_CALL_ARGS
+#endif
+#if (defined(I386) || defined(X86_64)) && (defined(LINUX) || defined(__GLIBC__))
+	    /* SAVE_CALL_CHAIN is supported if the code is compiled to save	*/
+	    /* frame pointers by default, i.e. no -fomit-frame-pointer flag.	*/
+# define CAN_SAVE_CALL_ARGS
+#endif
+
+# if defined(SAVE_CALL_COUNT) && !defined(GC_ADD_CALLER) \
+	     && defined(GC_CAN_SAVE_CALL_STACKS)
+#   define SAVE_CALL_CHAIN 
+# endif
+# ifdef SAVE_CALL_CHAIN
+#   if defined(SAVE_CALL_NARGS) && defined(CAN_SAVE_CALL_ARGS)
+#     define NARGS SAVE_CALL_NARGS
+#   else
+#     define NARGS 0	/* Number of arguments to save for each call.	*/
+#   endif
+# endif
+# ifdef SAVE_CALL_CHAIN
+#   ifndef SAVE_CALL_COUNT
+#     define NFRAMES 6	/* Number of frames to save. Even for		*/
+			/* alignment reasons.				*/
+#   else
+#     define NFRAMES ((SAVE_CALL_COUNT + 1) & ~1)
+#   endif
+#   define NEED_CALLINFO
+# endif /* SAVE_CALL_CHAIN */
+# ifdef GC_ADD_CALLER
+#   define NFRAMES 1
+#   define NARGS 0
+#   define NEED_CALLINFO
+# endif
+
+# if defined(MAKE_BACK_GRAPH) && !defined(DBG_HDRS_ALL)
+#   define DBG_HDRS_ALL
+# endif
+
+# if defined(POINTER_MASK) && !defined(POINTER_SHIFT)
+#   define POINTER_SHIFT 0
+# endif
+
+# if defined(POINTER_SHIFT) && !defined(POINTER_MASK)
+#   define POINTER_MASK ((GC_word)(-1))
+# endif
+
+# if !defined(FIXUP_POINTER) && defined(POINTER_MASK)
+#   define FIXUP_POINTER(p) (p) = ((p) & (POINTER_MASK) << POINTER_SHIFT)
+# endif
+
+# if defined(FIXUP_POINTER)
+#   define NEED_FIXUP_POINTER 1
+# else
+#   define NEED_FIXUP_POINTER 0
+#   define FIXUP_POINTER(p)
+# endif
+
+# if !defined(MARK_BIT_PER_GRANULE) && !defined(MARK_BIT_PER_OBJ)
+#   define MARK_BIT_PER_GRANULE	/* Usually faster */
+# endif
+
+/* Some static sanity tests.	*/
+# if defined(MARK_BIT_PER_GRANULE) && defined(MARK_BIT_PER_OBJ)
+#   error Define only one of MARK_BIT_PER_GRANULE and MARK_BIT_PER_OBJ.
+# endif
+
+# if defined(STACK_GROWS_UP) && defined(STACK_GROWS_DOWN)
+#   error "Only one of STACK_GROWS_UP and STACK_GROWS_DOWN should be defd."
+# endif
+# if !defined(STACK_GROWS_UP) && !defined(STACK_GROWS_DOWN)
+#   error "One of STACK_GROWS_UP and STACK_GROWS_DOWN should be defd."
+# endif
+
+# if defined(REDIRECT_MALLOC) && defined(THREADS) && !defined(LINUX)
+#   error "REDIRECT_MALLOC with THREADS works at most on Linux."
+# endif
+
+#ifdef GC_PRIVATE_H
+	/* This relies on some type definitions from gc_priv.h, from	*/
+        /* where it's normally included.				*/
+	/*								*/
+	/* How to get heap memory from the OS:				*/
+	/* Note that sbrk()-like allocation is preferred, since it 	*/
+	/* usually makes it possible to merge consecutively allocated	*/
+	/* chunks.  It also avoids unintented recursion with		*/
+	/* -DREDIRECT_MALLOC.						*/
+	/* GET_MEM() returns a HLKSIZE aligned chunk.			*/
+	/* 0 is taken to mean failure. 					*/
+	/* In the case os USE_MMAP, the argument must also be a 	*/
+	/* physical page size.						*/
+	/* GET_MEM is currently not assumed to retrieve 0 filled space, */
+	/* though we should perhaps take advantage of the case in which */
+	/* does.							*/
+	struct hblk;	/* See gc_priv.h.	*/
+# if defined(PCR)
+    char * real_malloc();
+#   define GET_MEM(bytes) HBLKPTR(real_malloc((size_t)bytes + GC_page_size) \
+					  + GC_page_size-1)
+# elif defined(OS2)
+    void * os2_alloc(size_t bytes);
+#   define GET_MEM(bytes) HBLKPTR((ptr_t)os2_alloc((size_t)bytes \
+					    + GC_page_size) \
+					    + GC_page_size-1)
+# elif defined(NEXT) || defined(DOS4GW) || defined(NONSTOP) || \
+		 (defined(AMIGA) && !defined(GC_AMIGA_FASTALLOC)) || \
+		 (defined(SOLARIS) && !defined(USE_MMAP))
+#   define GET_MEM(bytes) HBLKPTR((size_t) calloc(1, (size_t)bytes + GC_page_size) \
+					             + GC_page_size-1)
+# elif defined(MSWIN32)
+    extern ptr_t GC_win32_get_mem();
+#   define GET_MEM(bytes) (struct hblk *)GC_win32_get_mem(bytes)
+# elif defined(MACOS)
+#   if defined(USE_TEMPORARY_MEMORY)
+      extern Ptr GC_MacTemporaryNewPtr(size_t size, Boolean clearMemory);
+#     define GET_MEM(bytes) HBLKPTR( \
+			    GC_MacTemporaryNewPtr(bytes + GC_page_size, true) \
+			    + GC_page_size-1)
+#   else
+#     define GET_MEM(bytes) HBLKPTR( \
+				NewPtrClear(bytes + GC_page_size) + GC_page_size-1)
+#   endif
+# elif defined(MSWINCE)
+    extern ptr_t GC_wince_get_mem();
+#   define GET_MEM(bytes) (struct hblk *)GC_wince_get_mem(bytes)
+# elif defined(AMIGA) && defined(GC_AMIGA_FASTALLOC)
+    extern void *GC_amiga_get_mem(size_t size);
+#   define GET_MEM(bytes) HBLKPTR((size_t) \
+			  GC_amiga_get_mem((size_t)bytes + GC_page_size) \
+			  + GC_page_size-1)
+# else
+    extern ptr_t GC_unix_get_mem();
+#   define GET_MEM(bytes) (struct hblk *)GC_unix_get_mem(bytes)
+# endif
+
+#endif /* GC_PRIVATE_H */
+
+# endif /* GCCONFIG_H */
diff -Naur gc-7.1alpha3.orig/include/private/gcconfig.h gc-7.1alpha3/include/private/gcconfig.h
--- gc-7.1alpha3.orig/include/private/gcconfig.h	2008-02-20 20:23:00.000000000 +0100
+++ gc-7.1alpha3/include/private/gcconfig.h	2008-02-21 07:08:51.000000000 +0100
@@ -1994,6 +1994,16 @@
     /* We tried ...						*/
 #endif
 
+#if defined(LINUX_STACKBOTTOM) && defined(NO_PROC_STAT) \
+    && !defined(USE_LIBC_PRIVATES)
+    /* This combination will fail, since we have no way to get	*/
+    /* the stack base.	Use HEURISTIC2 instead.			*/
+#   undef LINUX_STACKBOTTOM
+#   define HEURISTIC2
+    /* This may still fail on some architectures like IA64.	*/
+    /* We tried ...						*/
+#endif
+
 #if defined(LINUX) && defined(USE_MMAP)
     /* The kernel may do a somewhat better job merging mappings etc.	*/
     /* with anonymous mappings.						*/
diff -Naur gc-7.1alpha3.orig/include/private/gcconfig.h~ gc-7.1alpha3/include/private/gcconfig.h~
--- gc-7.1alpha3.orig/include/private/gcconfig.h~	1970-01-01 01:00:00.000000000 +0100
+++ gc-7.1alpha3/include/private/gcconfig.h~	2008-02-20 20:23:00.000000000 +0100
@@ -0,0 +1,2364 @@
+/* 
+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers
+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.
+ * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.
+ * Copyright (c) 2000-2004 Hewlett-Packard Development Company, L.P.
+ *
+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
+ *
+ * Permission is hereby granted to use or copy this program
+ * for any purpose,  provided the above notices are retained on all copies.
+ * Permission to modify the code and to distribute modified code is granted,
+ * provided the above notices are retained, and a notice that the code was
+ * modified is included with the above copyright notice.
+ */
+
+/*
+ * This header is private to the gc.  It is almost always included from
+ * gc_priv.h.  However it is possible to include it by itself if just the
+ * configuration macros are needed.  In that
+ * case, a few declarations relying on types declared in gc_priv.h will be
+ * omitted.
+ */
+ 
+#ifndef GCCONFIG_H
+
+# define GCCONFIG_H
+
+# ifndef GC_PRIVATE_H
+    /* Fake ptr_t declaration, just to avoid compilation errors.	*/
+    /* This avoids many instances if "ifndef GC_PRIVATE_H" below.	*/
+    typedef struct GC_undefined_struct * ptr_t;
+#   include <stddef.h>	/* For size_t etc. */
+# endif
+
+/* Machine dependent parameters.  Some tuning parameters can be found	*/
+/* near the top of gc_private.h.					*/
+
+/* Machine specific parts contributed by various people.  See README file. */
+
+/* First a unified test for Linux: */
+# if defined(linux) || defined(__linux__)
+#  ifndef LINUX
+#    define LINUX
+#  endif
+# endif
+
+/* And one for NetBSD: */
+# if defined(__NetBSD__)
+#    define NETBSD
+# endif
+
+/* And one for OpenBSD: */
+# if defined(__OpenBSD__)
+#    define OPENBSD
+# endif
+
+/* And one for FreeBSD: */
+# if (defined(__FreeBSD__) || defined(__DragonFly__) || \
+      defined(__FreeBSD_kernel__)) && !defined(FREEBSD)
+#    define FREEBSD
+# endif
+
+/* Determine the machine type: */
+# if defined(__arm__) || defined(__thumb__)
+#    define ARM32
+#    if !defined(LINUX) && !defined(NETBSD)
+#      define NOSYS
+#      define mach_type_known
+#    endif
+# endif
+# if defined(sun) && defined(mc68000)
+#    error SUNOS4 no longer supported
+# endif
+# if defined(hp9000s300)
+#    error M68K based HP machines no longer supported.
+# endif
+# if defined(OPENBSD) && defined(m68k)
+#    define M68K
+#    define mach_type_known
+# endif
+# if defined(OPENBSD) && defined(__sparc__)
+#    define SPARC
+#    define mach_type_known
+# endif
+# if defined(NETBSD) && (defined(m68k) || defined(__m68k__))
+#    define M68K
+#    define mach_type_known
+# endif
+# if defined(NETBSD) && defined(__powerpc__)
+#    define POWERPC
+#    define mach_type_known
+# endif
+# if defined(NETBSD) && (defined(__arm32__) || defined(__arm__))
+#    define ARM32
+#    define mach_type_known
+# endif
+# if defined(NETBSD) && defined(__sh__)
+#    define SH
+#    define mach_type_known
+# endif
+# if defined(vax)
+#    define VAX
+#    ifdef ultrix
+#	define ULTRIX
+#    else
+#	define BSD
+#    endif
+#    define mach_type_known
+# endif
+# if defined(__NetBSD__) && defined(__vax__)
+#    define VAX
+#    define mach_type_known
+# endif
+# if defined(mips) || defined(__mips) || defined(_mips)
+#    define MIPS
+#    if defined(nec_ews) || defined(_nec_ews)
+#      define EWS4800
+#    endif
+#    if !defined(LINUX) && !defined(EWS4800) && !defined(NETBSD)
+#      if defined(ultrix) || defined(__ultrix)
+#	 define ULTRIX
+#      else
+#	 define IRIX5   /* or IRIX 6.X */
+#      endif
+#    endif /* !LINUX */
+#    if defined(__NetBSD__) && defined(__MIPSEL__)
+#      undef ULTRIX
+#    endif
+#    define mach_type_known
+# endif
+# if defined(DGUX) && (defined(i386) || defined(__i386__))
+#    define I386
+#    ifndef _USING_DGUX
+#    define _USING_DGUX
+#    endif
+#    define mach_type_known
+# endif
+# if defined(sequent) && (defined(i386) || defined(__i386__))
+#    define I386
+#    define SEQUENT
+#    define mach_type_known
+# endif
+# if defined(sun) && (defined(i386) || defined(__i386__))
+#    define I386
+#    define SOLARIS
+#    define mach_type_known
+# endif
+# if defined(sun) && defined(__amd64)
+#    define X86_64
+#    define SOLARIS
+#    define mach_type_known
+# endif
+# if (defined(__OS2__) || defined(__EMX__)) && defined(__32BIT__)
+#    define I386
+#    define OS2
+#    define mach_type_known
+# endif
+# if defined(ibm032)
+#   error IBM PC/RT no longer supported.
+# endif
+# if defined(sun) && (defined(sparc) || defined(__sparc))
+#   define SPARC
+    /* Test for SunOS 5.x */
+#     include <errno.h>
+#     define SOLARIS
+#   define mach_type_known
+# endif
+# if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux) \
+     && !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__) \
+     && !defined(__DragonFly__)
+#   define SPARC
+#   define DRSNX
+#   define mach_type_known
+# endif
+# if defined(_IBMR2)
+#   define POWERPC
+#   define AIX
+#   define mach_type_known
+# endif
+# if defined(__NetBSD__) && defined(__sparc__)
+#   define SPARC
+#   define mach_type_known
+# endif
+# if defined(_M_XENIX) && defined(_M_SYSV) && defined(_M_I386)
+	/* The above test may need refinement	*/
+#   define I386
+#   if defined(_SCO_ELF)
+#     define SCO_ELF
+#   else
+#     define SCO
+#   endif
+#   define mach_type_known
+# endif
+# if defined(_AUX_SOURCE)
+#   error A/UX no longer supported
+# endif
+# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) || defined(_PA_RISC2_0) \
+     || defined(hppa) || defined(__hppa__)
+#   define HP_PA
+#   if !defined(LINUX) && !defined(HPUX)
+#     define HPUX
+#   endif
+#   define mach_type_known
+# endif
+# if defined(__ia64) && (defined(_HPUX_SOURCE) || defined(__HP_aCC))
+#   define IA64
+#   ifndef HPUX
+#     define HPUX
+#   endif
+#   define mach_type_known
+# endif
+# if defined(__BEOS__) && defined(_X86_)
+#    define I386
+#    define BEOS
+#    define mach_type_known
+# endif
+# if defined(LINUX) && (defined(i386) || defined(__i386__))
+#    define I386
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__x86_64__)
+#    define X86_64
+#    define mach_type_known
+# endif
+# if defined(LINUX) && (defined(__ia64__) || defined(__ia64))
+#    define IA64
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__arm__)
+#    define ARM32
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__cris__)
+#    ifndef CRIS
+#	define CRIS
+#    endif
+#    define mach_type_known
+# endif
+# if defined(LINUX) && (defined(powerpc) || defined(__powerpc__) || \
+		        defined(powerpc64) || defined(__powerpc64__))
+#    define POWERPC
+#    define mach_type_known
+# endif
+# if defined(FREEBSD) && (defined(powerpc) || defined(__powerpc__))
+#    define POWERPC
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__mc68000__)
+#    define M68K
+#    define mach_type_known
+# endif
+# if defined(LINUX) && (defined(sparc) || defined(__sparc__))
+#    define SPARC
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__arm__)
+#    define ARM32
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__sh__)
+#    define SH
+#    define mach_type_known
+# endif
+# if defined(LINUX) && defined(__m32r__)
+#    define M32R
+#    define mach_type_known
+# endif
+# if defined(__alpha) || defined(__alpha__)
+#   define ALPHA
+#   if !defined(LINUX) && !defined(NETBSD) && !defined(OPENBSD) && !defined(FREEBSD)
+#     define OSF1	/* a.k.a Digital Unix */
+#   endif
+#   define mach_type_known
+# endif
+# if defined(_AMIGA) && !defined(AMIGA)
+#   define AMIGA
+# endif
+# ifdef AMIGA 
+#   define M68K
+#   define mach_type_known
+# endif
+# if defined(THINK_C) || defined(__MWERKS__) && !defined(__powerc)
+#   define M68K
+#   define MACOS
+#   define mach_type_known
+# endif
+# if defined(__MWERKS__) && defined(__powerc) && !defined(__MACH__)
+#   define POWERPC
+#   define MACOS
+#   define mach_type_known
+# endif
+# if defined(macosx) || (defined(__APPLE__) && defined(__MACH__))
+#   define DARWIN
+#   if defined(__ppc__)  || defined(__ppc64__)
+#    define POWERPC
+#    define mach_type_known
+#   elif defined(__x86_64__)
+#    define X86_64
+#    define mach_type_known
+#   elif defined(__i386__)
+#    define I386
+#    define mach_type_known
+#   endif
+# endif
+# if defined(NeXT) && defined(mc68000)
+#   define M68K
+#   define NEXT
+#   define mach_type_known
+# endif
+# if defined(NeXT) && (defined(i386) || defined(__i386__))
+#   define I386
+#   define NEXT
+#   define mach_type_known
+# endif
+# if defined(__OpenBSD__) && (defined(i386) || defined(__i386__))
+#   define I386
+#   define OPENBSD
+#   define mach_type_known
+# endif
+# if defined(FREEBSD) && (defined(i386) || defined(__i386__))
+#   define I386
+#   define mach_type_known
+# endif
+# if defined(FREEBSD) && defined(__x86_64__)
+#   define X86_64
+#   define mach_type_known
+# endif
+# if defined(__NetBSD__) && (defined(i386) || defined(__i386__))
+#   define I386
+#   define mach_type_known
+# endif
+# if defined(__NetBSD__) && defined(__x86_64__)
+#    define X86_64
+#    define mach_type_known
+# endif
+# if defined(FREEBSD) && defined(__sparc__)
+#    define SPARC
+#    define mach_type_known
+# endif
+# if defined(bsdi) && (defined(i386) || defined(__i386__))
+#    define I386
+#    define BSDI
+#    define mach_type_known
+# endif
+# if !defined(mach_type_known) && defined(__386BSD__)
+#   define I386
+#   define THREE86BSD
+#   define mach_type_known
+# endif
+# if defined(_CX_UX) && defined(_M88K)
+#   define M88K
+#   define CX_UX
+#   define mach_type_known
+# endif
+# if defined(DGUX) && defined(m88k)
+#   define M88K
+    /* DGUX defined */
+#   define mach_type_known
+# endif
+# if defined(_WIN32_WCE)
+    /* SH3, SH4, MIPS already defined for corresponding architectures */
+#   if defined(SH3) || defined(SH4)
+#     define SH
+#   endif
+#   if defined(x86)
+#     define I386
+#   endif
+#   if defined(ARM)
+#     define ARM32
+#   endif
+#   define MSWINCE
+#   define mach_type_known
+# else
+#   if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \
+        || defined(_WIN32) && !defined(__CYGWIN32__) && !defined(__CYGWIN__)
+#     if defined(__LP64__) || defined(_WIN64)
+#	define X86_64
+#     else
+#       define I386
+#     endif
+#     define MSWIN32	/* or Win64 */
+#     define mach_type_known
+#   endif
+#   if defined(_MSC_VER) && defined(_M_IA64)
+#     define IA64
+#     define MSWIN32	/* Really win64, but we don't treat 64-bit 	*/
+			/* variants as a differnt platform.		*/
+#   endif
+# endif
+# if defined(__DJGPP__)
+#   define I386
+#   ifndef DJGPP
+#     define DJGPP  /* MSDOS running the DJGPP port of GCC */
+#   endif
+#   define mach_type_known
+# endif
+# if defined(__CYGWIN32__) || defined(__CYGWIN__)
+#   define I386
+#   define CYGWIN32
+#   define mach_type_known
+# endif
+# if defined(__MINGW32__)
+#   define I386
+#   define MSWIN32
+#   define mach_type_known
+# endif
+# if defined(__BORLANDC__)
+#   define I386
+#   define MSWIN32
+#   define mach_type_known
+# endif
+# if defined(_UTS) && !defined(mach_type_known)
+#   define S370
+#   define UTS4
+#   define mach_type_known
+# endif
+# if defined(__pj__)
+#   error PicoJava no longer supported
+    /* The implementation had problems, and I haven't heard of users	*/
+    /* in ages.  If you want it resurrected, let me know.		*/
+# endif
+# if defined(__embedded__) && defined(PPC)
+#   define POWERPC
+#   define NOSYS
+#   define mach_type_known
+# endif
+/* Ivan Demakov */
+# if defined(__WATCOMC__) && defined(__386__)
+#   define I386
+#   if !defined(OS2) && !defined(MSWIN32) && !defined(DOS4GW)
+#     if defined(__OS2__)
+#       define OS2
+#     else
+#       if defined(__WINDOWS_386__) || defined(__NT__)
+#         define MSWIN32
+#       else
+#         define DOS4GW
+#       endif
+#     endif
+#   endif
+#   define mach_type_known
+# endif
+# if defined(__s390__) && defined(LINUX)
+#    define S390
+#    define mach_type_known
+# endif
+# if defined(__GNU__)
+#   if defined(__i386__)
+/* The Debian Hurd running on generic PC */  
+#     define  HURD
+#     define  I386
+#     define  mach_type_known
+#    endif 
+# endif
+# if defined(__TANDEM)
+    /* Nonstop S-series */
+    /* FIXME: Should recognize Integrity series? */
+#   define MIPS
+#   define NONSTOP
+#   define mach_type_known
+# endif
+
+/* Feel free to add more clauses here */
+
+/* Or manually define the machine type here.  A machine type is 	*/
+/* characterized by the architecture.  Some				*/
+/* machine types are further subdivided by OS.				*/
+/* Macros such as LINUX, FREEBSD, etc. distinguish them.		*/
+/* SYSV on an M68K actually means A/UX.					*/
+/* The distinction in these cases is usually the stack starting address */
+# ifndef mach_type_known
+#   error "The collector has not been ported to this machine/OS combination."
+# endif
+		    /* Mapping is: M68K       ==> Motorola 680X0	*/
+		    /*		   (NEXT, and SYSV (A/UX),		*/
+		    /*		   MACOS and AMIGA variants)		*/
+		    /*             I386       ==> Intel 386	 	*/
+		    /*		    (SEQUENT, OS2, SCO, LINUX, NETBSD,	*/
+		    /*		     FREEBSD, THREE86BSD, MSWIN32,	*/
+		    /* 		     BSDI,SOLARIS, NEXT, other variants)	*/
+                    /*             NS32K      ==> Encore Multimax 	*/
+                    /*             MIPS       ==> R2000 through R14K	*/
+                    /*			(many variants)			*/
+                    /*		   VAX	      ==> DEC VAX		*/
+                    /*			(BSD, ULTRIX variants)		*/
+                    /*		   HP_PA      ==> HP9000/700 & /800	*/
+                    /*				  HP/UX, LINUX		*/
+		    /*		   SPARC      ==> SPARC	v7/v8/v9	*/
+		    /*			(SOLARIS, LINUX, DRSNX variants)	*/
+		    /* 		   ALPHA      ==> DEC Alpha 		*/
+		    /*			(OSF1 and LINUX variants)	*/
+		    /* 		   M88K       ==> Motorola 88XX0        */
+		    /* 		        (CX_UX and DGUX)		*/
+		    /* 		   S370	      ==> 370-like machine	*/
+		    /* 			running Amdahl UTS4		*/
+                    /*             S390       ==> 390-like machine      */
+		    /*                  running LINUX                   */
+		    /* 		   ARM32      ==> Intel StrongARM	*/
+		    /* 		   IA64	      ==> Intel IPF		*/
+		    /*				  (e.g. Itanium)	*/
+		    /*			(LINUX and HPUX)	        */
+		    /*		   SH	      ==> Hitachi SuperH	*/
+		    /* 			(LINUX & MSWINCE)		*/
+		    /* 		   X86_64     ==> AMD x86-64		*/
+		    /*		   POWERPC    ==> IBM/Apple PowerPC	*/
+		    /*			(MACOS(<=9),DARWIN(incl.MACOSX),*/
+		    /*			 LINUX, NETBSD, AIX, NOSYS	*/
+		    /*			 variants)			*/
+		    /*			Handles 32 and 64-bit variants.	*/
+		    /*		   CRIS       ==> Axis Etrax		*/
+		    /*		   M32R	      ==> Renesas M32R		*/
+
+
+/*
+ * For each architecture and OS, the following need to be defined:
+ *
+ * CPP_WORDSZ is a simple integer constant representing the word size.
+ * in bits.  We assume byte addressibility, where a byte has 8 bits.
+ * We also assume CPP_WORDSZ is either 32 or 64.
+ * (We care about the length of pointers, not hardware
+ * bus widths.  Thus a 64 bit processor with a C compiler that uses
+ * 32 bit pointers should use CPP_WORDSZ of 32, not 64. Default is 32.)
+ *
+ * MACH_TYPE is a string representation of the machine type.
+ * OS_TYPE is analogous for the OS.
+ *
+ * ALIGNMENT is the largest N, such that
+ * all pointer are guaranteed to be aligned on N byte boundaries.
+ * defining it to be 1 will always work, but perform poorly.
+ *
+ * DATASTART is the beginning of the data segment.
+ * On some platforms SEARCH_FOR_DATA_START is defined.
+ * SEARCH_FOR_DATASTART will cause GC_data_start to
+ * be set to an address determined by accessing data backwards from _end
+ * until an unmapped page is found.  DATASTART will be defined to be
+ * GC_data_start.
+ * On UNIX-like systems, the collector will scan the area between DATASTART
+ * and DATAEND for root pointers.
+ *
+ * DATAEND, if not `end' where `end' is defined as ``extern int end[];''.
+ * RTH suggests gaining access to linker script synth'd values with
+ * this idiom instead of `&end' where `end' is defined as ``extern int end;'' .
+ * Otherwise, ``GCC will assume these are in .sdata/.sbss'' and it will, e.g.,
+ * cause failures on alpha*-*-* with ``-msmall-data or -fpic'' or mips-*-*
+ * without any special options.
+ *
+ * STACKBOTTOM is the cool end of the stack, which is usually the
+ * highest address in the stack.
+ * Under PCR or OS/2, we have other ways of finding thread stacks.
+ * For each machine, the following should:
+ * 1) define STACK_GROWS_UP if the stack grows toward higher addresses, and
+ * 2) define exactly one of
+ *	STACKBOTTOM (should be defined to be an expression)
+ *	LINUX_STACKBOTTOM
+ *	HEURISTIC1
+ *	HEURISTIC2
+ * If STACKBOTTOM is defined, then it's value will be used directly as the
+ * stack base.  If LINUX_STACKBOTTOM is defined, then it will be determined
+ * with a method appropriate for most Linux systems.  Currently we look
+ * first for __libc_stack_end (currently only id USE_LIBC_PRIVATES is
+ * defined), and if that fails read it from /proc.  (If USE_LIBC_PRIVATES
+ * is not defined and NO_PROC_STAT is defined, we revert to HEURISTIC2.)
+ * If either of the last two macros are defined, then STACKBOTTOM is computed
+ * during collector startup using one of the following two heuristics:
+ * HEURISTIC1:  Take an address inside GC_init's frame, and round it up to
+ *		the next multiple of STACK_GRAN.
+ * HEURISTIC2:  Take an address inside GC_init's frame, increment it repeatedly
+ *		in small steps (decrement if STACK_GROWS_UP), and read the value
+ *		at each location.  Remember the value when the first
+ *		Segmentation violation or Bus error is signalled.  Round that
+ *		to the nearest plausible page boundary, and use that instead
+ *		of STACKBOTTOM.
+ *
+ * Gustavo Rodriguez-Rivera points out that on most (all?) Unix machines,
+ * the value of environ is a pointer that can serve as STACKBOTTOM.
+ * I expect that HEURISTIC2 can be replaced by this approach, which
+ * interferes far less with debugging.  However it has the disadvantage
+ * that it's confused by a putenv call before the collector is initialized.
+ * This could be dealt with by intercepting putenv ...
+ *
+ * If no expression for STACKBOTTOM can be found, and neither of the above
+ * heuristics are usable, the collector can still be used with all of the above
+ * undefined, provided one of the following is done:
+ * 1) GC_mark_roots can be changed to somehow mark from the correct stack(s)
+ *    without reference to STACKBOTTOM.  This is appropriate for use in
+ *    conjunction with thread packages, since there will be multiple stacks.
+ *    (Allocating thread stacks in the heap, and treating them as ordinary
+ *    heap data objects is also possible as a last resort.  However, this is
+ *    likely to introduce significant amounts of excess storage retention
+ *    unless the dead parts of the thread stacks are periodically cleared.)
+ * 2) Client code may set GC_stackbottom before calling any GC_ routines.
+ *    If the author of the client code controls the main program, this is
+ *    easily accomplished by introducing a new main program, setting
+ *    GC_stackbottom to the address of a local variable, and then calling
+ *    the original main program.  The new main program would read something
+ *    like:
+ *
+ *		# include "gc_private.h"
+ *
+ *		main(argc, argv, envp)
+ *		int argc;
+ *		char **argv, **envp;
+ *		{
+ *		    int dummy;
+ *
+ *		    GC_stackbottom = (ptr_t)(&dummy);
+ *		    return(real_main(argc, argv, envp));
+ *		}
+ *
+ *
+ * Each architecture may also define the style of virtual dirty bit
+ * implementation to be used:
+ *   MPROTECT_VDB: Write protect the heap and catch faults.
+ *   GWW_VDB: Use win32 GetWriteWatch primitive.
+ *   PROC_VDB: Use the SVR4 /proc primitives to read dirty bits.
+ *
+ * The first and second one may be combined, in which case a runtime
+ * selection will be made, based on GetWriteWatch availability.
+ *
+ * An architecture may define DYNAMIC_LOADING if dynamic_load.c
+ * defined GC_register_dynamic_libraries() for the architecture.
+ *
+ * An architecture may define PREFETCH(x) to preload the cache with *x.
+ * This defaults to a no-op.
+ *
+ * PREFETCH_FOR_WRITE(x) is used if *x is about to be written.
+ *
+ * An architecture may also define CLEAR_DOUBLE(x) to be a fast way to
+ * clear the two words at GC_malloc-aligned address x.  By default,
+ * word stores of 0 are used instead.
+ *
+ * HEAP_START may be defined as the initial address hint for mmap-based
+ * allocation.
+ */
+
+/* If we are using a recent version of gcc, we can use __builtin_unwind_init()
+ * to push the relevant registers onto the stack.
+ */
+# if defined(__GNUC__) && ((__GNUC__ >= 3) || \
+			   (__GNUC__ == 2 && __GNUC_MINOR__ >= 8)) \
+		       && !defined(__INTEL_COMPILER) && !defined(__PATHCC__)
+#   define HAVE_BUILTIN_UNWIND_INIT
+# endif
+
+# define STACK_GRAN 0x1000000
+# ifdef M68K
+#   define MACH_TYPE "M68K"
+#   define ALIGNMENT 2
+#   ifdef OPENBSD
+#	define OS_TYPE "OPENBSD"
+#	define HEURISTIC2
+#	ifdef __ELF__
+#	  define DATASTART GC_data_start
+#	  define DYNAMIC_LOADING
+#	else
+	  extern char etext[];
+#	  define DATASTART ((ptr_t)(etext))
+#       endif
+#   endif
+#   ifdef NETBSD
+#	define OS_TYPE "NETBSD"
+#	define HEURISTIC2
+#	ifdef __ELF__
+#	  define DATASTART GC_data_start
+#	  define DYNAMIC_LOADING
+#	else
+	  extern char etext[];
+#	  define DATASTART ((ptr_t)(etext))
+#       endif
+#   endif
+#   ifdef LINUX
+#       define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#       define MPROTECT_VDB
+#       ifdef __ELF__
+#            define DYNAMIC_LOADING
+#	     include <features.h>
+#	     if defined(__GLIBC__)&& __GLIBC__>=2
+#              define SEARCH_FOR_DATA_START
+#	     else /* !GLIBC2 */
+               extern char **__environ;
+#              define DATASTART ((ptr_t)(&__environ))
+                             /* hideous kludge: __environ is the first */
+                             /* word in crt0.o, and delimits the start */
+                             /* of the data segment, no matter which   */
+                             /* ld options were passed through.        */
+                             /* We could use _etext instead, but that  */
+                             /* would include .rodata, which may       */
+                             /* contain large read-only data tables    */
+                             /* that we'd rather not scan.             */
+#	     endif /* !GLIBC2 */
+             extern int _end[];
+#            define DATAEND (_end)
+#       else
+             extern int etext[];
+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#       endif
+#   endif
+#   ifdef AMIGA
+#	define OS_TYPE "AMIGA"
+ 	    	/* STACKBOTTOM and DATASTART handled specially	*/
+ 	    	/* in os_dep.c					*/
+# 	define DATAEND	/* not needed */
+#	define GETPAGESIZE() 4096
+#   endif
+#   ifdef MACOS
+#     ifndef __LOWMEM__
+#     include <LowMem.h>
+#     endif
+#     define OS_TYPE "MACOS"
+			/* see os_dep.c for details of global data segments. */
+#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())
+#     define DATAEND	/* not needed */
+#     define GETPAGESIZE() 4096
+#   endif
+#   ifdef NEXT
+#	define OS_TYPE "NEXT"
+#	define DATASTART ((ptr_t) get_etext())
+#	define STACKBOTTOM ((ptr_t) 0x4000000)
+#	define DATAEND	/* not needed */
+#   endif
+# endif
+
+# if defined(POWERPC)
+#   define MACH_TYPE "POWERPC"
+#   ifdef MACOS
+#     define ALIGNMENT 2  /* Still necessary?  Could it be 4?	*/
+#     ifndef __LOWMEM__
+#     include <LowMem.h>
+#     endif
+#     define OS_TYPE "MACOS"
+			/* see os_dep.c for details of global data segments. */
+#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())
+#     define DATAEND  /* not needed */
+#   endif
+#   ifdef LINUX
+#     if defined(__powerpc64__)
+#       define ALIGNMENT 8
+#       define CPP_WORDSZ 64
+#       ifndef HBLKSIZE
+#         define HBLKSIZE 4096
+#       endif
+#     else
+#       define ALIGNMENT 4
+#     endif
+#     define OS_TYPE "LINUX"
+      /* HEURISTIC1 has been reliably reported to fail for a 32-bit	*/
+      /* executable on a 64 bit kernel.					*/
+#     define LINUX_STACKBOTTOM
+#     define DYNAMIC_LOADING
+#     define SEARCH_FOR_DATA_START
+      extern int _end[];
+#     define DATAEND (_end)
+#   endif
+#   ifdef DARWIN
+#     define OS_TYPE "DARWIN"
+#     define DYNAMIC_LOADING
+#     if defined(__ppc64__)
+#       define ALIGNMENT 8
+#       define CPP_WORDSZ 64
+#       define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)
+#       define CACHE_LINE_SIZE 64
+#       ifndef HBLKSIZE
+#         define HBLKSIZE 4096
+#       endif
+#     else
+#       define ALIGNMENT 4
+#       define STACKBOTTOM ((ptr_t) 0xc0000000)
+#     endif
+      /* XXX: see get_end(3), get_etext() and get_end() should not be used.
+	 These aren't used when dyld support is enabled (it is by default) */
+#     define DATASTART ((ptr_t) get_etext())
+#     define DATAEND	((ptr_t) get_end())
+#     define USE_MMAP
+#     define USE_MMAP_ANON
+#     ifdef GC_DARWIN_THREADS
+#       define MPROTECT_VDB
+#     endif
+#     include <unistd.h>
+#     define GETPAGESIZE() getpagesize()
+#     if defined(USE_PPC_PREFETCH) && defined(__GNUC__)
+	/* The performance impact of prefetches is untested */
+#	define PREFETCH(x) \
+	  __asm__ __volatile__ ("dcbt 0,%0" : : "r" ((const void *) (x)))
+#	define PREFETCH_FOR_WRITE(x) \
+	  __asm__ __volatile__ ("dcbtst 0,%0" : : "r" ((const void *) (x)))
+#     endif
+      /* There seems to be some issues with trylock hanging on darwin. This
+	 should be looked into some more */
+#     define NO_PTHREAD_TRYLOCK
+#   endif
+#   ifdef FREEBSD
+#       define ALIGNMENT 4
+#       define OS_TYPE "FREEBSD"
+#       ifndef GC_FREEBSD_THREADS
+#           define MPROTECT_VDB
+#       endif
+#       define SIG_SUSPEND SIGUSR1
+#       define SIG_THR_RESTART SIGUSR2
+#       define FREEBSD_STACKBOTTOM
+#       ifdef __ELF__
+#           define DYNAMIC_LOADING
+#       endif
+        extern char etext[];
+        extern char * GC_FreeBSDGetDataStart();
+#       define DATASTART GC_FreeBSDGetDataStart(0x1000, &etext)
+#   endif
+#   ifdef NETBSD
+#     define ALIGNMENT 4
+#     define OS_TYPE "NETBSD"
+#     define HEURISTIC2
+      extern char etext[];
+#     define DATASTART GC_data_start
+#     define DYNAMIC_LOADING
+#   endif
+#   ifdef AIX
+#     define OS_TYPE "AIX"
+#     undef ALIGNMENT /* in case it's defined	*/
+#     ifdef IA64
+#       undef IA64
+          /* DOB: some AIX installs stupidly define IA64 in */
+          /* /usr/include/sys/systemcfg.h   		    */
+#     endif
+#     ifdef __64BIT__
+#       define ALIGNMENT 8
+#       define CPP_WORDSZ 64
+#       define STACKBOTTOM ((ptr_t)0x1000000000000000)
+#     else
+#       define ALIGNMENT 4
+#       define CPP_WORDSZ 32
+#       define STACKBOTTOM ((ptr_t)((ulong)&errno))
+#     endif
+#     define USE_MMAP
+#     define USE_MMAP_ANON
+	/* From AIX linker man page:
+	_text Specifies the first location of the program.
+	_etext Specifies the first location after the program.
+	_data Specifies the first location of the data.
+	_edata Specifies the first location after the initialized data
+	_end or end Specifies the first location after all data.
+	*/
+      extern int _data[], _end[];
+#     define DATASTART ((ptr_t)((ulong)_data))
+#     define DATAEND ((ptr_t)((ulong)_end))
+      extern int errno;
+#     define DYNAMIC_LOADING
+	/* For really old versions of AIX, this may have to be removed. */
+#   endif
+
+#   ifdef NOSYS
+#     define ALIGNMENT 4
+#     define OS_TYPE "NOSYS"
+      extern void __end[], __dso_handle[];
+#     define DATASTART (__dso_handle)  /* OK, that's ugly.  */
+#     define DATAEND (__end)
+	/* Stack starts at 0xE0000000 for the simulator.  */
+#     undef STACK_GRAN
+#     define STACK_GRAN 0x10000000
+#     define HEURISTIC1
+#   endif
+# endif
+
+# ifdef VAX
+#   define MACH_TYPE "VAX"
+#   define ALIGNMENT 4	/* Pointers are longword aligned by 4.2 C compiler */
+    extern char etext[];
+#   define DATASTART ((ptr_t)(etext))
+#   ifdef BSD
+#	define OS_TYPE "BSD"
+#	define HEURISTIC1
+			/* HEURISTIC2 may be OK, but it's hard to test. */
+#   endif
+#   ifdef ULTRIX
+#	define OS_TYPE "ULTRIX"
+#	define STACKBOTTOM ((ptr_t) 0x7fffc800)
+#   endif
+# endif
+
+# ifdef SPARC
+#   define MACH_TYPE "SPARC"
+#   if defined(__arch64__) || defined(__sparcv9)
+#     define ALIGNMENT 8
+#     define CPP_WORDSZ 64
+#     define ELF_CLASS ELFCLASS64
+#   else
+#     define ALIGNMENT 4	/* Required by hardware	*/
+#     define CPP_WORDSZ 32
+#   endif
+    /* Don't define USE_ASM_PUSH_REGS.  We do use an asm helper, but	*/
+    /* not to push the registers on the mark stack.			*/
+#   ifdef SOLARIS
+#	define OS_TYPE "SOLARIS"
+	extern int _etext[];
+	extern int _end[];
+	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_SysVGetDataStart(0x10000, (ptr_t)_etext)
+#	define DATAEND (_end)
+#	if !defined(USE_MMAP) && defined(REDIRECT_MALLOC)
+#	    define USE_MMAP
+	    /* Otherwise we now use calloc.  Mmap may result in the	*/
+	    /* heap interleaved with thread stacks, which can result in	*/
+	    /* excessive blacklisting.  Sbrk is unusable since it	*/
+	    /* doesn't interact correctly with the system malloc.	*/
+#	endif
+#       ifdef USE_MMAP
+#         define HEAP_START (ptr_t)0x40000000
+#       else
+#	  define HEAP_START DATAEND
+#       endif
+#	define PROC_VDB
+/*	HEURISTIC1 reportedly no longer works under 2.7.  		*/
+/*  	HEURISTIC2 probably works, but this appears to be preferable.	*/
+/*	Apparently USRSTACK is defined to be USERLIMIT, but in some	*/
+/* 	installations that's undefined.  We work around this with a	*/
+/*	gross hack:							*/
+#       include <sys/vmparam.h>
+#	ifdef USERLIMIT
+	  /* This should work everywhere, but doesn't.	*/
+#	  define STACKBOTTOM USRSTACK
+#       else
+#	  define HEURISTIC2
+#       endif
+#	include <unistd.h>
+#       define GETPAGESIZE()  sysconf(_SC_PAGESIZE)
+		/* getpagesize() appeared to be missing from at least one */
+		/* Solaris 5.4 installation.  Weird.			  */
+#	define DYNAMIC_LOADING
+#   endif
+#   ifdef DRSNX
+#	define OS_TYPE "DRSNX"
+	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+	extern int etext[];
+#       define DATASTART GC_SysVGetDataStart(0x10000, (ptr_t)etext)
+#	define MPROTECT_VDB
+#       define STACKBOTTOM ((ptr_t) 0xdfff0000)
+#	define DYNAMIC_LOADING
+#   endif
+#   ifdef LINUX
+#     define OS_TYPE "LINUX"
+#     ifdef __ELF__
+#       define DYNAMIC_LOADING
+#     else
+          Linux Sparc/a.out not supported
+#     endif
+      extern int _end[];
+      extern int _etext[];
+#     define DATAEND (_end)
+#     define SVR4
+      extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#     ifdef __arch64__
+#	define DATASTART GC_SysVGetDataStart(0x100000, (ptr_t)_etext)
+#     else
+#       define DATASTART GC_SysVGetDataStart(0x10000, (ptr_t)_etext)
+#     endif
+#     define LINUX_STACKBOTTOM
+#   endif
+#   ifdef OPENBSD
+#     define OS_TYPE "OPENBSD"
+#     define STACKBOTTOM ((ptr_t) 0xf8000000)
+      extern int etext[];
+#     define DATASTART ((ptr_t)(etext))
+#   endif
+#   ifdef NETBSD
+#     define OS_TYPE "NETBSD"
+#     define HEURISTIC2
+#     ifdef __ELF__
+#	define DATASTART GC_data_start
+#	define DYNAMIC_LOADING
+#     else
+	extern char etext[];
+#	define DATASTART ((ptr_t)(etext))
+#     endif
+#   endif
+#   ifdef FREEBSD
+#	define OS_TYPE "FREEBSD"
+#	define SIG_SUSPEND SIGUSR1
+#	define SIG_THR_RESTART SIGUSR2
+#	define FREEBSD_STACKBOTTOM
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+	extern char etext[];
+	extern char edata[];
+	extern char end[];
+#	define NEED_FIND_LIMIT
+#	define DATASTART ((ptr_t)(&etext))
+#	define DATAEND (GC_find_limit (DATASTART, TRUE))
+#	define DATASTART2 ((ptr_t)(&edata))
+#	define DATAEND2 ((ptr_t)(&end))
+#   endif
+# endif
+
+# ifdef I386
+#   define MACH_TYPE "I386"
+#   if defined(__LP64__) || defined(_WIN64)
+#     error This should be handled as X86_64
+#   else
+#     define CPP_WORDSZ 32
+#     define ALIGNMENT 4
+			/* Appears to hold for all "32 bit" compilers	*/
+			/* except Borland.  The -a4 option fixes 	*/
+			/* Borland.					*/
+                        /* Ivan Demakov: For Watcom the option is -zp4. */
+#   endif
+#   ifdef SEQUENT
+#	define OS_TYPE "SEQUENT"
+	extern int etext[];
+#       define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#       define STACKBOTTOM ((ptr_t) 0x3ffff000) 
+#   endif
+#   ifdef BEOS
+#     define OS_TYPE "BEOS"
+#     include <OS.h>
+#     define GETPAGESIZE() B_PAGE_SIZE
+      extern int etext[];
+#     define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#   endif
+#   ifdef SOLARIS
+#	define OS_TYPE "SOLARIS"
+        extern int _etext[], _end[];
+  	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_SysVGetDataStart(0x1000, (ptr_t)_etext)
+#	define DATAEND (_end)
+/*	# define STACKBOTTOM ((ptr_t)(_start)) worked through 2.7,  	*/
+/*      but reportedly breaks under 2.8.  It appears that the stack	*/
+/* 	base is a property of the executable, so this should not break	*/
+/* 	old executables.						*/
+/*  	HEURISTIC2 probably works, but this appears to be preferable.	*/
+#       include <sys/vm.h>
+#	define STACKBOTTOM USRSTACK
+/* At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */
+/* It appears to be fixed in 2.8 and 2.9.				*/
+#	ifdef SOLARIS25_PROC_VDB_BUG_FIXED
+#	  define PROC_VDB
+#	endif
+#	define DYNAMIC_LOADING
+#	if !defined(USE_MMAP) && defined(REDIRECT_MALLOC)
+#	    define USE_MMAP
+	    /* Otherwise we now use calloc.  Mmap may result in the	*/
+	    /* heap interleaved with thread stacks, which can result in	*/
+	    /* excessive blacklisting.  Sbrk is unusable since it	*/
+	    /* doesn't interact correctly with the system malloc.	*/
+#	endif
+#       ifdef USE_MMAP
+#         define HEAP_START (ptr_t)0x40000000
+#       else
+#	  define HEAP_START DATAEND
+#       endif
+#   endif
+#   ifdef SCO
+#	define OS_TYPE "SCO"
+	extern int etext[];
+#   	define DATASTART ((ptr_t)((((word) (etext)) + 0x3fffff) \
+				  & ~0x3fffff) \
+				 +((word)etext & 0xfff))
+#	define STACKBOTTOM ((ptr_t) 0x7ffffffc)
+#   endif
+#   ifdef SCO_ELF
+#       define OS_TYPE "SCO_ELF"
+        extern int etext[];
+#       define DATASTART ((ptr_t)(etext))
+#       define STACKBOTTOM ((ptr_t) 0x08048000)
+#       define DYNAMIC_LOADING
+#	define ELF_CLASS ELFCLASS32
+#   endif
+#   ifdef DGUX
+#	define OS_TYPE "DGUX"
+	extern int _etext, _end;
+	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#	define DATASTART GC_SysVGetDataStart(0x1000, (ptr_t)(&_etext))
+#	define DATAEND (&_end)
+#	define STACK_GROWS_DOWN
+#	define HEURISTIC2
+#	include <unistd.h>
+#	define GETPAGESIZE()  sysconf(_SC_PAGESIZE)
+#	define DYNAMIC_LOADING
+#	ifndef USE_MMAP
+#	  define USE_MMAP
+#	endif /* USE_MMAP */
+#	define MAP_FAILED (void *) -1
+#	ifdef USE_MMAP
+#	  define HEAP_START (ptr_t)0x40000000
+#	else /* USE_MMAP */
+#	  define HEAP_START DATAEND
+#	endif /* USE_MMAP */
+#   endif /* DGUX */
+
+#   ifdef LINUX
+#	define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#	if 0
+#	  define HEURISTIC1
+#         undef STACK_GRAN
+#         define STACK_GRAN 0x10000000
+	  /* STACKBOTTOM is usually 0xc0000000, but this changes with	*/
+	  /* different kernel configurations.  In particular, systems	*/
+	  /* with 2GB physical memory will usually move the user	*/
+	  /* address space limit, and hence initial SP to 0x80000000.	*/
+#       endif
+#       if !defined(GC_LINUX_THREADS) || !defined(REDIRECT_MALLOC)
+#	    define MPROTECT_VDB
+#	else
+	    /* We seem to get random errors in incremental mode,	*/
+	    /* possibly because Linux threads is itself a malloc client */
+	    /* and can't deal with the signals.				*/
+#	endif
+#	define HEAP_START (ptr_t)0x1000
+		/* This encourages mmap to give us low addresses,	*/
+		/* thus allowing the heap to grow to ~3GB		*/
+#       ifdef __ELF__
+#            define DYNAMIC_LOADING
+#	     ifdef UNDEFINED	/* includes ro data */
+	       extern int _etext[];
+#              define DATASTART ((ptr_t)((((word) (_etext)) + 0xfff) & ~0xfff))
+#	     endif
+#	     include <features.h>
+#	     if defined(__GLIBC__) && __GLIBC__ >= 2
+#		 define SEARCH_FOR_DATA_START
+#	     else
+     	         extern char **__environ;
+#                define DATASTART ((ptr_t)(&__environ))
+			      /* hideous kludge: __environ is the first */
+			      /* word in crt0.o, and delimits the start */
+			      /* of the data segment, no matter which   */
+			      /* ld options were passed through.        */
+			      /* We could use _etext instead, but that  */
+			      /* would include .rodata, which may       */
+			      /* contain large read-only data tables    */
+			      /* that we'd rather not scan.		*/
+#	     endif
+	     extern int _end[];
+#	     define DATAEND (_end)
+#	else
+	     extern int etext[];
+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#       endif
+#	ifdef USE_I686_PREFETCH
+	  /* FIXME: Thus should use __builtin_prefetch, but we'll leave that	*/
+	  /* for the next rtelease.						*/
+#	  define PREFETCH(x) \
+	    __asm__ __volatile__ ("	prefetchnta	%0": : "m"(*(char *)(x)))
+	    /* Empirically prefetcht0 is much more effective at reducing	*/
+	    /* cache miss stalls for the targetted load instructions.  But it	*/
+	    /* seems to interfere enough with other cache traffic that the net	*/
+	    /* result is worse than prefetchnta.				*/
+#         if 0 
+	    /* Using prefetches for write seems to have a slight negative	*/
+	    /* impact on performance, at least for a PIII/500.			*/
+#	    define PREFETCH_FOR_WRITE(x) \
+	      __asm__ __volatile__ ("	prefetcht0	%0": : "m"(*(char *)(x)))
+#	  endif
+#	endif
+#	ifdef USE_3DNOW_PREFETCH
+#	  define PREFETCH(x) \
+	    __asm__ __volatile__ ("	prefetch	%0": : "m"(*(char *)(x)))
+#	  define PREFETCH_FOR_WRITE(x) \
+	    __asm__ __volatile__ ("	prefetchw	%0": : "m"(*(char *)(x)))
+#	endif
+#   endif
+#   ifdef CYGWIN32
+#       define OS_TYPE "CYGWIN32"
+#       define DATASTART ((ptr_t)GC_DATASTART)  /* From gc.h */
+#       define DATAEND	 ((ptr_t)GC_DATAEND)
+#	undef STACK_GRAN
+#       define STACK_GRAN 0x10000
+#       define HEURISTIC1
+#   endif
+#   ifdef OS2
+#	define OS_TYPE "OS2"
+ 	    	/* STACKBOTTOM and DATASTART are handled specially in 	*/
+		/* os_dep.c. OS2 actually has the right			*/
+		/* system call!						*/
+#	define DATAEND	/* not needed */
+#   endif
+#   ifdef MSWIN32
+#	define OS_TYPE "MSWIN32"
+		/* STACKBOTTOM and DATASTART are handled specially in 	*/
+		/* os_dep.c.						*/
+#       if !defined(__WATCOMC__)
+#	  define MPROTECT_VDB
+	  /* We also avoided doing this in the past with GC_WIN32_THREADS */
+	  /* Hopefully that's fixed.					  */
+#	endif
+#	if _MSC_VER >= 1300  /* .NET, i.e. > VisualStudio 6	*/
+#         define GWW_VDB
+#	endif
+#       define DATAEND  /* not needed */
+#   endif
+#   ifdef MSWINCE
+#	define OS_TYPE "MSWINCE"
+#       define DATAEND  /* not needed */
+#   endif
+#   ifdef DJGPP
+#       define OS_TYPE "DJGPP"
+#       include "stubinfo.h"
+        extern int etext[];
+        extern int _stklen;
+        extern int __djgpp_stack_limit;
+#       define DATASTART ((ptr_t)((((word) (etext)) + 0x1ff) & ~0x1ff))
+/* #       define STACKBOTTOM ((ptr_t)((word) _stubinfo + _stubinfo->size \
+                                                     + _stklen)) */
+#       define STACKBOTTOM ((ptr_t)((word) __djgpp_stack_limit + _stklen))
+		/* This may not be right.  */
+#   endif
+#   ifdef OPENBSD
+#	define OS_TYPE "OPENBSD"
+#   endif
+#   ifdef FREEBSD
+#	define OS_TYPE "FREEBSD"
+#	ifndef GC_FREEBSD_THREADS
+#	    define MPROTECT_VDB
+#	endif
+#	ifdef __GLIBC__
+#	    define SIG_SUSPEND		(32+6)
+#	    define SIG_THR_RESTART	(32+5)
+	    extern int _end[];
+#	    define DATAEND (_end)
+#	else
+#	    define SIG_SUSPEND SIGUSR1
+#	    define SIG_THR_RESTART SIGUSR2
+#	endif
+#	define FREEBSD_STACKBOTTOM
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+	extern char etext[];
+	extern char * GC_FreeBSDGetDataStart(size_t, ptr_t);
+#	define DATASTART GC_FreeBSDGetDataStart(0x1000, (ptr_t)etext)
+#   endif
+#   ifdef NETBSD
+#	define OS_TYPE "NETBSD"
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+#   endif
+#   ifdef THREE86BSD
+#	define OS_TYPE "THREE86BSD"
+#   endif
+#   ifdef BSDI
+#	define OS_TYPE "BSDI"
+#   endif
+#   if defined(OPENBSD) || defined(NETBSD) \
+        || defined(THREE86BSD) || defined(BSDI)
+#	define HEURISTIC2
+	extern char etext[];
+#	define DATASTART ((ptr_t)(etext))
+#   endif
+#   ifdef NEXT
+#	define OS_TYPE "NEXT"
+#	define DATASTART ((ptr_t) get_etext())
+#	define STACKBOTTOM ((ptr_t)0xc0000000)
+#	define DATAEND	/* not needed */
+#   endif
+#   ifdef DOS4GW
+#     define OS_TYPE "DOS4GW"
+      extern long __nullarea;
+      extern char _end;
+      extern char *_STACKTOP;
+      /* Depending on calling conventions Watcom C either precedes
+         or does not precedes with undescore names of C-variables.
+         Make sure startup code variables always have the same names.  */
+      #pragma aux __nullarea "*";
+      #pragma aux _end "*";
+#     define STACKBOTTOM ((ptr_t) _STACKTOP)
+                         /* confused? me too. */
+#     define DATASTART ((ptr_t) &__nullarea)
+#     define DATAEND ((ptr_t) &_end)
+#   endif
+#   ifdef HURD
+#     define OS_TYPE "HURD"
+#     define STACK_GROWS_DOWN
+#     define HEURISTIC2
+#     define SIG_SUSPEND SIGUSR1
+#     define SIG_THR_RESTART SIGUSR2
+#     define SEARCH_FOR_DATA_START
+      extern int _end[];
+#     define DATAEND ((ptr_t) (_end))
+/* #     define MPROTECT_VDB  Not quite working yet? */
+#     define DYNAMIC_LOADING
+#   endif
+#   ifdef DARWIN
+#     define OS_TYPE "DARWIN"
+#     define DARWIN_DONT_PARSE_STACK
+#     define DYNAMIC_LOADING
+      /* XXX: see get_end(3), get_etext() and get_end() should not be used.
+	 These aren't used when dyld support is enabled (it is by default) */
+#     define DATASTART ((ptr_t) get_etext())
+#     define DATAEND	((ptr_t) get_end())
+#     define STACKBOTTOM ((ptr_t) 0xc0000000)
+#     define USE_MMAP
+#     define USE_MMAP_ANON
+#     ifdef GC_DARWIN_THREADS
+#       define MPROTECT_VDB
+#     endif
+#     include <unistd.h>
+#     define GETPAGESIZE() getpagesize()
+      /* There seems to be some issues with trylock hanging on darwin. This
+	 should be looked into some more */
+#      define NO_PTHREAD_TRYLOCK
+#   endif /* DARWIN */
+# endif
+
+# ifdef NS32K
+#   define MACH_TYPE "NS32K"
+#   define ALIGNMENT 4
+    extern char **environ;
+#   define DATASTART ((ptr_t)(&environ))
+			      /* hideous kludge: environ is the first   */
+			      /* word in crt0.o, and delimits the start */
+			      /* of the data segment, no matter which   */
+			      /* ld options were passed through.        */
+#   define STACKBOTTOM ((ptr_t) 0xfffff000) /* for Encore */
+# endif
+
+# ifdef MIPS
+#   define MACH_TYPE "MIPS"
+#   ifdef LINUX
+      /* This was developed for a linuxce style platform.  Probably	*/
+      /* needs to be tweaked for workstation class machines.		*/
+#     define OS_TYPE "LINUX"
+#     define DYNAMIC_LOADING
+      extern int _end[];
+#     define DATAEND (_end)
+      extern int __data_start[];
+#     define DATASTART ((ptr_t)(__data_start))
+#     ifdef _MIPS_SZPTR
+#	define CPP_WORDSZ _MIPS_SZPTR
+#	define ALIGNMENT (_MIPS_SZPTR/8)
+#     else
+#	define ALIGNMENT 4
+#     endif
+#     if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 2 || __GLIBC__ > 2
+#        define LINUX_STACKBOTTOM
+#     else
+#        define STACKBOTTOM 0x80000000
+#     endif
+#   endif /* Linux */
+#   ifdef EWS4800
+#      define HEURISTIC2
+#      if defined(_MIPS_SZPTR) && (_MIPS_SZPTR == 64)
+         extern int _fdata[], _end[];
+#        define DATASTART ((ptr_t)_fdata)
+#        define DATAEND ((ptr_t)_end)
+#        define CPP_WORDSZ _MIPS_SZPTR
+#        define ALIGNMENT (_MIPS_SZPTR/8)
+#      else
+         extern int etext[], edata[], end[];
+         extern int _DYNAMIC_LINKING[], _gp[];
+#        define DATASTART ((ptr_t)((((word)etext + 0x3ffff) & ~0x3ffff) \
+               + ((word)etext & 0xffff)))
+#        define DATAEND (edata)
+#        define DATASTART2 (_DYNAMIC_LINKING \
+               ? (ptr_t)(((word)_gp + 0x8000 + 0x3ffff) & ~0x3ffff) \
+               : (ptr_t)edata)
+#        define DATAEND2 (end)
+#        define ALIGNMENT 4
+#      endif
+#      define OS_TYPE "EWS4800"
+#   endif
+#   ifdef ULTRIX
+#	define HEURISTIC2
+#       define DATASTART (ptr_t)0x10000000
+			      /* Could probably be slightly higher since */
+			      /* startup code allocates lots of stuff.   */
+#	define OS_TYPE "ULTRIX"
+#       define ALIGNMENT 4
+#   endif
+#   ifdef IRIX5
+#	define HEURISTIC2
+        extern int _fdata[];
+#       define DATASTART ((ptr_t)(_fdata))
+#       ifdef USE_MMAP
+#         define HEAP_START (ptr_t)0x30000000
+#       else
+#	  define HEAP_START DATASTART
+#       endif
+			      /* Lowest plausible heap address.		*/
+			      /* In the MMAP case, we map there.	*/
+			      /* In either case it is used to identify	*/
+			      /* heap sections so they're not 		*/
+			      /* considered as roots.			*/
+#	define OS_TYPE "IRIX5"
+/*#       define MPROTECT_VDB DOB: this should work, but there is evidence */
+/* 	  	of recent breakage.					   */
+#       ifdef _MIPS_SZPTR
+#	  define CPP_WORDSZ _MIPS_SZPTR
+#	  define ALIGNMENT (_MIPS_SZPTR/8)
+#	else
+#         define ALIGNMENT 4
+#	endif
+#	define DYNAMIC_LOADING
+#   endif
+#   ifdef MSWINCE
+#       define OS_TYPE "MSWINCE"
+#       define ALIGNMENT 4
+#       define DATAEND /* not needed */
+#   endif
+#   if defined(NETBSD)
+#     define OS_TYPE "NETBSD"
+#     define ALIGNMENT 4
+#     define HEURISTIC2
+#     ifdef __ELF__
+        extern int etext[];
+#       define DATASTART GC_data_start
+#       define NEED_FIND_LIMIT
+#       define DYNAMIC_LOADING
+#     else
+#       define DATASTART ((ptr_t) 0x10000000)
+#       define STACKBOTTOM ((ptr_t) 0x7ffff000)
+#     endif /* _ELF_ */
+#  endif
+#  if defined(NONSTOP)
+#    define CPP_WORDSZ 32
+#    define OS_TYPE "NONSTOP"
+#    define ALIGNMENT 4
+#    define DATASTART ((ptr_t) 0x08000000)
+     extern char **environ;
+#    define DATAEND ((ptr_t)(environ - 0x10))
+#    define STACKBOTTOM ((ptr_t) 0x4fffffff)
+#   endif
+# endif
+
+# ifdef HP_PA
+#   define MACH_TYPE "HP_PA"
+#   ifdef __LP64__
+#     define CPP_WORDSZ 64
+#     define ALIGNMENT 8
+#   else
+#     define CPP_WORDSZ 32
+#     define ALIGNMENT 4
+#   endif
+#   if !defined(GC_HPUX_THREADS) && !defined(GC_LINUX_THREADS)
+#     ifndef LINUX /* For now. */
+#       define MPROTECT_VDB
+#     endif
+#   else
+#     ifdef PARALLEL_MARK
+#	define USE_MARK_BYTES
+		/* Minimize compare-and-swap usage.		*/
+#     endif
+#   endif
+#   define STACK_GROWS_UP
+#   ifdef HPUX
+#     define OS_TYPE "HPUX"
+      extern int __data_start[];
+#     define DATASTART ((ptr_t)(__data_start))
+#     if 0
+	/* The following appears to work for 7xx systems running HP/UX	*/
+	/* 9.xx Furthermore, it might result in much faster		*/
+	/* collections than HEURISTIC2, which may involve scanning	*/
+	/* segments that directly precede the stack.  It is not the	*/
+	/* default, since it may not work on older machine/OS		*/
+	/* combinations. (Thanks to Raymond X.T. Nijssen for uncovering	*/
+	/* this.)							*/
+#       define STACKBOTTOM ((ptr_t) 0x7b033000)  /* from /etc/conf/h/param.h */
+#     else
+	/* Gustavo Rodriguez-Rivera suggested changing HEURISTIC2	*/
+	/* to this.  Note that the GC must be initialized before the	*/
+    	/* first putenv call.						*/
+	extern char ** environ;
+#       define STACKBOTTOM ((ptr_t)environ)
+#     endif
+#     define DYNAMIC_LOADING
+#     include <unistd.h>
+#     define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)
+#     ifndef __GNUC__
+#       define PREFETCH(x)  { \
+                              register long addr = (long)(x); \
+                              (void) _asm ("LDW", 0, 0, addr, 0); \
+                            }
+#     endif
+#   endif /* HPUX */
+#   ifdef LINUX
+#     define OS_TYPE "LINUX"
+#     define LINUX_STACKBOTTOM
+#     define DYNAMIC_LOADING
+#     define SEARCH_FOR_DATA_START
+      extern int _end[];
+#     define DATAEND (&_end)
+#   endif /* LINUX */
+# endif /* HP_PA */
+
+# ifdef ALPHA
+#   define MACH_TYPE "ALPHA"
+#   define ALIGNMENT 8
+#   define CPP_WORDSZ 64
+#   ifdef NETBSD
+#	define OS_TYPE "NETBSD"
+#	define HEURISTIC2
+#	define DATASTART GC_data_start
+#	define ELFCLASS32 32
+#	define ELFCLASS64 64
+#	define ELF_CLASS ELFCLASS64
+#       define DYNAMIC_LOADING
+#   endif
+#   ifdef OPENBSD
+#	define OS_TYPE "OPENBSD"
+#	define HEURISTIC2
+#   	ifdef __ELF__	/* since OpenBSD/Alpha 2.9 */
+#	   define DATASTART GC_data_start
+#   	   define ELFCLASS32 32
+#   	   define ELFCLASS64 64
+#   	   define ELF_CLASS ELFCLASS64
+#       else		/* ECOFF, until OpenBSD/Alpha 2.7 */
+#   	   define DATASTART ((ptr_t) 0x140000000)
+#   	endif
+#   endif
+#   ifdef FREEBSD
+#	define OS_TYPE "FREEBSD"
+/* MPROTECT_VDB is not yet supported at all on FreeBSD/alpha. */
+#	define SIG_SUSPEND SIGUSR1
+#	define SIG_THR_RESTART SIGUSR2
+#	define FREEBSD_STACKBOTTOM
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+/* Handle unmapped hole alpha*-*-freebsd[45]* puts between etext and edata. */
+	extern char etext[];
+	extern char edata[];
+	extern char end[];
+#	define NEED_FIND_LIMIT
+#	define DATASTART ((ptr_t)(&etext))
+#	define DATAEND (GC_find_limit (DATASTART, TRUE))
+#	define DATASTART2 ((ptr_t)(&edata))
+#	define DATAEND2 ((ptr_t)(&end))
+#   endif
+#   ifdef OSF1
+#	define OS_TYPE "OSF1"
+#   	define DATASTART ((ptr_t) 0x140000000)
+	extern int _end[];
+#   	define DATAEND ((ptr_t) &_end)
+ 	extern char ** environ;
+	/* round up from the value of environ to the nearest page boundary */
+	/* Probably breaks if putenv is called before collector 	   */
+	/* initialization.						   */
+#	define STACKBOTTOM ((ptr_t)(((word)(environ) | (getpagesize()-1))+1))
+/* #   	define HEURISTIC2 */
+	/* Normally HEURISTIC2 is too conervative, since		*/
+	/* the text segment immediately follows the stack.		*/
+	/* Hence we give an upper pound.				*/
+	/* This is currently unused, since we disabled HEURISTIC2	*/
+    	extern int __start[];
+#   	define HEURISTIC2_LIMIT ((ptr_t)((word)(__start) & ~(getpagesize()-1)))
+#	ifndef GC_OSF1_THREADS
+	  /* Unresolved signal issues with threads.	*/
+#   	  define MPROTECT_VDB
+#       endif
+#   	define DYNAMIC_LOADING
+#   endif
+#   ifdef LINUX
+#       define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#       ifdef __ELF__
+#	  define SEARCH_FOR_DATA_START
+#         define DYNAMIC_LOADING
+#       else
+#           define DATASTART ((ptr_t) 0x140000000)
+#       endif
+	extern int _end[];
+#	define DATAEND (_end)
+#	define MPROTECT_VDB
+		/* Has only been superficially tested.  May not	*/
+		/* work on all versions.			*/
+#   endif
+# endif
+
+# ifdef IA64
+#   define MACH_TYPE "IA64"
+#   ifdef HPUX
+#	ifdef _ILP32
+#	  define CPP_WORDSZ 32
+	    /* Requires 8 byte alignment for malloc */
+#   	  define ALIGNMENT 4
+#       else
+#	  ifndef _LP64
+		---> unknown ABI
+#         endif
+#	  define CPP_WORDSZ 64
+	    /* Requires 16 byte alignment for malloc */
+#         define ALIGNMENT 8
+#       endif
+#       define OS_TYPE "HPUX"	
+        extern int __data_start[];
+#       define DATASTART ((ptr_t)(__data_start))
+        /* Gustavo Rodriguez-Rivera suggested changing HEURISTIC2	*/
+        /* to this.  Note that the GC must be initialized before the	*/
+    	/* first putenv call.						*/
+	extern char ** environ;
+#       define STACKBOTTOM ((ptr_t)environ)
+#       define HPUX_STACKBOTTOM
+#       define DYNAMIC_LOADING
+#       include <unistd.h>
+#       define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)
+ 	/* The following was empirically determined, and is probably	*/
+	/* not very robust.						*/
+	/* Note that the backing store base seems to be at a nice 	*/
+	/* address minus one page.					*/
+#	define BACKING_STORE_DISPLACEMENT 0x1000000
+#	define BACKING_STORE_ALIGNMENT 0x1000
+	extern ptr_t GC_register_stackbottom;
+#	define BACKING_STORE_BASE GC_register_stackbottom
+	/* Known to be wrong for recent HP/UX versions!!!	*/
+#   endif
+#   ifdef LINUX
+#   	define CPP_WORDSZ 64
+#   	define ALIGNMENT 8
+#       define OS_TYPE "LINUX"
+	/* The following works on NUE and older kernels:	*/
+/* #       define STACKBOTTOM ((ptr_t) 0xa000000000000000l)	*/
+	/* This does not work on NUE:				*/
+#       define LINUX_STACKBOTTOM
+	/* We also need the base address of the register stack	*/
+	/* backing store.  This is computed in 			*/
+	/* GC_linux_register_stack_base based on the following	*/
+	/* constants:						*/
+#       define BACKING_STORE_ALIGNMENT 0x100000
+#       define BACKING_STORE_DISPLACEMENT 0x80000000
+	extern ptr_t GC_register_stackbottom;
+#	define BACKING_STORE_BASE GC_register_stackbottom
+#	define SEARCH_FOR_DATA_START
+#	ifdef __GNUC__
+#         define DYNAMIC_LOADING
+#	else
+	  /* In the Intel compiler environment, we seem to end up with  */
+	  /* statically linked executables and an undefined reference	*/
+	  /* to _DYNAMIC						*/
+#  	endif
+#	define MPROTECT_VDB
+		/* Requires Linux 2.3.47 or later.	*/
+	extern int _end[];
+#	define DATAEND (_end)
+#       ifdef __GNUC__
+#	  ifndef __INTEL_COMPILER
+#	    define PREFETCH(x) \
+	      __asm__ ("	lfetch	[%0]": : "r"(x))
+#	    define PREFETCH_FOR_WRITE(x) \
+	      __asm__ ("	lfetch.excl	[%0]": : "r"(x))
+#	    define CLEAR_DOUBLE(x) \
+	      __asm__ ("	stf.spill	[%0]=f0": : "r"((void *)(x)))
+#	  else
+#           include <ia64intrin.h>
+#	    define PREFETCH(x) \
+	      __lfetch(__lfhint_none, (x))
+#	    define PREFETCH_FOR_WRITE(x) \
+	      __lfetch(__lfhint_nta,  (x))
+#	    define CLEAR_DOUBLE(x) \
+	      __stf_spill((void *)(x), 0)
+#	  endif // __INTEL_COMPILER
+#       endif
+#   endif
+#   ifdef MSWIN32
+      /* FIXME: This is a very partial guess.  There is no port, yet.	*/
+#     define OS_TYPE "MSWIN32"
+		/* STACKBOTTOM and DATASTART are handled specially in 	*/
+		/* os_dep.c.						*/
+#     define DATAEND  /* not needed */
+#     if defined(_WIN64)
+#       define CPP_WORDSZ 64
+#     else
+#       define CPP_WORDSZ 32   /* Is this possible?	*/
+#     endif
+#     define ALIGNMENT 8
+#     define STRTOULL _strtoui64
+#   endif
+# endif
+
+# ifdef M88K
+#   define MACH_TYPE "M88K"
+#   define ALIGNMENT 4
+    extern int etext[];
+#   ifdef CX_UX
+#	define OS_TYPE "CX_UX"
+#       define DATASTART ((((word)etext + 0x3fffff) & ~0x3fffff) + 0x10000)
+#   endif
+#   ifdef  DGUX
+#	define OS_TYPE "DGUX"
+	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_SysVGetDataStart(0x10000, (ptr_t)etext)
+#   endif
+#   define STACKBOTTOM ((char*)0xf0000000) /* determined empirically */
+# endif
+
+# ifdef S370
+    /* If this still works, and if anyone cares, this should probably	*/
+    /* be moved to the S390 category.					*/
+#   define MACH_TYPE "S370"
+#   define ALIGNMENT 4	/* Required by hardware	*/
+#   ifdef UTS4
+#       define OS_TYPE "UTS4"
+	extern int etext[];
+	extern int _etext[];
+	extern int _end[];
+	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_SysVGetDataStart(0x10000, (ptr_t)_etext)
+#	define DATAEND (_end)
+#	define HEURISTIC2
+#   endif
+# endif
+
+# ifdef S390
+#   define MACH_TYPE "S390"
+#   ifndef __s390x__
+#   define ALIGNMENT 4
+#   define CPP_WORDSZ 32
+#   else
+#   define ALIGNMENT 8
+#   define CPP_WORDSZ 64
+#   ifndef HBLKSIZE
+#     define HBLKSIZE 4096
+#   endif
+#   endif
+#   ifdef LINUX
+#       define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#       define DYNAMIC_LOADING
+	extern int __data_start[];
+#       define DATASTART ((ptr_t)(__data_start))
+    extern int _end[];
+#   define DATAEND (_end)
+#   define CACHE_LINE_SIZE 256
+#   define GETPAGESIZE() 4096
+#   endif
+# endif
+
+# ifdef ARM32
+#   define CPP_WORDSZ 32
+#   define MACH_TYPE "ARM32"
+#   define ALIGNMENT 4
+#   ifdef NETBSD
+#       define OS_TYPE "NETBSD"
+#       define HEURISTIC2
+#	ifdef __ELF__
+#          define DATASTART GC_data_start
+#	   define DYNAMIC_LOADING
+#	else
+           extern char etext[];
+#          define DATASTART ((ptr_t)(etext))
+#	endif
+#   endif
+#   ifdef LINUX
+#       define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#       undef STACK_GRAN
+#       define STACK_GRAN 0x10000000
+#       ifdef __ELF__
+#            define DYNAMIC_LOADING
+#	     include <features.h>
+#	     if defined(__GLIBC__) && __GLIBC__ >= 2
+#		 define SEARCH_FOR_DATA_START
+#	     else
+     	         extern char **__environ;
+#                define DATASTART ((ptr_t)(&__environ))
+			      /* hideous kludge: __environ is the first */
+			      /* word in crt0.o, and delimits the start */
+			      /* of the data segment, no matter which   */
+			      /* ld options were passed through.        */
+			      /* We could use _etext instead, but that  */
+			      /* would include .rodata, which may       */
+			      /* contain large read-only data tables    */
+			      /* that we'd rather not scan.		*/
+#	     endif
+	     extern int _end[];
+#	     define DATAEND (_end)
+#	else
+	     extern int etext[];
+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#       endif
+#   endif
+#   ifdef MSWINCE
+#     define OS_TYPE "MSWINCE"
+#     define DATAEND /* not needed */
+#   endif
+#   ifdef NOSYS
+      /* __data_start is usually defined in the target linker script.  */
+      extern int __data_start[];
+#     define DATASTART (ptr_t)(__data_start)
+      /* __stack_base__ is set in newlib/libc/sys/arm/crt0.S  */
+      extern void *__stack_base__;
+#     define STACKBOTTOM ((ptr_t) (__stack_base__))
+#   endif
+#endif
+
+# ifdef CRIS
+#   define MACH_TYPE "CRIS"
+#   define CPP_WORDSZ 32
+#   define ALIGNMENT 1
+#   define OS_TYPE "LINUX"
+#   define DYNAMIC_LOADING
+#   define LINUX_STACKBOTTOM
+#   define SEARCH_FOR_DATA_START
+      extern int _end[];
+#   define DATAEND (_end)
+# endif
+
+# ifdef SH
+#   define MACH_TYPE "SH"
+#   define ALIGNMENT 4
+#   ifdef MSWINCE
+#     define OS_TYPE "MSWINCE"
+#     define DATAEND /* not needed */
+#   endif
+#   ifdef LINUX
+#     define OS_TYPE "LINUX"
+#     define LINUX_STACKBOTTOM
+#     define DYNAMIC_LOADING
+#     define SEARCH_FOR_DATA_START
+      extern int _end[];
+#     define DATAEND (_end)
+#   endif
+#   ifdef NETBSD
+#      define OS_TYPE "NETBSD"
+#      define HEURISTIC2
+#      define DATASTART GC_data_start
+#      define DYNAMIC_LOADING
+#   endif
+# endif
+ 
+# ifdef SH4
+#   define MACH_TYPE "SH4"
+#   define OS_TYPE "MSWINCE"
+#   define ALIGNMENT 4
+#   define DATAEND /* not needed */
+# endif
+
+# ifdef M32R
+#   define CPP_WORDSZ 32
+#   define MACH_TYPE "M32R"
+#   define ALIGNMENT 4
+#   ifdef LINUX
+#     define OS_TYPE "LINUX"
+#     define LINUX_STACKBOTTOM
+#     undef STACK_GRAN
+#     define STACK_GRAN 0x10000000
+#     define DYNAMIC_LOADING
+#     define SEARCH_FOR_DATA_START
+      extern int _end[];
+#     define DATAEND (_end)
+#   endif
+# endif
+
+# ifdef X86_64
+#   define MACH_TYPE "X86_64"
+#   define ALIGNMENT 8
+#   define CPP_WORDSZ 64
+#   ifndef HBLKSIZE
+#     define HBLKSIZE 4096
+#   endif
+#   define CACHE_LINE_SIZE 64
+#   ifdef LINUX
+#	define OS_TYPE "LINUX"
+#       define LINUX_STACKBOTTOM
+#       if !defined(GC_LINUX_THREADS) || !defined(REDIRECT_MALLOC)
+#	    define MPROTECT_VDB
+#	else
+	    /* We seem to get random errors in incremental mode,	*/
+	    /* possibly because Linux threads is itself a malloc client */
+	    /* and can't deal with the signals.				*/
+#	endif
+#       ifdef __ELF__
+#            define DYNAMIC_LOADING
+#	     ifdef UNDEFINED	/* includes ro data */
+	       extern int _etext[];
+#              define DATASTART ((ptr_t)((((word) (_etext)) + 0xfff) & ~0xfff))
+#	     endif
+#	     include <features.h>
+#	     define SEARCH_FOR_DATA_START
+	     extern int _end[];
+#	     define DATAEND (_end)
+#	else
+	     extern int etext[];
+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
+#       endif
+#       if defined(__GNUC__) && __GNUC__ >= 3
+#	    define PREFETCH(x) __builtin_prefetch((x), 0, 0)
+#	    define PREFETCH_FOR_WRITE(x) __builtin_prefetch((x), 1)
+#	endif
+#   endif
+#   ifdef DARWIN
+#     define OS_TYPE "DARWIN"
+#     define DARWIN_DONT_PARSE_STACK
+#     define DYNAMIC_LOADING
+      /* XXX: see get_end(3), get_etext() and get_end() should not be used.
+	 These aren't used when dyld support is enabled (it is by default) */
+#     define DATASTART ((ptr_t) get_etext())
+#     define DATAEND	((ptr_t) get_end())
+#     define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)
+#     define USE_MMAP
+#     define USE_MMAP_ANON
+#     ifdef GC_DARWIN_THREADS
+#       define MPROTECT_VDB
+#     endif
+#     include <unistd.h>
+#     define GETPAGESIZE() getpagesize()
+      /* There seems to be some issues with trylock hanging on darwin. This
+	 should be looked into some more */
+#     define NO_PTHREAD_TRYLOCK
+#   endif
+#   ifdef FREEBSD
+#	define OS_TYPE "FREEBSD"
+#	ifndef GC_FREEBSD_THREADS
+#	    define MPROTECT_VDB
+#	endif
+#	ifdef __GLIBC__
+#	    define SIG_SUSPEND		(32+6)
+#	    define SIG_THR_RESTART	(32+5)
+	    extern int _end[];
+#	    define DATAEND (_end)
+#	else
+#	    define SIG_SUSPEND SIGUSR1
+#	    define SIG_THR_RESTART SIGUSR2
+#	endif
+#	define FREEBSD_STACKBOTTOM
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+	extern char etext[];
+	extern char * GC_FreeBSDGetDataStart();
+#	define DATASTART GC_FreeBSDGetDataStart(0x1000, &etext)
+#   endif
+#   ifdef NETBSD
+#	define OS_TYPE "NETBSD"
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+#	define HEURISTIC2
+	extern char etext[];
+#	define SEARCH_FOR_DATA_START
+#   endif
+#   ifdef SOLARIS
+#	define OS_TYPE "SOLARIS"
+#	define ELF_CLASS ELFCLASS64
+        extern int _etext[], _end[];
+  	extern ptr_t GC_SysVGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_SysVGetDataStart(0x1000, (ptr_t)_etext)
+#	define DATAEND (_end)
+/*	# define STACKBOTTOM ((ptr_t)(_start)) worked through 2.7,  	*/
+/*      but reportedly breaks under 2.8.  It appears that the stack	*/
+/* 	base is a property of the executable, so this should not break	*/
+/* 	old executables.						*/
+/*  	HEURISTIC2 probably works, but this appears to be preferable.	*/
+/*	Apparently USRSTACK is defined to be USERLIMIT, but in some	*/
+/* 	installations that's undefined.  We work around this with a	*/
+/*	gross hack:							*/
+#       include <sys/vmparam.h>
+#	ifdef USERLIMIT
+	  /* This should work everywhere, but doesn't.	*/
+#	  define STACKBOTTOM USRSTACK
+#       else
+#	  define HEURISTIC2
+#       endif
+/* At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */
+/* It appears to be fixed in 2.8 and 2.9.				*/
+#	ifdef SOLARIS25_PROC_VDB_BUG_FIXED
+#	  define PROC_VDB
+#	endif
+#	define DYNAMIC_LOADING
+#	if !defined(USE_MMAP) && defined(REDIRECT_MALLOC)
+#	    define USE_MMAP
+	    /* Otherwise we now use calloc.  Mmap may result in the	*/
+	    /* heap interleaved with thread stacks, which can result in	*/
+	    /* excessive blacklisting.  Sbrk is unusable since it	*/
+	    /* doesn't interact correctly with the system malloc.	*/
+#	endif
+#       ifdef USE_MMAP
+#         define HEAP_START (ptr_t)0x40000000
+#       else
+#	  define HEAP_START DATAEND
+#       endif
+#   endif
+#   ifdef MSWIN32
+#	define OS_TYPE "MSWIN32"
+		/* STACKBOTTOM and DATASTART are handled specially in 	*/
+		/* os_dep.c.						*/
+#       if !defined(__WATCOMC__)
+#	  define MPROTECT_VDB
+	  /* We also avoided doing this in the past with GC_WIN32_THREADS */
+	  /* Hopefully that's fixed.					  */
+#	endif
+#	if _MSC_VER >= 1300  /* .NET, i.e. > VisualStudio 6	*/
+#         define GWW_VDB
+#	endif
+#       define DATAEND  /* not needed */
+#   endif
+# endif
+
+#if defined(LINUX_STACKBOTTOM) && defined(NO_PROC_STAT) \
+    && !defined(USE_LIBC_PRIVATES)
+    /* This combination will fail, since we have no way to get	*/
+    /* the stack base.	Use HEURISTIC2 instead.			*/
+#   undef LINUX_STACKBOTTOM
+#   define HEURISTIC2
+    /* This may still fail on some architectures like IA64.	*/
+    /* We tried ...						*/
+#endif
+
+#if defined(LINUX) && defined(USE_MMAP)
+    /* The kernel may do a somewhat better job merging mappings etc.	*/
+    /* with anonymous mappings.						*/
+#   define USE_MMAP_ANON
+#endif
+
+#if defined(GC_LINUX_THREADS) && defined(REDIRECT_MALLOC)
+    /* Nptl allocates thread stacks with mmap, which is fine.  But it	*/
+    /* keeps a cache of thread stacks.  Thread stacks contain the	*/
+    /* thread control blocks.  These in turn contain a pointer to	*/
+    /* (sizeof (void *) from the beginning of) the dtv for thread-local	*/
+    /* storage, which is calloc allocated.  If we don't scan the cached	*/
+    /* thread stacks, we appear to lose the dtv.  This tends to		*/
+    /* result in something that looks like a bogus dtv count, which	*/
+    /* tends to result in a memset call on a block that is way too	*/
+    /* large.  Sometimes we're lucky and the process just dies ...	*/
+    /* There seems to be a similar issue with some other memory 	*/
+    /* allocated by the dynamic loader.					*/
+    /* This should be avoidable by either:				*/
+    /* - Defining USE_PROC_FOR_LIBRARIES here.				*/
+    /*   That performs very poorly, precisely because we end up 	*/
+    /*   scanning cached stacks.					*/
+    /* - Have calloc look at its callers.  				*/
+    /*   In spite of the fact that it is gross and disgusting.		*/
+    /* In fact neither seems to suffice, probably in part because 	*/
+    /* even with USE_PROC_FOR_LIBRARIES, we don't scan parts of stack	*/
+    /* segments that appear to be out of bounds.  Thus we actually	*/
+    /* do both, which seems to yield the best results.			*/
+
+#   define USE_PROC_FOR_LIBRARIES
+#endif
+
+# ifndef STACK_GROWS_UP
+#   define STACK_GROWS_DOWN
+# endif
+
+# ifndef CPP_WORDSZ
+#   define CPP_WORDSZ 32
+# endif
+
+# ifndef OS_TYPE
+#   define OS_TYPE ""
+# endif
+
+# ifndef DATAEND
+    extern int end[];
+#   define DATAEND (end)
+# endif
+
+# if defined(SVR4) && !defined(GETPAGESIZE)
+#    include <unistd.h>
+#    define GETPAGESIZE()  sysconf(_SC_PAGESIZE)
+# endif
+
+# ifndef GETPAGESIZE
+#   if defined(SOLARIS) || defined(IRIX5) || defined(LINUX) \
+       || defined(NETBSD) || defined(FREEBSD) || defined(HPUX)
+#	include <unistd.h>
+#   endif
+#   define GETPAGESIZE() getpagesize()
+# endif
+
+# if defined(SOLARIS) || defined(DRSNX) || defined(UTS4)
+	    /* OS has SVR4 generic features.		*/
+    	    /* Probably others also qualify.		*/
+#   define SVR4
+# endif
+
+# if defined(SOLARIS) || defined(DRSNX)
+	    /* OS has SOLARIS style semi-undocumented interface */
+    	    /* to dynamic loader.				*/
+#   define SOLARISDL
+	    /* OS has SOLARIS style signal handlers.		*/
+#   define SUNOS5SIGS
+# endif
+
+# if defined(HPUX)
+#   define SUNOS5SIGS
+# endif
+
+# if defined(FREEBSD) && \
+     (defined(__DragonFly__) || __FreeBSD__ >= 4 || (__FreeBSD_kernel__ >= 4))
+#   define SUNOS5SIGS
+# endif
+
+# ifdef GC_NETBSD_THREADS
+#   define SIGRTMIN 33
+#   define SIGRTMAX 63
+# endif
+
+# if defined(SVR4) || defined(LINUX) || defined(IRIX5) || defined(HPUX) \
+	    || defined(OPENBSD) || defined(NETBSD) || defined(FREEBSD) \
+	    || defined(DGUX) || defined(BSD) \
+	    || defined(AIX) || defined(DARWIN) || defined(OSF1) \
+	    || defined(HURD)
+#   define UNIX_LIKE   /* Basic Unix-like system calls work.	*/
+# endif
+
+# if CPP_WORDSZ != 32 && CPP_WORDSZ != 64
+	   -> bad word size
+# endif
+
+# ifdef PCR
+#   undef DYNAMIC_LOADING
+#   undef STACKBOTTOM
+#   undef HEURISTIC1
+#   undef HEURISTIC2
+#   undef PROC_VDB
+#   undef MPROTECT_VDB
+#   define PCR_VDB
+# endif
+
+# ifdef SMALL_CONFIG
+	/* Presumably not worth the space it takes. */
+#   undef PROC_VDB
+#   undef MPROTECT_VDB
+# endif
+
+# ifdef USE_MUNMAP
+#   undef MPROTECT_VDB  /* Can't deal with address space holes. */
+# endif
+
+# ifdef PARALLEL_MARK
+#   undef MPROTECT_VDB  /* For now.	*/
+# endif
+
+# if !defined(PCR_VDB) && !defined(PROC_VDB) && !defined(MPROTECT_VDB) \
+    && !defined(GWW_VDB)
+#   define DEFAULT_VDB
+# endif
+
+# ifndef PREFETCH
+#   define PREFETCH(x)
+#   define NO_PREFETCH
+# endif
+
+# ifndef PREFETCH_FOR_WRITE
+#   define PREFETCH_FOR_WRITE(x)
+#   define NO_PREFETCH_FOR_WRITE
+# endif
+
+# ifndef CACHE_LINE_SIZE
+#   define CACHE_LINE_SIZE 32	/* Wild guess	*/
+# endif
+
+# if defined(LINUX) || defined(HURD) || defined(__GLIBC__)
+#   define REGISTER_LIBRARIES_EARLY
+    /* We sometimes use dl_iterate_phdr, which may acquire an internal	*/
+    /* lock.  This isn't safe after the world has stopped.  So we must	*/
+    /* call GC_register_dynamic_libraries before stopping the world.	*/
+    /* For performance reasons, this may be beneficial on other		*/
+    /* platforms as well, though it should be avoided in win32.		*/
+# endif /* LINUX */
+
+# if defined(SEARCH_FOR_DATA_START)
+    extern ptr_t GC_data_start;
+#   define DATASTART GC_data_start
+# endif
+
+# ifndef CLEAR_DOUBLE
+#   define CLEAR_DOUBLE(x) \
+		((word*)x)[0] = 0; \
+		((word*)x)[1] = 0;
+# endif /* CLEAR_DOUBLE */
+
+# if defined(GC_LINUX_THREADS) && defined(REDIRECT_MALLOC) \
+     && !defined(INCLUDE_LINUX_THREAD_DESCR)
+    /* Will not work, since libc and the dynamic loader use thread 	*/
+    /* locals, sometimes as the only reference.				*/
+#   define INCLUDE_LINUX_THREAD_DESCR
+# endif
+
+# if defined(GC_IRIX_THREADS) && !defined(IRIX5)
+	--> inconsistent configuration
+# endif
+# if defined(GC_LINUX_THREADS) && !defined(LINUX)
+	--> inconsistent configuration
+# endif
+# if defined(GC_NETBSD_THREADS) && !defined(NETBSD)
+	--> inconsistent configuration
+# endif
+# if defined(GC_FREEBSD_THREADS) && !defined(FREEBSD)
+	--> inconsistent configuration
+# endif
+# if defined(GC_SOLARIS_THREADS) && !defined(SOLARIS)
+	--> inconsistent configuration
+# endif
+# if defined(GC_HPUX_THREADS) && !defined(HPUX)
+	--> inconsistent configuration
+# endif
+# if defined(GC_AIX_THREADS) && !defined(_AIX)
+	--> inconsistent configuration
+# endif
+# if defined(GC_GNU_THREADS) && !defined(HURD)
+	--> inconsistent configuration
+# endif
+# if defined(GC_WIN32_THREADS) && !defined(MSWIN32) && !defined(CYGWIN32)
+	--> inconsistent configuration
+# endif
+
+# if defined(PCR) || defined(GC_WIN32_THREADS) || defined(GC_PTHREADS)
+#   define THREADS
+# endif
+
+# if !defined(USE_MARK_BITS) && !defined(USE_MARK_BYTES)
+#   if defined(THREADS) && defined(PARALLEL_MARK)
+#     define USE_MARK_BYTES
+#   else
+#     define USE_MARK_BITS
+#   endif
+# endif
+
+# if defined(MSWINCE)
+#   define NO_GETENV
+# endif
+
+# if defined(SPARC)
+#   define ASM_CLEAR_CODE	/* Stack clearing is crucial, and we 	*/
+				/* include assembly code to do it well.	*/
+# endif
+
+  /* Can we save call chain in objects for debugging?   	        */
+  /* SET NFRAMES (# of saved frames) and NARGS (#of args for each 	*/
+  /* frame) to reasonable values for the platform.			*/
+  /* Set SAVE_CALL_CHAIN if we can.  SAVE_CALL_COUNT can be specified 	*/
+  /* at build time, though we feel free to adjust it slightly.		*/
+  /* Define NEED_CALLINFO if we either save the call stack or 		*/
+  /* GC_ADD_CALLER is defined.						*/
+  /* GC_CAN_SAVE_CALL_STACKS is set in gc.h.				*/
+
+#if defined(SPARC)
+# define CAN_SAVE_CALL_ARGS
+#endif
+#if (defined(I386) || defined(X86_64)) && (defined(LINUX) || defined(__GLIBC__))
+	    /* SAVE_CALL_CHAIN is supported if the code is compiled to save	*/
+	    /* frame pointers by default, i.e. no -fomit-frame-pointer flag.	*/
+# define CAN_SAVE_CALL_ARGS
+#endif
+
+# if defined(SAVE_CALL_COUNT) && !defined(GC_ADD_CALLER) \
+	     && defined(GC_CAN_SAVE_CALL_STACKS)
+#   define SAVE_CALL_CHAIN 
+# endif
+# ifdef SAVE_CALL_CHAIN
+#   if defined(SAVE_CALL_NARGS) && defined(CAN_SAVE_CALL_ARGS)
+#     define NARGS SAVE_CALL_NARGS
+#   else
+#     define NARGS 0	/* Number of arguments to save for each call.	*/
+#   endif
+# endif
+# ifdef SAVE_CALL_CHAIN
+#   ifndef SAVE_CALL_COUNT
+#     define NFRAMES 6	/* Number of frames to save. Even for		*/
+			/* alignment reasons.				*/
+#   else
+#     define NFRAMES ((SAVE_CALL_COUNT + 1) & ~1)
+#   endif
+#   define NEED_CALLINFO
+# endif /* SAVE_CALL_CHAIN */
+# ifdef GC_ADD_CALLER
+#   define NFRAMES 1
+#   define NARGS 0
+#   define NEED_CALLINFO
+# endif
+
+# if defined(MAKE_BACK_GRAPH) && !defined(DBG_HDRS_ALL)
+#   define DBG_HDRS_ALL
+# endif
+
+# if defined(POINTER_MASK) && !defined(POINTER_SHIFT)
+#   define POINTER_SHIFT 0
+# endif
+
+# if defined(POINTER_SHIFT) && !defined(POINTER_MASK)
+#   define POINTER_MASK ((GC_word)(-1))
+# endif
+
+# if !defined(FIXUP_POINTER) && defined(POINTER_MASK)
+#   define FIXUP_POINTER(p) (p) = ((p) & (POINTER_MASK) << POINTER_SHIFT)
+# endif
+
+# if defined(FIXUP_POINTER)
+#   define NEED_FIXUP_POINTER 1
+# else
+#   define NEED_FIXUP_POINTER 0
+#   define FIXUP_POINTER(p)
+# endif
+
+# if !defined(MARK_BIT_PER_GRANULE) && !defined(MARK_BIT_PER_OBJ)
+#   define MARK_BIT_PER_GRANULE	/* Usually faster */
+# endif
+
+/* Some static sanity tests.	*/
+# if defined(MARK_BIT_PER_GRANULE) && defined(MARK_BIT_PER_OBJ)
+#   error Define only one of MARK_BIT_PER_GRANULE and MARK_BIT_PER_OBJ.
+# endif
+
+# if defined(STACK_GROWS_UP) && defined(STACK_GROWS_DOWN)
+#   error "Only one of STACK_GROWS_UP and STACK_GROWS_DOWN should be defd."
+# endif
+# if !defined(STACK_GROWS_UP) && !defined(STACK_GROWS_DOWN)
+#   error "One of STACK_GROWS_UP and STACK_GROWS_DOWN should be defd."
+# endif
+
+# if defined(REDIRECT_MALLOC) && defined(THREADS) && !defined(LINUX)
+#   error "REDIRECT_MALLOC with THREADS works at most on Linux."
+# endif
+
+#ifdef GC_PRIVATE_H
+	/* This relies on some type definitions from gc_priv.h, from	*/
+        /* where it's normally included.				*/
+	/*								*/
+	/* How to get heap memory from the OS:				*/
+	/* Note that sbrk()-like allocation is preferred, since it 	*/
+	/* usually makes it possible to merge consecutively allocated	*/
+	/* chunks.  It also avoids unintented recursion with		*/
+	/* -DREDIRECT_MALLOC.						*/
+	/* GET_MEM() returns a HLKSIZE aligned chunk.			*/
+	/* 0 is taken to mean failure. 					*/
+	/* In the case os USE_MMAP, the argument must also be a 	*/
+	/* physical page size.						*/
+	/* GET_MEM is currently not assumed to retrieve 0 filled space, */
+	/* though we should perhaps take advantage of the case in which */
+	/* does.							*/
+	struct hblk;	/* See gc_priv.h.	*/
+# if defined(PCR)
+    char * real_malloc();
+#   define GET_MEM(bytes) HBLKPTR(real_malloc((size_t)bytes + GC_page_size) \
+					  + GC_page_size-1)
+# elif defined(OS2)
+    void * os2_alloc(size_t bytes);
+#   define GET_MEM(bytes) HBLKPTR((ptr_t)os2_alloc((size_t)bytes \
+					    + GC_page_size) \
+					    + GC_page_size-1)
+# elif defined(NEXT) || defined(DOS4GW) || defined(NONSTOP) || \
+		 (defined(AMIGA) && !defined(GC_AMIGA_FASTALLOC)) || \
+		 (defined(SOLARIS) && !defined(USE_MMAP))
+#   define GET_MEM(bytes) HBLKPTR((size_t) calloc(1, (size_t)bytes + GC_page_size) \
+					             + GC_page_size-1)
+# elif defined(MSWIN32)
+    extern ptr_t GC_win32_get_mem();
+#   define GET_MEM(bytes) (struct hblk *)GC_win32_get_mem(bytes)
+# elif defined(MACOS)
+#   if defined(USE_TEMPORARY_MEMORY)
+      extern Ptr GC_MacTemporaryNewPtr(size_t size, Boolean clearMemory);
+#     define GET_MEM(bytes) HBLKPTR( \
+			    GC_MacTemporaryNewPtr(bytes + GC_page_size, true) \
+			    + GC_page_size-1)
+#   else
+#     define GET_MEM(bytes) HBLKPTR( \
+				NewPtrClear(bytes + GC_page_size) + GC_page_size-1)
+#   endif
+# elif defined(MSWINCE)
+    extern ptr_t GC_wince_get_mem();
+#   define GET_MEM(bytes) (struct hblk *)GC_wince_get_mem(bytes)
+# elif defined(AMIGA) && defined(GC_AMIGA_FASTALLOC)
+    extern void *GC_amiga_get_mem(size_t size);
+#   define GET_MEM(bytes) HBLKPTR((size_t) \
+			  GC_amiga_get_mem((size_t)bytes + GC_page_size) \
+			  + GC_page_size-1)
+# else
+    extern ptr_t GC_unix_get_mem();
+#   define GET_MEM(bytes) (struct hblk *)GC_unix_get_mem(bytes)
+# endif
+
+#endif /* GC_PRIVATE_H */
+
+# endif /* GCCONFIG_H */
diff -Naur gc-7.1alpha3.orig/win32_threads.c gc-7.1alpha3/win32_threads.c
--- gc-7.1alpha3.orig/win32_threads.c	2008-02-12 02:54:47.000000000 +0100
+++ gc-7.1alpha3/win32_threads.c	2008-02-21 07:08:51.000000000 +0100
@@ -29,7 +29,13 @@
 /* on THREAD_LOCAL_ALLOC, which is currently incompatible. 		    */
 /* It might be possible to get GC_DLL and DllMain-based	thread registration */
 /* to work with Cygwin, but if you try you are on your own.		    */
-#ifdef GC_DLL
+/*---------------------------------------------------------------------*/
+/*    Bigloo start (30 jul 2007)                                       */
+/*---------------------------------------------------------------------*/
+#if defined(GC_DLL) && defined(CYGWIN32)
+/*---------------------------------------------------------------------*/
+/*    Bigloo end                                                       */
+/*---------------------------------------------------------------------*/
 # error GC_DLL untested with Cygwin
 #endif
 
