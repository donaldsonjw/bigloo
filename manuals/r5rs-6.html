<!-- 95% W3C COMPLIANT, 95% CSS FREE, RAW HTML -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-1">
<title>R5Rs</title>
 <style type="text/css">
  <!--
  pre { font-family: monospace }
  tt { font-family: monospace }
  code { font-family: monospace }
  p.flushright { text-align: right }
  p.flushleft { text-align: left }
  span.sc { font-variant: small-caps }
  span.sf { font-family: sans-serif }
  span.skribetitle { font-family: sans-serif; font-weight: bolder; font-size: x-large; }
  span.refscreen { }
  span.refprint { display: none; }
  -->
 </style>
</head>

<body class="chapter" bgcolor="#ffffff">
<table width="100%" class="skribetitle" cellspacing="0" cellpadding="0"><tbody>
<tr><td align="center" bgcolor="#8381de"><div class="skribetitle"><strong><big><big><big>3. R5Rs<br/>Scheme Revised(5) Report on the Algorithmic Language Scheme -- Basic concepts</big></big></big></strong></div><center>
</center>
</td></tr></tbody></table>
<table cellpadding="3" cellspacing="0" width="100%" class="skribe-margins"><tr>
<td align="left" valign="top" class="skribe-left-margin" width="20%" bgcolor="#dedeff"><div class="skribe-left-margin">
<br/><center id='center7561'
><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th id="tc7551" align="center" colspan="1"><font color="#ffffff"><strong id='bold7549'
>main page</strong></font></th></tr>
<tr bgcolor="#ffffff"><td id="tc7558" align="center" colspan="1"><table width="100%" border="0" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc7554" align="left" valign="top" colspan="1"><strong id='bold7553'
>top:</strong></td><td id="tc7555" align="right" valign="top" colspan="1"><a href="r5rs.html#R5Rs-Scheme-Revised(5)-Report-on-the-Algorithmic-Language-Scheme" class="inbound">R5Rs<br/>Scheme Revised(5) Report on the Algorithmic Language Scheme</a></td></tr>
</tbody></table>
</td></tr>
</tbody></table>
</center>
<br/><br/><center id='center7571'
><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th id="tc7565" align="center" colspan="1"><font color="#ffffff"><strong id='bold7563'
>Basic concepts</strong></font></th></tr>
<tr bgcolor="#ffffff"><td id="tc7568" align="center" colspan="1"><table cellspacing="1" cellpadding="1" width="100%" class="toc">
<tbody>
 <tr><td valign="top" align="left">3.1</td><td colspan="4" width="100%"><a href="r5rs-6.html#Variables;-syntactic-keywords;-and-regions">Variables; syntactic keywords; and regions</a></td></tr>
 <tr><td valign="top" align="left">3.2</td><td colspan="4" width="100%"><a href="r5rs-6.html#Disjointness-of-types">Disjointness of types</a></td></tr>
 <tr><td valign="top" align="left">3.3</td><td colspan="4" width="100%"><a href="r5rs-6.html#External-representations">External representations</a></td></tr>
 <tr><td valign="top" align="left">3.4</td><td colspan="4" width="100%"><a href="r5rs-6.html#Storage-model">Storage model</a></td></tr>
 <tr><td valign="top" align="left">3.5</td><td colspan="4" width="100%"><a href="r5rs-6.html#Proper-tail-recursion">Proper tail recursion</a></td></tr>
</tbody>
</table>
</td></tr>
</tbody></table>
</center>
<br/><br/><center id='center7581'
><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th id="tc7575" align="center" colspan="1"><font color="#ffffff"><strong id='bold7573'
>Chapters</strong></font></th></tr>
<tr bgcolor="#ffffff"><td id="tc7578" align="center" colspan="1"><table cellspacing="1" cellpadding="1" width="100%" class="toc">
<tbody>
 <tr><td valign="top" align="left"></td><td colspan="4" width="100%"><a href="r5rs-1.html#Summary">Summary</a></td></tr>
 <tr><td valign="top" align="left"></td><td colspan="4" width="100%"><a href="r5rs-2.html#Introduction">Introduction</a></td></tr>
 <tr><td valign="top" align="left"></td><td colspan="4" width="100%"><a href="r5rs-3.html#Table-of-contents">Table of contents</a></td></tr>
 <tr><td valign="top" align="left">1</td><td colspan="4" width="100%"><a href="r5rs-4.html#Overview-of-Scheme">Overview of Scheme</a></td></tr>
 <tr><td valign="top" align="left">2</td><td colspan="4" width="100%"><a href="r5rs-5.html#Lexical-conventions">Lexical conventions</a></td></tr>
 <tr><td valign="top" align="left">3</td><td colspan="4" width="100%"><a href="r5rs-6.html#Basic-concepts">Basic concepts</a></td></tr>
 <tr><td valign="top" align="left">4</td><td colspan="4" width="100%"><a href="r5rs-7.html#Expressions">Expressions</a></td></tr>
 <tr><td valign="top" align="left">5</td><td colspan="4" width="100%"><a href="r5rs-8.html#Program-structure">Program structure</a></td></tr>
 <tr><td valign="top" align="left">6</td><td colspan="4" width="100%"><a href="r5rs-9.html#Standard-procedures">Standard procedures</a></td></tr>
 <tr><td valign="top" align="left">7</td><td colspan="4" width="100%"><a href="r5rs-10.html#Formal-syntax-and-semantics">Formal syntax and semantics</a></td></tr>
 <tr><td valign="top" align="left">8</td><td colspan="4" width="100%"><a href="r5rs-11.html#Concepts">Concepts</a></td></tr>
 <tr><td valign="top" align="left">9</td><td colspan="4" width="100%"><a href="r5rs-12.html#Variables-and-Procedures">Variables and Procedures</a></td></tr>
 <tr><td valign="top" align="left"></td><td colspan="4" width="100%"><a href="r5rs-13.html#Notes">Notes</a></td></tr>
 <tr><td valign="top" align="left"></td><td colspan="4" width="100%"><a href="r5rs-14.html#Additional-material">Additional material</a></td></tr>
 <tr><td valign="top" align="left"></td><td colspan="4" width="100%"><a href="r5rs-15.html#Example">Example</a></td></tr>
 <tr><td valign="top" align="left"></td><td colspan="4" width="100%"><a href="r5rs-16.html#Bibliography">Bibliography</a></td></tr>
</tbody>
</table>
</td></tr>
</tbody></table>
</center>
</div></td>
<td align="left" valign="top" class="skribe-body"><div class="skribe-body">
<a name="Basic-concepts" class="mark"></a>

<!-- Variables; syntactic keywords; and regions -->
<a name="Variables;-syntactic-keywords;-and-regions"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.1 Variables; syntactic keywords; and regions</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Variables;-syntactic-keywords;-and-regions" class="mark"></a>
An identifier may name a type of syntax, or it may name
<a name="g1368" class="mark"></a>a location where a value can be stored.  An identifier that names a type
of syntax is called a <em id='emph1370'
>syntactic keyword</em>
<a name="g1372" class="mark"></a>and is said to be <em id='emph1374'
>bound</em> to that syntax.  An identifier that names a
location is called a <em id='emph1375'
>variable</em> and is said to be
<a name="g1377" class="mark"></a><em id='emph1379'
>bound</em> to that location.  The set of all visible
bindings in effect at some point in a program is
<a name="g1381" class="mark"></a>known as the <em id='emph1383'
>environment</em> in effect at that point.  The value
stored in the location to which a variable is bound is called the
variable's value.  By abuse of terminology, the variable is sometimes
said to name the value or to be bound to the value.  This is not quite
accurate, but confusion rarely results from this practice.<br/><br/>

Certain expression types are used to create new kinds of syntax
and bind syntactic keywords to those new syntaxes, while other
expression types create new locations and bind variables to those
locations.  These expression types are called <em id='emph1385'
>binding constructs</em>.<br/><br/><a name="g1388" class="mark"></a>Those that bind syntactic keywords are listed in section <a href="r5rs-7.html#Macros" class="inbound">Macros</a>.
The most fundamental of the variable binding constructs is the
<samp id='samp1390'
>lambda</samp> expression, because all other variable binding constructs
can be explained in terms of <samp id='samp1391'
>lambda</samp> expressions.  The other
variable binding constructs are <samp id='samp1392'
>let</samp>, <samp id='samp1393'
>let*</samp>, <samp id='samp1394'
>letrec</samp>,
and <samp id='samp1395'
>do</samp> expressions (see sections <a href="r5rs-7.html#Procedures" class="inbound">Procedures</a>, <a href="r5rs-7.html#Binding-constructs" class="inbound">Binding constructs</a>, and
<a href="r5rs-7.html#Iteration" class="inbound">Iteration</a>).<br/><br/>
Like Algol and Pascal, and unlike most other dialects of Lisp
except for Common Lisp, Scheme is a statically scoped language with
block structure.  To each place where an identifier is bound in a program
there corresponds a &quot;region&quot; of the program text within which
<a name="g1398" class="mark"></a>the binding is visible.  The region is determined by the particular
binding construct that establishes the binding; if the binding is
established by a <samp id='samp1400'
>lambda</samp> expression, for example, then its region
is the entire <samp id='samp1401'
>lambda</samp> expression.  Every mention of an identifier
refers to the binding of the identifier that established the
innermost of the regions containing the use.  If there is no binding of
the identifier whose region contains the use, then the use refers to the
binding for the variable in the top level environment, if any
(chapters <a href="r5rs-7.html#Expressions" class="inbound">Expressions</a> and <a href="r5rs-9.html#Standard-procedures" class="inbound">Standard procedures</a>); if there is no
binding for the identifier,
it is said to be &quot;unbound&quot;.
<a name="g1403" class="mark"></a><a name="g1406" class="mark"></a><a name="g1409" class="mark"></a>



</div><br>
<!-- Disjointness of types -->
<a name="Disjointness-of-types"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.2 Disjointness of types</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Disjointness-of-types" class="mark"></a>
No object satisfies more than one of the following predicates:<br/><br/><center id='center1414'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1412'
>boolean?          pair?
symbol?           number?
char?             string?
vector?           port?
procedure?
</pre>
</td></tr>
</tbody></table></center>

These predicates define the types <em id='emph1415'
>boolean</em>, <em id='emph1416'
>pair</em>, <em id='emph1417'
>symbol</em>, <em id='emph1418'
>number</em>, <em id='emph1419'
>char</em> (or <em id='emph1420'
>character</em>), <em id='emph1421'
>string</em>, <em id='emph1422'
>vector</em>, <em id='emph1423'
>port</em>, and <em id='emph1424'
>procedure</em>.  The empty list is a special
object of its own type; it satisfies none of the above predicates.<br/><br/><a name="g1426" class="mark"></a><a name="g1428" class="mark"></a><a name="g1430" class="mark"></a><a name="g1433" class="mark"></a>
<a name="g1435" class="mark"></a><a name="g1437" class="mark"></a><a name="g1439" class="mark"></a><a name="g1441" class="mark"></a>
<a name="g1444" class="mark"></a><a name="g1446" class="mark"></a><a name="g1448" class="mark"></a>
Although there is a separate boolean type,
any Scheme value can be used as a boolean value for the purpose of a
conditional test.  As explained in section <a href="r5rs-9.html#Booleans" class="inbound">Booleans</a>, all
values count as true in such a test except for <tt id='tt1450'
>#f</tt>.
This report uses the word ``true'' to refer to any
Scheme value except <tt id='tt1451'
>#f</tt>, and the word ``false'' to refer to
<tt id='tt1452'
>#f</tt>.  
<a name="g1454" class="mark"></a><a name="g1457" class="mark"></a>
</div><br>
<!-- External representations -->
<a name="External-representations"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.3 External representations</font>
</h3></td></tr></table>
</div><div class="section">
<a name="External-representations" class="mark"></a>
An important concept in Scheme (and Lisp) is that of the <em id='emph1459'
>external
representation</em> of an object as a sequence of characters.  For example,
an external representation of the integer 28 is the sequence of
characters ``<tt id='tt1460'
>28</tt>'', and an external representation of a list consisting
of the integers 8 and 13 is the sequence of characters ``<tt id='tt1461'
>(8 13)</tt>''.<br/><br/>The external representation of an object is not necessarily unique.  The
integer 28 also has representations ``<tt id='tt1463'
>#e28.000</tt>'' and ``<tt id='tt1464'
>#x1c</tt>'', and the
list in the previous paragraph also has the representations ``<tt id='tt1465'
>( 08 13
)</tt>'' and ``<tt id='tt1466'
>(8 .: (13 .: ()))</tt>'' (see section <a href="r5rs-9.html#Pairs-and-lists" class="inbound">Pairs and lists</a>).<br/><br/>Many objects have standard external representations, but some, such as
procedures, do not have standard representations (although particular
implementations may define representations for them).<br/><br/>An external representation may be written in a program to obtain the
corresponding object (see <samp id='samp1469'
>quote</samp>, section <a href="r5rs-7.html#Literal-expressions" class="inbound">Literal expressions</a>).<br/><br/>External representations can also be used for input and output.  The
procedure <samp id='samp1471'
>read</samp> (section <a href="r5rs-9.html#Input" class="inbound">Input</a>) parses external
representations, and the procedure <samp id='samp1472'
>write</samp> (section <a href="r5rs-9.html#Output" class="inbound">Output</a>)
generates them.  Together, they provide an elegant and powerful
input/output facility.<br/><br/>Note that the sequence of characters ``<tt id='tt1474'
>(+ 2 6)</tt>'' is <em id='emph1475'
>not</em> an
external representation of the integer 8, even though it <em id='emph1476'
>is</em> an
expression evaluating to the integer 8; rather, it is an external
representation of a three-element list, the elements of which are the symbol
<tt id='tt1477'
>+</tt> and the integers 2 and 6.  Scheme's syntax has the property that
any sequence of characters that is an expression is also the external
representation of some object.  This can lead to confusion, since it may
not be obvious out of context whether a given sequence of characters is
intended to denote data or program, but it is also a source of power,
since it facilitates writing programs such as interpreters and
compilers that treat programs as data (or vice versa).<br/><br/>The syntax of external representations of various kinds of objects
accompanies the description of the primitives for manipulating the
objects in the appropriate sections of chapter <a href="r5rs-9.html#Standard-procedures" class="inbound">Standard procedures</a>.<br/><br/></div><br>
<!-- Storage model -->
<a name="Storage-model"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.4 Storage model</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Storage-model" class="mark"></a>
Variables and objects such as pairs, vectors, and strings implicitly
denote locations or sequences of locations.  A string, for
<a name="g1481" class="mark"></a>example, denotes as many locations as there are characters in the string. 
(These locations need not correspond to a full machine word.) A new value may be
stored into one of these locations using the <tt id='tt1483'
>string-set!</tt> procedure, but
the string continues to denote the same locations as before.<br/><br/>An object fetched from a location, by a variable reference or by
a procedure such as <samp id='samp1485'
>car</samp>, <samp id='samp1486'
>vector-ref</samp>, or <samp id='samp1487'
>string-ref</samp>, is
equivalent in the sense of <code id='code1488'
>eqv?</code> 
(section <a href="r5rs-9.html#Equivalence-predicates" class="inbound">Equivalence predicates</a>)
<a name="g1490" class="mark"></a>to the object last stored in the location before the fetch.<br/><br/>Every location is marked to show whether it is in use.
No variable or object ever refers to a location that is not in use.
Whenever this report speaks of storage being allocated for a variable
or object, what is meant is that an appropriate number of locations are
chosen from the set of locations that are not in use, and the chosen
locations are marked to indicate that they are now in use before the variable
or object is made to denote them.<br/><br/>In many systems it is desirable for constants (i.e. the values of
<a name="g1495" class="mark"></a>literal expressions) to reside in read-only-memory.  To express this, it is
convenient to imagine that every object that denotes locations is associated
with a flag telling whether that object is mutable or
<a name="g1498" class="mark"></a>immutable.  In such systems literal constants and the strings
<a name="g1501" class="mark"></a>returned by <code id='code1503'
>symbol-&gt;string</code> are immutable objects, while all objects
<a name="g1505" class="mark"></a>created by the other procedures listed in this report are mutable.  It is an
error to attempt to store a new value into a location that is denoted by an
immutable object.<br/><br/></div><br>
<!-- Proper tail recursion -->
<a name="Proper-tail-recursion"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.5 Proper tail recursion</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Proper-tail-recursion" class="mark"></a>
Implementations of Scheme are required to be
<em id='emph1508'
>properly tail-recursive</em>.
<a name="g1510" class="mark"></a>Procedure calls that occur in certain syntactic
contexts defined below are `tail calls'.  A Scheme implementation is
properly tail-recursive if it supports an unbounded number of active
tail calls.  A call is <em id='emph1512'
>active</em> if the called procedure may still
return.  Note that this includes calls that may be returned from either
by the current continuation or by continuations captured earlier by
<samp id='samp1513'
>call-with-current-continuation</samp> that are later invoked.
In the absence of captured continuations, calls could
return at most once and the active calls would be those that had not
yet returned.
A formal definition of proper tail recursion can be found
in [propertailrecursion].<br/><br/><br/><em id='emph1516'
>Rationale:</em><br/><br/>Intuitively, no space is needed for an active tail call because the
continuation that is used in the tail call has the same semantics as the
continuation passed to the procedure containing the call.  Although an improper
implementation might use a new continuation in the call, a return
to this new continuation would be followed immediately by a return
to the continuation passed to the procedure.  A properly tail-recursive
implementation returns to that continuation directly.<br/><br/>Proper tail recursion was one of the central ideas in Steele and
Sussman's original version of Scheme.  Their first Scheme interpreter
implemented both functions and actors.  Control flow was expressed using
actors, which differed from functions in that they passed their results
on to another actor instead of returning to a caller.  In the terminology
of this section, each actor finished with a tail call to another actor.<br/><br/>Steele and Sussman later observed that in their interpreter the code
for dealing with actors was identical to that for functions and thus
there was no need to include both in the language.<br/><br/>A <em id='emph1521'
>tail call</em> is a procedure call that occurs
<a name="g1523" class="mark"></a>in a <em id='emph1525'
>tail context</em>.  Tail contexts are defined inductively.  Note
that a tail context is always determined with respect to a particular lambda
expression.<br/><br/><ul class="itemize" id='itemize1554'
><li>The last expression within the body of a lambda expression,
shown as &lt;tail expression&gt; below, occurs in a tail context.<br/><br/><center id='center1531'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ccccff"><pre class="prog" id='prog1529'
><tt id='tt1528'
>(lambda &lt;formals&gt;
  &lt;definition&gt;* &lt;expression&gt;* &lt;tail expression&gt;)
</tt>
</pre>
</td></tr>
</tbody></table></center>

</li>
<li>If one of the following expressions is in a tail context,
then the subexpressions shown as &lt;tail expression&gt; are in a tail context.
These were derived from rules in the grammar given in
chapter <a href="r5rs-10.html#Formal-syntax-and-semantics" class="inbound">Formal syntax and semantics</a> by replacing some occurrences of &lt;expression&gt;
with &lt;tail expression&gt;.  Only those rules that contain tail contexts
are shown here.<br/><br/><center id='center1543'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ccccff"><pre class="prog" id='prog1541'
>(if &lt;expression&gt; &lt;tail expression&gt; &lt;tail expression&gt;)
(if &lt;expression&gt; &lt;tail expression&gt;)<br/><br/>(cond &lt;cond clause&gt;+)
(cond &lt;cond clause&gt;* (else &lt;tail sequence&gt;))<br/><br/>(case &lt;expression&gt;
  &lt;case clause&gt;+)
(case &lt;expression&gt;
  &lt;case clause&gt;*
  (else &lt;tail sequence&gt;))<br/><br/>(and &lt;expression&gt;* &lt;tail expression&gt;)
(or &lt;expression&gt;* &lt;tail expression&gt;)<br/><br/>(let (&lt;binding spec&gt;*) &lt;tail body&gt;)
(let &lt;variable&gt; (&lt;binding spec&gt;*) &lt;tail body&gt;)
(let* (&lt;binding spec&gt;*) &lt;tail body&gt;)
(letrec (&lt;binding spec&gt;*) &lt;tail body&gt;)<br/><br/>(let-syntax (&lt;syntax spec&gt;*) &lt;tail body&gt;)
(letrec-syntax (&lt;syntax spec&gt;*) &lt;tail body&gt;)<br/><br/>(begin &lt;tail sequence&gt;)<br/><br/>(do (&lt;iteration spec&gt;*)
    (&lt;test&gt; &lt;tail sequence&gt;)
  &lt;expression&gt;*)
</pre>
</td></tr>
</tbody></table></center>

<br/>where<br/><br/><center id='center1549'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ccccff"><pre class="prog" id='prog1547'
>&lt;cond clause&gt; --&gt; (&lt;test&gt; &lt;tail sequence&gt;)
&lt;case clause&gt; --&gt; ((&lt;datum&gt;*) &lt;tail sequence&gt;)<br/><br/>&lt;tail body&gt; --&gt; &lt;definition&gt;* &lt;tail sequence&gt;
&lt;tail sequence&gt; --&gt; &lt;expression&gt;* &lt;tail expression&gt;
</pre>
</td></tr>
</tbody></table></center>

</li>
<li>If a <samp id='samp1551'
>cond</samp> expression is in a tail context, and has a clause of
the form <samp id='samp1552'
>(&lt;expression1&gt; =&gt; &lt;expression2&gt;)</samp>
then the (implied) call to
the procedure that results from the evaluation of &lt;expression2&gt; is in a
tail context.  &lt;expression2&gt; itself is not in a tail context.
</li>
</ul>
Certain built-in procedures are also required to perform tail calls.
The first argument passed to <code id='code1555'
>apply</code> and to
<a name="g1557" class="mark"></a><code id='code1559'
>call-with-current-continuation</code>, and the second argument passed to
<a name="g1561" class="mark"></a><code id='code1563'
>call-with-values</code>, must be called via a tail call.
<a name="g1565" class="mark"></a>Similarly, <code id='code1567'
>eval</code> must evaluate its argument as if it
<a name="g1569" class="mark"></a>were in tail position within the <code id='code1571'
>eval</code> procedure.
<a name="g1573" class="mark"></a>
In the following example the only tail call is the call to <samp id='samp1575'
>f</samp>.
None of the calls to <samp id='samp1576'
>g</samp> or <samp id='samp1577'
>h</samp> are tail calls.  The reference to
<samp id='samp1578'
>x</samp> is in a tail context, but it is not a call and thus is not a
tail call.<br/><br/><center id='center1585'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1583'
>(<strong id='bold7582'
>lambda</strong> ()
  (<strong id='bold7583'
>if</strong> (g)
      (<strong id='bold7584'
>let</strong> ((x (h)))
        x)
      (and (g) (f))))
</pre>
</td></tr>
</tbody></table></center>

<em id='emph1586'
>Note:</em>
Implementations are allowed, but not required, to
recognize that some non-tail calls, such as the call to <samp id='samp1587'
>h</samp>
above, can be evaluated as though they were tail calls.
In the example above, the <samp id='samp1588'
>let</samp> expression could be compiled
as a tail call to <samp id='samp1589'
>h</samp>. (The possibility of <samp id='samp1590'
>h</samp> returning
an unexpected number of values can be ignored, because in that
case the effect of the <samp id='samp1591'
>let</samp> is explicitly unspecified and
implementation-dependent.)
       

</div><br>
</div></td>
</tr></table><div class="skribe-ending">
<hr> 
<p class="ending" id='paragraph7590'
><font size="-1">
This <span class="sc">Html</span> page has been produced by 
<a href="http://www-sop.inria.fr/indes/fp/Skribe" class="http">Skribe</a>.
<br/>
Last update <em id='it7588'
>Wed Sep 16 07:50:27 2015</em>.</font></p></div>
</body>
</html>
